// This file was generated by counterfeiter
package simulationfakes

import (
	"sync"
	"time"

	"github.com/3dsim/simulation-goclient/models"
	"github.com/3dsim/simulation-goclient/simulation"
)

type FakeClient struct {
	SimulationsStub        func(organizationID int32, status []string, sort []string, offset, limit int32) ([]*models.Simulation, error)
	simulationsMutex       sync.RWMutex
	simulationsArgsForCall []struct {
		organizationID int32
		status         []string
		sort           []string
		offset         int32
		limit          int32
	}
	simulationsReturns struct {
		result1 []*models.Simulation
		result2 error
	}
	simulationsReturnsOnCall map[int]struct {
		result1 []*models.Simulation
		result2 error
	}
	StartSimulationStub        func(simulationID int32) error
	startSimulationMutex       sync.RWMutex
	startSimulationArgsForCall []struct {
		simulationID int32
	}
	startSimulationReturns struct {
		result1 error
	}
	startSimulationReturnsOnCall map[int]struct {
		result1 error
	}
	ThermalSimulationStub        func(simulationID int32) (*models.ThermalSimulation, error)
	thermalSimulationMutex       sync.RWMutex
	thermalSimulationArgsForCall []struct {
		simulationID int32
	}
	thermalSimulationReturns struct {
		result1 *models.ThermalSimulation
		result2 error
	}
	thermalSimulationReturnsOnCall map[int]struct {
		result1 *models.ThermalSimulation
		result2 error
	}
	SingleBeadSimulationStub        func(simulationID int32) (*models.SingleBeadSimulation, error)
	singleBeadSimulationMutex       sync.RWMutex
	singleBeadSimulationArgsForCall []struct {
		simulationID int32
	}
	singleBeadSimulationReturns struct {
		result1 *models.SingleBeadSimulation
		result2 error
	}
	singleBeadSimulationReturnsOnCall map[int]struct {
		result1 *models.SingleBeadSimulation
		result2 error
	}
	PostAssumedStrainSimulationStub        func(*models.AssumedStrainSimulation) (*models.AssumedStrainSimulation, error)
	postAssumedStrainSimulationMutex       sync.RWMutex
	postAssumedStrainSimulationArgsForCall []struct {
		arg1 *models.AssumedStrainSimulation
	}
	postAssumedStrainSimulationReturns struct {
		result1 *models.AssumedStrainSimulation
		result2 error
	}
	postAssumedStrainSimulationReturnsOnCall map[int]struct {
		result1 *models.AssumedStrainSimulation
		result2 error
	}
	PostPorositySimulationStub        func(*models.PorositySimulation) (*models.PorositySimulation, error)
	postPorositySimulationMutex       sync.RWMutex
	postPorositySimulationArgsForCall []struct {
		arg1 *models.PorositySimulation
	}
	postPorositySimulationReturns struct {
		result1 *models.PorositySimulation
		result2 error
	}
	postPorositySimulationReturnsOnCall map[int]struct {
		result1 *models.PorositySimulation
		result2 error
	}
	PostScanPatternSimulationStub        func(*models.ScanPatternSimulation) (*models.ScanPatternSimulation, error)
	postScanPatternSimulationMutex       sync.RWMutex
	postScanPatternSimulationArgsForCall []struct {
		arg1 *models.ScanPatternSimulation
	}
	postScanPatternSimulationReturns struct {
		result1 *models.ScanPatternSimulation
		result2 error
	}
	postScanPatternSimulationReturnsOnCall map[int]struct {
		result1 *models.ScanPatternSimulation
		result2 error
	}
	PostSingleBeadSimulationStub        func(*models.SingleBeadSimulation) (*models.SingleBeadSimulation, error)
	postSingleBeadSimulationMutex       sync.RWMutex
	postSingleBeadSimulationArgsForCall []struct {
		arg1 *models.SingleBeadSimulation
	}
	postSingleBeadSimulationReturns struct {
		result1 *models.SingleBeadSimulation
		result2 error
	}
	postSingleBeadSimulationReturnsOnCall map[int]struct {
		result1 *models.SingleBeadSimulation
		result2 error
	}
	PostThermalSimulationStub        func(*models.ThermalSimulation) (*models.ThermalSimulation, error)
	postThermalSimulationMutex       sync.RWMutex
	postThermalSimulationArgsForCall []struct {
		arg1 *models.ThermalSimulation
	}
	postThermalSimulationReturns struct {
		result1 *models.ThermalSimulation
		result2 error
	}
	postThermalSimulationReturnsOnCall map[int]struct {
		result1 *models.ThermalSimulation
		result2 error
	}
	MachineStub        func(machineID int32) (*models.Machine, error)
	machineMutex       sync.RWMutex
	machineArgsForCall []struct {
		machineID int32
	}
	machineReturns struct {
		result1 *models.Machine
		result2 error
	}
	machineReturnsOnCall map[int]struct {
		result1 *models.Machine
		result2 error
	}
	MaterialStub        func(materialID int32) (*models.Material, error)
	materialMutex       sync.RWMutex
	materialArgsForCall []struct {
		materialID int32
	}
	materialReturns struct {
		result1 *models.Material
		result2 error
	}
	materialReturnsOnCall map[int]struct {
		result1 *models.Material
		result2 error
	}
	SimulationStub        func(simulationID int32) (*models.Simulation, error)
	simulationMutex       sync.RWMutex
	simulationArgsForCall []struct {
		simulationID int32
	}
	simulationReturns struct {
		result1 *models.Simulation
		result2 error
	}
	simulationReturnsOnCall map[int]struct {
		result1 *models.Simulation
		result2 error
	}
	ScanPatternSimulationStub        func(simulationID int32) (*models.ScanPatternSimulation, error)
	scanPatternSimulationMutex       sync.RWMutex
	scanPatternSimulationArgsForCall []struct {
		simulationID int32
	}
	scanPatternSimulationReturns struct {
		result1 *models.ScanPatternSimulation
		result2 error
	}
	scanPatternSimulationReturnsOnCall map[int]struct {
		result1 *models.ScanPatternSimulation
		result2 error
	}
	AssumedStrainSimulationStub        func(simulationID int32) (*models.AssumedStrainSimulation, error)
	assumedStrainSimulationMutex       sync.RWMutex
	assumedStrainSimulationArgsForCall []struct {
		simulationID int32
	}
	assumedStrainSimulationReturns struct {
		result1 *models.AssumedStrainSimulation
		result2 error
	}
	assumedStrainSimulationReturnsOnCall map[int]struct {
		result1 *models.AssumedStrainSimulation
		result2 error
	}
	PorositySimulationStub        func(simulationID int32) (*models.PorositySimulation, error)
	porositySimulationMutex       sync.RWMutex
	porositySimulationArgsForCall []struct {
		simulationID int32
	}
	porositySimulationReturns struct {
		result1 *models.PorositySimulation
		result2 error
	}
	porositySimulationReturnsOnCall map[int]struct {
		result1 *models.PorositySimulation
		result2 error
	}
	PostLogWithTimeStub        func(simulationID int32, messageDate time.Time, message string) error
	postLogWithTimeMutex       sync.RWMutex
	postLogWithTimeArgsForCall []struct {
		simulationID int32
		messageDate  time.Time
		message      string
	}
	postLogWithTimeReturns struct {
		result1 error
	}
	postLogWithTimeReturnsOnCall map[int]struct {
		result1 error
	}
	PostLogStub        func(simulationID int32, message string) error
	postLogMutex       sync.RWMutex
	postLogArgsForCall []struct {
		simulationID int32
		message      string
	}
	postLogReturns struct {
		result1 error
	}
	postLogReturnsOnCall map[int]struct {
		result1 error
	}
	PatchSimulationStub        func(simulationID int32, patch *models.PatchDocument) error
	patchSimulationMutex       sync.RWMutex
	patchSimulationArgsForCall []struct {
		simulationID int32
		patch        *models.PatchDocument
	}
	patchSimulationReturns struct {
		result1 error
	}
	patchSimulationReturnsOnCall map[int]struct {
		result1 error
	}
	MultiPatchSimulationStub        func(simulationID int32, patches []*models.PatchDocument) error
	multiPatchSimulationMutex       sync.RWMutex
	multiPatchSimulationArgsForCall []struct {
		simulationID int32
		patches      []*models.PatchDocument
	}
	multiPatchSimulationReturns struct {
		result1 error
	}
	multiPatchSimulationReturnsOnCall map[int]struct {
		result1 error
	}
	PostSimulationActivityStub        func(simulationID int32, simulationActivity *models.SimulationActivity) (*models.SimulationActivity, error)
	postSimulationActivityMutex       sync.RWMutex
	postSimulationActivityArgsForCall []struct {
		simulationID       int32
		simulationActivity *models.SimulationActivity
	}
	postSimulationActivityReturns struct {
		result1 *models.SimulationActivity
		result2 error
	}
	postSimulationActivityReturnsOnCall map[int]struct {
		result1 *models.SimulationActivity
		result2 error
	}
	SimulationActivityByActivityIDStub        func(simulationID int32, activityID string) (*models.SimulationActivity, error)
	simulationActivityByActivityIDMutex       sync.RWMutex
	simulationActivityByActivityIDArgsForCall []struct {
		simulationID int32
		activityID   string
	}
	simulationActivityByActivityIDReturns struct {
		result1 *models.SimulationActivity
		result2 error
	}
	simulationActivityByActivityIDReturnsOnCall map[int]struct {
		result1 *models.SimulationActivity
		result2 error
	}
	PutSimulationActivityStub        func(simulationID int32, simulationActivity *models.SimulationActivity) error
	putSimulationActivityMutex       sync.RWMutex
	putSimulationActivityArgsForCall []struct {
		simulationID       int32
		simulationActivity *models.SimulationActivity
	}
	putSimulationActivityReturns struct {
		result1 error
	}
	putSimulationActivityReturnsOnCall map[int]struct {
		result1 error
	}
	AddSimulationOutputStub        func(simulationID int32, outputType, outputFileLocation string) (*models.SimulationOutput, error)
	addSimulationOutputMutex       sync.RWMutex
	addSimulationOutputArgsForCall []struct {
		simulationID       int32
		outputType         string
		outputFileLocation string
	}
	addSimulationOutputReturns struct {
		result1 *models.SimulationOutput
		result2 error
	}
	addSimulationOutputReturnsOnCall map[int]struct {
		result1 *models.SimulationOutput
		result2 error
	}
	UpdateSimulationStatusStub        func(simulationID int32, status string) error
	updateSimulationStatusMutex       sync.RWMutex
	updateSimulationStatusArgsForCall []struct {
		simulationID int32
		status       string
	}
	updateSimulationStatusReturns struct {
		result1 error
	}
	updateSimulationStatusReturnsOnCall map[int]struct {
		result1 error
	}
	RawSimulationStub        func(simulationID int32) (map[string]interface{}, error)
	rawSimulationMutex       sync.RWMutex
	rawSimulationArgsForCall []struct {
		simulationID int32
	}
	rawSimulationReturns struct {
		result1 map[string]interface{}
		result2 error
	}
	rawSimulationReturnsOnCall map[int]struct {
		result1 map[string]interface{}
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) Simulations(organizationID int32, status []string, sort []string, offset int32, limit int32) ([]*models.Simulation, error) {
	var statusCopy []string
	if status != nil {
		statusCopy = make([]string, len(status))
		copy(statusCopy, status)
	}
	var sortCopy []string
	if sort != nil {
		sortCopy = make([]string, len(sort))
		copy(sortCopy, sort)
	}
	fake.simulationsMutex.Lock()
	ret, specificReturn := fake.simulationsReturnsOnCall[len(fake.simulationsArgsForCall)]
	fake.simulationsArgsForCall = append(fake.simulationsArgsForCall, struct {
		organizationID int32
		status         []string
		sort           []string
		offset         int32
		limit          int32
	}{organizationID, statusCopy, sortCopy, offset, limit})
	fake.recordInvocation("Simulations", []interface{}{organizationID, statusCopy, sortCopy, offset, limit})
	fake.simulationsMutex.Unlock()
	if fake.SimulationsStub != nil {
		return fake.SimulationsStub(organizationID, status, sort, offset, limit)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.simulationsReturns.result1, fake.simulationsReturns.result2
}

func (fake *FakeClient) SimulationsCallCount() int {
	fake.simulationsMutex.RLock()
	defer fake.simulationsMutex.RUnlock()
	return len(fake.simulationsArgsForCall)
}

func (fake *FakeClient) SimulationsArgsForCall(i int) (int32, []string, []string, int32, int32) {
	fake.simulationsMutex.RLock()
	defer fake.simulationsMutex.RUnlock()
	return fake.simulationsArgsForCall[i].organizationID, fake.simulationsArgsForCall[i].status, fake.simulationsArgsForCall[i].sort, fake.simulationsArgsForCall[i].offset, fake.simulationsArgsForCall[i].limit
}

func (fake *FakeClient) SimulationsReturns(result1 []*models.Simulation, result2 error) {
	fake.SimulationsStub = nil
	fake.simulationsReturns = struct {
		result1 []*models.Simulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SimulationsReturnsOnCall(i int, result1 []*models.Simulation, result2 error) {
	fake.SimulationsStub = nil
	if fake.simulationsReturnsOnCall == nil {
		fake.simulationsReturnsOnCall = make(map[int]struct {
			result1 []*models.Simulation
			result2 error
		})
	}
	fake.simulationsReturnsOnCall[i] = struct {
		result1 []*models.Simulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) StartSimulation(simulationID int32) error {
	fake.startSimulationMutex.Lock()
	ret, specificReturn := fake.startSimulationReturnsOnCall[len(fake.startSimulationArgsForCall)]
	fake.startSimulationArgsForCall = append(fake.startSimulationArgsForCall, struct {
		simulationID int32
	}{simulationID})
	fake.recordInvocation("StartSimulation", []interface{}{simulationID})
	fake.startSimulationMutex.Unlock()
	if fake.StartSimulationStub != nil {
		return fake.StartSimulationStub(simulationID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.startSimulationReturns.result1
}

func (fake *FakeClient) StartSimulationCallCount() int {
	fake.startSimulationMutex.RLock()
	defer fake.startSimulationMutex.RUnlock()
	return len(fake.startSimulationArgsForCall)
}

func (fake *FakeClient) StartSimulationArgsForCall(i int) int32 {
	fake.startSimulationMutex.RLock()
	defer fake.startSimulationMutex.RUnlock()
	return fake.startSimulationArgsForCall[i].simulationID
}

func (fake *FakeClient) StartSimulationReturns(result1 error) {
	fake.StartSimulationStub = nil
	fake.startSimulationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) StartSimulationReturnsOnCall(i int, result1 error) {
	fake.StartSimulationStub = nil
	if fake.startSimulationReturnsOnCall == nil {
		fake.startSimulationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startSimulationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ThermalSimulation(simulationID int32) (*models.ThermalSimulation, error) {
	fake.thermalSimulationMutex.Lock()
	ret, specificReturn := fake.thermalSimulationReturnsOnCall[len(fake.thermalSimulationArgsForCall)]
	fake.thermalSimulationArgsForCall = append(fake.thermalSimulationArgsForCall, struct {
		simulationID int32
	}{simulationID})
	fake.recordInvocation("ThermalSimulation", []interface{}{simulationID})
	fake.thermalSimulationMutex.Unlock()
	if fake.ThermalSimulationStub != nil {
		return fake.ThermalSimulationStub(simulationID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.thermalSimulationReturns.result1, fake.thermalSimulationReturns.result2
}

func (fake *FakeClient) ThermalSimulationCallCount() int {
	fake.thermalSimulationMutex.RLock()
	defer fake.thermalSimulationMutex.RUnlock()
	return len(fake.thermalSimulationArgsForCall)
}

func (fake *FakeClient) ThermalSimulationArgsForCall(i int) int32 {
	fake.thermalSimulationMutex.RLock()
	defer fake.thermalSimulationMutex.RUnlock()
	return fake.thermalSimulationArgsForCall[i].simulationID
}

func (fake *FakeClient) ThermalSimulationReturns(result1 *models.ThermalSimulation, result2 error) {
	fake.ThermalSimulationStub = nil
	fake.thermalSimulationReturns = struct {
		result1 *models.ThermalSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ThermalSimulationReturnsOnCall(i int, result1 *models.ThermalSimulation, result2 error) {
	fake.ThermalSimulationStub = nil
	if fake.thermalSimulationReturnsOnCall == nil {
		fake.thermalSimulationReturnsOnCall = make(map[int]struct {
			result1 *models.ThermalSimulation
			result2 error
		})
	}
	fake.thermalSimulationReturnsOnCall[i] = struct {
		result1 *models.ThermalSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SingleBeadSimulation(simulationID int32) (*models.SingleBeadSimulation, error) {
	fake.singleBeadSimulationMutex.Lock()
	ret, specificReturn := fake.singleBeadSimulationReturnsOnCall[len(fake.singleBeadSimulationArgsForCall)]
	fake.singleBeadSimulationArgsForCall = append(fake.singleBeadSimulationArgsForCall, struct {
		simulationID int32
	}{simulationID})
	fake.recordInvocation("SingleBeadSimulation", []interface{}{simulationID})
	fake.singleBeadSimulationMutex.Unlock()
	if fake.SingleBeadSimulationStub != nil {
		return fake.SingleBeadSimulationStub(simulationID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.singleBeadSimulationReturns.result1, fake.singleBeadSimulationReturns.result2
}

func (fake *FakeClient) SingleBeadSimulationCallCount() int {
	fake.singleBeadSimulationMutex.RLock()
	defer fake.singleBeadSimulationMutex.RUnlock()
	return len(fake.singleBeadSimulationArgsForCall)
}

func (fake *FakeClient) SingleBeadSimulationArgsForCall(i int) int32 {
	fake.singleBeadSimulationMutex.RLock()
	defer fake.singleBeadSimulationMutex.RUnlock()
	return fake.singleBeadSimulationArgsForCall[i].simulationID
}

func (fake *FakeClient) SingleBeadSimulationReturns(result1 *models.SingleBeadSimulation, result2 error) {
	fake.SingleBeadSimulationStub = nil
	fake.singleBeadSimulationReturns = struct {
		result1 *models.SingleBeadSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SingleBeadSimulationReturnsOnCall(i int, result1 *models.SingleBeadSimulation, result2 error) {
	fake.SingleBeadSimulationStub = nil
	if fake.singleBeadSimulationReturnsOnCall == nil {
		fake.singleBeadSimulationReturnsOnCall = make(map[int]struct {
			result1 *models.SingleBeadSimulation
			result2 error
		})
	}
	fake.singleBeadSimulationReturnsOnCall[i] = struct {
		result1 *models.SingleBeadSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostAssumedStrainSimulation(arg1 *models.AssumedStrainSimulation) (*models.AssumedStrainSimulation, error) {
	fake.postAssumedStrainSimulationMutex.Lock()
	ret, specificReturn := fake.postAssumedStrainSimulationReturnsOnCall[len(fake.postAssumedStrainSimulationArgsForCall)]
	fake.postAssumedStrainSimulationArgsForCall = append(fake.postAssumedStrainSimulationArgsForCall, struct {
		arg1 *models.AssumedStrainSimulation
	}{arg1})
	fake.recordInvocation("PostAssumedStrainSimulation", []interface{}{arg1})
	fake.postAssumedStrainSimulationMutex.Unlock()
	if fake.PostAssumedStrainSimulationStub != nil {
		return fake.PostAssumedStrainSimulationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.postAssumedStrainSimulationReturns.result1, fake.postAssumedStrainSimulationReturns.result2
}

func (fake *FakeClient) PostAssumedStrainSimulationCallCount() int {
	fake.postAssumedStrainSimulationMutex.RLock()
	defer fake.postAssumedStrainSimulationMutex.RUnlock()
	return len(fake.postAssumedStrainSimulationArgsForCall)
}

func (fake *FakeClient) PostAssumedStrainSimulationArgsForCall(i int) *models.AssumedStrainSimulation {
	fake.postAssumedStrainSimulationMutex.RLock()
	defer fake.postAssumedStrainSimulationMutex.RUnlock()
	return fake.postAssumedStrainSimulationArgsForCall[i].arg1
}

func (fake *FakeClient) PostAssumedStrainSimulationReturns(result1 *models.AssumedStrainSimulation, result2 error) {
	fake.PostAssumedStrainSimulationStub = nil
	fake.postAssumedStrainSimulationReturns = struct {
		result1 *models.AssumedStrainSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostAssumedStrainSimulationReturnsOnCall(i int, result1 *models.AssumedStrainSimulation, result2 error) {
	fake.PostAssumedStrainSimulationStub = nil
	if fake.postAssumedStrainSimulationReturnsOnCall == nil {
		fake.postAssumedStrainSimulationReturnsOnCall = make(map[int]struct {
			result1 *models.AssumedStrainSimulation
			result2 error
		})
	}
	fake.postAssumedStrainSimulationReturnsOnCall[i] = struct {
		result1 *models.AssumedStrainSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostPorositySimulation(arg1 *models.PorositySimulation) (*models.PorositySimulation, error) {
	fake.postPorositySimulationMutex.Lock()
	ret, specificReturn := fake.postPorositySimulationReturnsOnCall[len(fake.postPorositySimulationArgsForCall)]
	fake.postPorositySimulationArgsForCall = append(fake.postPorositySimulationArgsForCall, struct {
		arg1 *models.PorositySimulation
	}{arg1})
	fake.recordInvocation("PostPorositySimulation", []interface{}{arg1})
	fake.postPorositySimulationMutex.Unlock()
	if fake.PostPorositySimulationStub != nil {
		return fake.PostPorositySimulationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.postPorositySimulationReturns.result1, fake.postPorositySimulationReturns.result2
}

func (fake *FakeClient) PostPorositySimulationCallCount() int {
	fake.postPorositySimulationMutex.RLock()
	defer fake.postPorositySimulationMutex.RUnlock()
	return len(fake.postPorositySimulationArgsForCall)
}

func (fake *FakeClient) PostPorositySimulationArgsForCall(i int) *models.PorositySimulation {
	fake.postPorositySimulationMutex.RLock()
	defer fake.postPorositySimulationMutex.RUnlock()
	return fake.postPorositySimulationArgsForCall[i].arg1
}

func (fake *FakeClient) PostPorositySimulationReturns(result1 *models.PorositySimulation, result2 error) {
	fake.PostPorositySimulationStub = nil
	fake.postPorositySimulationReturns = struct {
		result1 *models.PorositySimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostPorositySimulationReturnsOnCall(i int, result1 *models.PorositySimulation, result2 error) {
	fake.PostPorositySimulationStub = nil
	if fake.postPorositySimulationReturnsOnCall == nil {
		fake.postPorositySimulationReturnsOnCall = make(map[int]struct {
			result1 *models.PorositySimulation
			result2 error
		})
	}
	fake.postPorositySimulationReturnsOnCall[i] = struct {
		result1 *models.PorositySimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostScanPatternSimulation(arg1 *models.ScanPatternSimulation) (*models.ScanPatternSimulation, error) {
	fake.postScanPatternSimulationMutex.Lock()
	ret, specificReturn := fake.postScanPatternSimulationReturnsOnCall[len(fake.postScanPatternSimulationArgsForCall)]
	fake.postScanPatternSimulationArgsForCall = append(fake.postScanPatternSimulationArgsForCall, struct {
		arg1 *models.ScanPatternSimulation
	}{arg1})
	fake.recordInvocation("PostScanPatternSimulation", []interface{}{arg1})
	fake.postScanPatternSimulationMutex.Unlock()
	if fake.PostScanPatternSimulationStub != nil {
		return fake.PostScanPatternSimulationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.postScanPatternSimulationReturns.result1, fake.postScanPatternSimulationReturns.result2
}

func (fake *FakeClient) PostScanPatternSimulationCallCount() int {
	fake.postScanPatternSimulationMutex.RLock()
	defer fake.postScanPatternSimulationMutex.RUnlock()
	return len(fake.postScanPatternSimulationArgsForCall)
}

func (fake *FakeClient) PostScanPatternSimulationArgsForCall(i int) *models.ScanPatternSimulation {
	fake.postScanPatternSimulationMutex.RLock()
	defer fake.postScanPatternSimulationMutex.RUnlock()
	return fake.postScanPatternSimulationArgsForCall[i].arg1
}

func (fake *FakeClient) PostScanPatternSimulationReturns(result1 *models.ScanPatternSimulation, result2 error) {
	fake.PostScanPatternSimulationStub = nil
	fake.postScanPatternSimulationReturns = struct {
		result1 *models.ScanPatternSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostScanPatternSimulationReturnsOnCall(i int, result1 *models.ScanPatternSimulation, result2 error) {
	fake.PostScanPatternSimulationStub = nil
	if fake.postScanPatternSimulationReturnsOnCall == nil {
		fake.postScanPatternSimulationReturnsOnCall = make(map[int]struct {
			result1 *models.ScanPatternSimulation
			result2 error
		})
	}
	fake.postScanPatternSimulationReturnsOnCall[i] = struct {
		result1 *models.ScanPatternSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostSingleBeadSimulation(arg1 *models.SingleBeadSimulation) (*models.SingleBeadSimulation, error) {
	fake.postSingleBeadSimulationMutex.Lock()
	ret, specificReturn := fake.postSingleBeadSimulationReturnsOnCall[len(fake.postSingleBeadSimulationArgsForCall)]
	fake.postSingleBeadSimulationArgsForCall = append(fake.postSingleBeadSimulationArgsForCall, struct {
		arg1 *models.SingleBeadSimulation
	}{arg1})
	fake.recordInvocation("PostSingleBeadSimulation", []interface{}{arg1})
	fake.postSingleBeadSimulationMutex.Unlock()
	if fake.PostSingleBeadSimulationStub != nil {
		return fake.PostSingleBeadSimulationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.postSingleBeadSimulationReturns.result1, fake.postSingleBeadSimulationReturns.result2
}

func (fake *FakeClient) PostSingleBeadSimulationCallCount() int {
	fake.postSingleBeadSimulationMutex.RLock()
	defer fake.postSingleBeadSimulationMutex.RUnlock()
	return len(fake.postSingleBeadSimulationArgsForCall)
}

func (fake *FakeClient) PostSingleBeadSimulationArgsForCall(i int) *models.SingleBeadSimulation {
	fake.postSingleBeadSimulationMutex.RLock()
	defer fake.postSingleBeadSimulationMutex.RUnlock()
	return fake.postSingleBeadSimulationArgsForCall[i].arg1
}

func (fake *FakeClient) PostSingleBeadSimulationReturns(result1 *models.SingleBeadSimulation, result2 error) {
	fake.PostSingleBeadSimulationStub = nil
	fake.postSingleBeadSimulationReturns = struct {
		result1 *models.SingleBeadSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostSingleBeadSimulationReturnsOnCall(i int, result1 *models.SingleBeadSimulation, result2 error) {
	fake.PostSingleBeadSimulationStub = nil
	if fake.postSingleBeadSimulationReturnsOnCall == nil {
		fake.postSingleBeadSimulationReturnsOnCall = make(map[int]struct {
			result1 *models.SingleBeadSimulation
			result2 error
		})
	}
	fake.postSingleBeadSimulationReturnsOnCall[i] = struct {
		result1 *models.SingleBeadSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostThermalSimulation(arg1 *models.ThermalSimulation) (*models.ThermalSimulation, error) {
	fake.postThermalSimulationMutex.Lock()
	ret, specificReturn := fake.postThermalSimulationReturnsOnCall[len(fake.postThermalSimulationArgsForCall)]
	fake.postThermalSimulationArgsForCall = append(fake.postThermalSimulationArgsForCall, struct {
		arg1 *models.ThermalSimulation
	}{arg1})
	fake.recordInvocation("PostThermalSimulation", []interface{}{arg1})
	fake.postThermalSimulationMutex.Unlock()
	if fake.PostThermalSimulationStub != nil {
		return fake.PostThermalSimulationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.postThermalSimulationReturns.result1, fake.postThermalSimulationReturns.result2
}

func (fake *FakeClient) PostThermalSimulationCallCount() int {
	fake.postThermalSimulationMutex.RLock()
	defer fake.postThermalSimulationMutex.RUnlock()
	return len(fake.postThermalSimulationArgsForCall)
}

func (fake *FakeClient) PostThermalSimulationArgsForCall(i int) *models.ThermalSimulation {
	fake.postThermalSimulationMutex.RLock()
	defer fake.postThermalSimulationMutex.RUnlock()
	return fake.postThermalSimulationArgsForCall[i].arg1
}

func (fake *FakeClient) PostThermalSimulationReturns(result1 *models.ThermalSimulation, result2 error) {
	fake.PostThermalSimulationStub = nil
	fake.postThermalSimulationReturns = struct {
		result1 *models.ThermalSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostThermalSimulationReturnsOnCall(i int, result1 *models.ThermalSimulation, result2 error) {
	fake.PostThermalSimulationStub = nil
	if fake.postThermalSimulationReturnsOnCall == nil {
		fake.postThermalSimulationReturnsOnCall = make(map[int]struct {
			result1 *models.ThermalSimulation
			result2 error
		})
	}
	fake.postThermalSimulationReturnsOnCall[i] = struct {
		result1 *models.ThermalSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Machine(machineID int32) (*models.Machine, error) {
	fake.machineMutex.Lock()
	ret, specificReturn := fake.machineReturnsOnCall[len(fake.machineArgsForCall)]
	fake.machineArgsForCall = append(fake.machineArgsForCall, struct {
		machineID int32
	}{machineID})
	fake.recordInvocation("Machine", []interface{}{machineID})
	fake.machineMutex.Unlock()
	if fake.MachineStub != nil {
		return fake.MachineStub(machineID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.machineReturns.result1, fake.machineReturns.result2
}

func (fake *FakeClient) MachineCallCount() int {
	fake.machineMutex.RLock()
	defer fake.machineMutex.RUnlock()
	return len(fake.machineArgsForCall)
}

func (fake *FakeClient) MachineArgsForCall(i int) int32 {
	fake.machineMutex.RLock()
	defer fake.machineMutex.RUnlock()
	return fake.machineArgsForCall[i].machineID
}

func (fake *FakeClient) MachineReturns(result1 *models.Machine, result2 error) {
	fake.MachineStub = nil
	fake.machineReturns = struct {
		result1 *models.Machine
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) MachineReturnsOnCall(i int, result1 *models.Machine, result2 error) {
	fake.MachineStub = nil
	if fake.machineReturnsOnCall == nil {
		fake.machineReturnsOnCall = make(map[int]struct {
			result1 *models.Machine
			result2 error
		})
	}
	fake.machineReturnsOnCall[i] = struct {
		result1 *models.Machine
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Material(materialID int32) (*models.Material, error) {
	fake.materialMutex.Lock()
	ret, specificReturn := fake.materialReturnsOnCall[len(fake.materialArgsForCall)]
	fake.materialArgsForCall = append(fake.materialArgsForCall, struct {
		materialID int32
	}{materialID})
	fake.recordInvocation("Material", []interface{}{materialID})
	fake.materialMutex.Unlock()
	if fake.MaterialStub != nil {
		return fake.MaterialStub(materialID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.materialReturns.result1, fake.materialReturns.result2
}

func (fake *FakeClient) MaterialCallCount() int {
	fake.materialMutex.RLock()
	defer fake.materialMutex.RUnlock()
	return len(fake.materialArgsForCall)
}

func (fake *FakeClient) MaterialArgsForCall(i int) int32 {
	fake.materialMutex.RLock()
	defer fake.materialMutex.RUnlock()
	return fake.materialArgsForCall[i].materialID
}

func (fake *FakeClient) MaterialReturns(result1 *models.Material, result2 error) {
	fake.MaterialStub = nil
	fake.materialReturns = struct {
		result1 *models.Material
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) MaterialReturnsOnCall(i int, result1 *models.Material, result2 error) {
	fake.MaterialStub = nil
	if fake.materialReturnsOnCall == nil {
		fake.materialReturnsOnCall = make(map[int]struct {
			result1 *models.Material
			result2 error
		})
	}
	fake.materialReturnsOnCall[i] = struct {
		result1 *models.Material
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Simulation(simulationID int32) (*models.Simulation, error) {
	fake.simulationMutex.Lock()
	ret, specificReturn := fake.simulationReturnsOnCall[len(fake.simulationArgsForCall)]
	fake.simulationArgsForCall = append(fake.simulationArgsForCall, struct {
		simulationID int32
	}{simulationID})
	fake.recordInvocation("Simulation", []interface{}{simulationID})
	fake.simulationMutex.Unlock()
	if fake.SimulationStub != nil {
		return fake.SimulationStub(simulationID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.simulationReturns.result1, fake.simulationReturns.result2
}

func (fake *FakeClient) SimulationCallCount() int {
	fake.simulationMutex.RLock()
	defer fake.simulationMutex.RUnlock()
	return len(fake.simulationArgsForCall)
}

func (fake *FakeClient) SimulationArgsForCall(i int) int32 {
	fake.simulationMutex.RLock()
	defer fake.simulationMutex.RUnlock()
	return fake.simulationArgsForCall[i].simulationID
}

func (fake *FakeClient) SimulationReturns(result1 *models.Simulation, result2 error) {
	fake.SimulationStub = nil
	fake.simulationReturns = struct {
		result1 *models.Simulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SimulationReturnsOnCall(i int, result1 *models.Simulation, result2 error) {
	fake.SimulationStub = nil
	if fake.simulationReturnsOnCall == nil {
		fake.simulationReturnsOnCall = make(map[int]struct {
			result1 *models.Simulation
			result2 error
		})
	}
	fake.simulationReturnsOnCall[i] = struct {
		result1 *models.Simulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ScanPatternSimulation(simulationID int32) (*models.ScanPatternSimulation, error) {
	fake.scanPatternSimulationMutex.Lock()
	ret, specificReturn := fake.scanPatternSimulationReturnsOnCall[len(fake.scanPatternSimulationArgsForCall)]
	fake.scanPatternSimulationArgsForCall = append(fake.scanPatternSimulationArgsForCall, struct {
		simulationID int32
	}{simulationID})
	fake.recordInvocation("ScanPatternSimulation", []interface{}{simulationID})
	fake.scanPatternSimulationMutex.Unlock()
	if fake.ScanPatternSimulationStub != nil {
		return fake.ScanPatternSimulationStub(simulationID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.scanPatternSimulationReturns.result1, fake.scanPatternSimulationReturns.result2
}

func (fake *FakeClient) ScanPatternSimulationCallCount() int {
	fake.scanPatternSimulationMutex.RLock()
	defer fake.scanPatternSimulationMutex.RUnlock()
	return len(fake.scanPatternSimulationArgsForCall)
}

func (fake *FakeClient) ScanPatternSimulationArgsForCall(i int) int32 {
	fake.scanPatternSimulationMutex.RLock()
	defer fake.scanPatternSimulationMutex.RUnlock()
	return fake.scanPatternSimulationArgsForCall[i].simulationID
}

func (fake *FakeClient) ScanPatternSimulationReturns(result1 *models.ScanPatternSimulation, result2 error) {
	fake.ScanPatternSimulationStub = nil
	fake.scanPatternSimulationReturns = struct {
		result1 *models.ScanPatternSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ScanPatternSimulationReturnsOnCall(i int, result1 *models.ScanPatternSimulation, result2 error) {
	fake.ScanPatternSimulationStub = nil
	if fake.scanPatternSimulationReturnsOnCall == nil {
		fake.scanPatternSimulationReturnsOnCall = make(map[int]struct {
			result1 *models.ScanPatternSimulation
			result2 error
		})
	}
	fake.scanPatternSimulationReturnsOnCall[i] = struct {
		result1 *models.ScanPatternSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) AssumedStrainSimulation(simulationID int32) (*models.AssumedStrainSimulation, error) {
	fake.assumedStrainSimulationMutex.Lock()
	ret, specificReturn := fake.assumedStrainSimulationReturnsOnCall[len(fake.assumedStrainSimulationArgsForCall)]
	fake.assumedStrainSimulationArgsForCall = append(fake.assumedStrainSimulationArgsForCall, struct {
		simulationID int32
	}{simulationID})
	fake.recordInvocation("AssumedStrainSimulation", []interface{}{simulationID})
	fake.assumedStrainSimulationMutex.Unlock()
	if fake.AssumedStrainSimulationStub != nil {
		return fake.AssumedStrainSimulationStub(simulationID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.assumedStrainSimulationReturns.result1, fake.assumedStrainSimulationReturns.result2
}

func (fake *FakeClient) AssumedStrainSimulationCallCount() int {
	fake.assumedStrainSimulationMutex.RLock()
	defer fake.assumedStrainSimulationMutex.RUnlock()
	return len(fake.assumedStrainSimulationArgsForCall)
}

func (fake *FakeClient) AssumedStrainSimulationArgsForCall(i int) int32 {
	fake.assumedStrainSimulationMutex.RLock()
	defer fake.assumedStrainSimulationMutex.RUnlock()
	return fake.assumedStrainSimulationArgsForCall[i].simulationID
}

func (fake *FakeClient) AssumedStrainSimulationReturns(result1 *models.AssumedStrainSimulation, result2 error) {
	fake.AssumedStrainSimulationStub = nil
	fake.assumedStrainSimulationReturns = struct {
		result1 *models.AssumedStrainSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) AssumedStrainSimulationReturnsOnCall(i int, result1 *models.AssumedStrainSimulation, result2 error) {
	fake.AssumedStrainSimulationStub = nil
	if fake.assumedStrainSimulationReturnsOnCall == nil {
		fake.assumedStrainSimulationReturnsOnCall = make(map[int]struct {
			result1 *models.AssumedStrainSimulation
			result2 error
		})
	}
	fake.assumedStrainSimulationReturnsOnCall[i] = struct {
		result1 *models.AssumedStrainSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PorositySimulation(simulationID int32) (*models.PorositySimulation, error) {
	fake.porositySimulationMutex.Lock()
	ret, specificReturn := fake.porositySimulationReturnsOnCall[len(fake.porositySimulationArgsForCall)]
	fake.porositySimulationArgsForCall = append(fake.porositySimulationArgsForCall, struct {
		simulationID int32
	}{simulationID})
	fake.recordInvocation("PorositySimulation", []interface{}{simulationID})
	fake.porositySimulationMutex.Unlock()
	if fake.PorositySimulationStub != nil {
		return fake.PorositySimulationStub(simulationID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.porositySimulationReturns.result1, fake.porositySimulationReturns.result2
}

func (fake *FakeClient) PorositySimulationCallCount() int {
	fake.porositySimulationMutex.RLock()
	defer fake.porositySimulationMutex.RUnlock()
	return len(fake.porositySimulationArgsForCall)
}

func (fake *FakeClient) PorositySimulationArgsForCall(i int) int32 {
	fake.porositySimulationMutex.RLock()
	defer fake.porositySimulationMutex.RUnlock()
	return fake.porositySimulationArgsForCall[i].simulationID
}

func (fake *FakeClient) PorositySimulationReturns(result1 *models.PorositySimulation, result2 error) {
	fake.PorositySimulationStub = nil
	fake.porositySimulationReturns = struct {
		result1 *models.PorositySimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PorositySimulationReturnsOnCall(i int, result1 *models.PorositySimulation, result2 error) {
	fake.PorositySimulationStub = nil
	if fake.porositySimulationReturnsOnCall == nil {
		fake.porositySimulationReturnsOnCall = make(map[int]struct {
			result1 *models.PorositySimulation
			result2 error
		})
	}
	fake.porositySimulationReturnsOnCall[i] = struct {
		result1 *models.PorositySimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostLogWithTime(simulationID int32, messageDate time.Time, message string) error {
	fake.postLogWithTimeMutex.Lock()
	ret, specificReturn := fake.postLogWithTimeReturnsOnCall[len(fake.postLogWithTimeArgsForCall)]
	fake.postLogWithTimeArgsForCall = append(fake.postLogWithTimeArgsForCall, struct {
		simulationID int32
		messageDate  time.Time
		message      string
	}{simulationID, messageDate, message})
	fake.recordInvocation("PostLogWithTime", []interface{}{simulationID, messageDate, message})
	fake.postLogWithTimeMutex.Unlock()
	if fake.PostLogWithTimeStub != nil {
		return fake.PostLogWithTimeStub(simulationID, messageDate, message)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.postLogWithTimeReturns.result1
}

func (fake *FakeClient) PostLogWithTimeCallCount() int {
	fake.postLogWithTimeMutex.RLock()
	defer fake.postLogWithTimeMutex.RUnlock()
	return len(fake.postLogWithTimeArgsForCall)
}

func (fake *FakeClient) PostLogWithTimeArgsForCall(i int) (int32, time.Time, string) {
	fake.postLogWithTimeMutex.RLock()
	defer fake.postLogWithTimeMutex.RUnlock()
	return fake.postLogWithTimeArgsForCall[i].simulationID, fake.postLogWithTimeArgsForCall[i].messageDate, fake.postLogWithTimeArgsForCall[i].message
}

func (fake *FakeClient) PostLogWithTimeReturns(result1 error) {
	fake.PostLogWithTimeStub = nil
	fake.postLogWithTimeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PostLogWithTimeReturnsOnCall(i int, result1 error) {
	fake.PostLogWithTimeStub = nil
	if fake.postLogWithTimeReturnsOnCall == nil {
		fake.postLogWithTimeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.postLogWithTimeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PostLog(simulationID int32, message string) error {
	fake.postLogMutex.Lock()
	ret, specificReturn := fake.postLogReturnsOnCall[len(fake.postLogArgsForCall)]
	fake.postLogArgsForCall = append(fake.postLogArgsForCall, struct {
		simulationID int32
		message      string
	}{simulationID, message})
	fake.recordInvocation("PostLog", []interface{}{simulationID, message})
	fake.postLogMutex.Unlock()
	if fake.PostLogStub != nil {
		return fake.PostLogStub(simulationID, message)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.postLogReturns.result1
}

func (fake *FakeClient) PostLogCallCount() int {
	fake.postLogMutex.RLock()
	defer fake.postLogMutex.RUnlock()
	return len(fake.postLogArgsForCall)
}

func (fake *FakeClient) PostLogArgsForCall(i int) (int32, string) {
	fake.postLogMutex.RLock()
	defer fake.postLogMutex.RUnlock()
	return fake.postLogArgsForCall[i].simulationID, fake.postLogArgsForCall[i].message
}

func (fake *FakeClient) PostLogReturns(result1 error) {
	fake.PostLogStub = nil
	fake.postLogReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PostLogReturnsOnCall(i int, result1 error) {
	fake.PostLogStub = nil
	if fake.postLogReturnsOnCall == nil {
		fake.postLogReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.postLogReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PatchSimulation(simulationID int32, patch *models.PatchDocument) error {
	fake.patchSimulationMutex.Lock()
	ret, specificReturn := fake.patchSimulationReturnsOnCall[len(fake.patchSimulationArgsForCall)]
	fake.patchSimulationArgsForCall = append(fake.patchSimulationArgsForCall, struct {
		simulationID int32
		patch        *models.PatchDocument
	}{simulationID, patch})
	fake.recordInvocation("PatchSimulation", []interface{}{simulationID, patch})
	fake.patchSimulationMutex.Unlock()
	if fake.PatchSimulationStub != nil {
		return fake.PatchSimulationStub(simulationID, patch)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.patchSimulationReturns.result1
}

func (fake *FakeClient) PatchSimulationCallCount() int {
	fake.patchSimulationMutex.RLock()
	defer fake.patchSimulationMutex.RUnlock()
	return len(fake.patchSimulationArgsForCall)
}

func (fake *FakeClient) PatchSimulationArgsForCall(i int) (int32, *models.PatchDocument) {
	fake.patchSimulationMutex.RLock()
	defer fake.patchSimulationMutex.RUnlock()
	return fake.patchSimulationArgsForCall[i].simulationID, fake.patchSimulationArgsForCall[i].patch
}

func (fake *FakeClient) PatchSimulationReturns(result1 error) {
	fake.PatchSimulationStub = nil
	fake.patchSimulationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PatchSimulationReturnsOnCall(i int, result1 error) {
	fake.PatchSimulationStub = nil
	if fake.patchSimulationReturnsOnCall == nil {
		fake.patchSimulationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.patchSimulationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) MultiPatchSimulation(simulationID int32, patches []*models.PatchDocument) error {
	var patchesCopy []*models.PatchDocument
	if patches != nil {
		patchesCopy = make([]*models.PatchDocument, len(patches))
		copy(patchesCopy, patches)
	}
	fake.multiPatchSimulationMutex.Lock()
	ret, specificReturn := fake.multiPatchSimulationReturnsOnCall[len(fake.multiPatchSimulationArgsForCall)]
	fake.multiPatchSimulationArgsForCall = append(fake.multiPatchSimulationArgsForCall, struct {
		simulationID int32
		patches      []*models.PatchDocument
	}{simulationID, patchesCopy})
	fake.recordInvocation("MultiPatchSimulation", []interface{}{simulationID, patchesCopy})
	fake.multiPatchSimulationMutex.Unlock()
	if fake.MultiPatchSimulationStub != nil {
		return fake.MultiPatchSimulationStub(simulationID, patches)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.multiPatchSimulationReturns.result1
}

func (fake *FakeClient) MultiPatchSimulationCallCount() int {
	fake.multiPatchSimulationMutex.RLock()
	defer fake.multiPatchSimulationMutex.RUnlock()
	return len(fake.multiPatchSimulationArgsForCall)
}

func (fake *FakeClient) MultiPatchSimulationArgsForCall(i int) (int32, []*models.PatchDocument) {
	fake.multiPatchSimulationMutex.RLock()
	defer fake.multiPatchSimulationMutex.RUnlock()
	return fake.multiPatchSimulationArgsForCall[i].simulationID, fake.multiPatchSimulationArgsForCall[i].patches
}

func (fake *FakeClient) MultiPatchSimulationReturns(result1 error) {
	fake.MultiPatchSimulationStub = nil
	fake.multiPatchSimulationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) MultiPatchSimulationReturnsOnCall(i int, result1 error) {
	fake.MultiPatchSimulationStub = nil
	if fake.multiPatchSimulationReturnsOnCall == nil {
		fake.multiPatchSimulationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.multiPatchSimulationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PostSimulationActivity(simulationID int32, simulationActivity *models.SimulationActivity) (*models.SimulationActivity, error) {
	fake.postSimulationActivityMutex.Lock()
	ret, specificReturn := fake.postSimulationActivityReturnsOnCall[len(fake.postSimulationActivityArgsForCall)]
	fake.postSimulationActivityArgsForCall = append(fake.postSimulationActivityArgsForCall, struct {
		simulationID       int32
		simulationActivity *models.SimulationActivity
	}{simulationID, simulationActivity})
	fake.recordInvocation("PostSimulationActivity", []interface{}{simulationID, simulationActivity})
	fake.postSimulationActivityMutex.Unlock()
	if fake.PostSimulationActivityStub != nil {
		return fake.PostSimulationActivityStub(simulationID, simulationActivity)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.postSimulationActivityReturns.result1, fake.postSimulationActivityReturns.result2
}

func (fake *FakeClient) PostSimulationActivityCallCount() int {
	fake.postSimulationActivityMutex.RLock()
	defer fake.postSimulationActivityMutex.RUnlock()
	return len(fake.postSimulationActivityArgsForCall)
}

func (fake *FakeClient) PostSimulationActivityArgsForCall(i int) (int32, *models.SimulationActivity) {
	fake.postSimulationActivityMutex.RLock()
	defer fake.postSimulationActivityMutex.RUnlock()
	return fake.postSimulationActivityArgsForCall[i].simulationID, fake.postSimulationActivityArgsForCall[i].simulationActivity
}

func (fake *FakeClient) PostSimulationActivityReturns(result1 *models.SimulationActivity, result2 error) {
	fake.PostSimulationActivityStub = nil
	fake.postSimulationActivityReturns = struct {
		result1 *models.SimulationActivity
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostSimulationActivityReturnsOnCall(i int, result1 *models.SimulationActivity, result2 error) {
	fake.PostSimulationActivityStub = nil
	if fake.postSimulationActivityReturnsOnCall == nil {
		fake.postSimulationActivityReturnsOnCall = make(map[int]struct {
			result1 *models.SimulationActivity
			result2 error
		})
	}
	fake.postSimulationActivityReturnsOnCall[i] = struct {
		result1 *models.SimulationActivity
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SimulationActivityByActivityID(simulationID int32, activityID string) (*models.SimulationActivity, error) {
	fake.simulationActivityByActivityIDMutex.Lock()
	ret, specificReturn := fake.simulationActivityByActivityIDReturnsOnCall[len(fake.simulationActivityByActivityIDArgsForCall)]
	fake.simulationActivityByActivityIDArgsForCall = append(fake.simulationActivityByActivityIDArgsForCall, struct {
		simulationID int32
		activityID   string
	}{simulationID, activityID})
	fake.recordInvocation("SimulationActivityByActivityID", []interface{}{simulationID, activityID})
	fake.simulationActivityByActivityIDMutex.Unlock()
	if fake.SimulationActivityByActivityIDStub != nil {
		return fake.SimulationActivityByActivityIDStub(simulationID, activityID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.simulationActivityByActivityIDReturns.result1, fake.simulationActivityByActivityIDReturns.result2
}

func (fake *FakeClient) SimulationActivityByActivityIDCallCount() int {
	fake.simulationActivityByActivityIDMutex.RLock()
	defer fake.simulationActivityByActivityIDMutex.RUnlock()
	return len(fake.simulationActivityByActivityIDArgsForCall)
}

func (fake *FakeClient) SimulationActivityByActivityIDArgsForCall(i int) (int32, string) {
	fake.simulationActivityByActivityIDMutex.RLock()
	defer fake.simulationActivityByActivityIDMutex.RUnlock()
	return fake.simulationActivityByActivityIDArgsForCall[i].simulationID, fake.simulationActivityByActivityIDArgsForCall[i].activityID
}

func (fake *FakeClient) SimulationActivityByActivityIDReturns(result1 *models.SimulationActivity, result2 error) {
	fake.SimulationActivityByActivityIDStub = nil
	fake.simulationActivityByActivityIDReturns = struct {
		result1 *models.SimulationActivity
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SimulationActivityByActivityIDReturnsOnCall(i int, result1 *models.SimulationActivity, result2 error) {
	fake.SimulationActivityByActivityIDStub = nil
	if fake.simulationActivityByActivityIDReturnsOnCall == nil {
		fake.simulationActivityByActivityIDReturnsOnCall = make(map[int]struct {
			result1 *models.SimulationActivity
			result2 error
		})
	}
	fake.simulationActivityByActivityIDReturnsOnCall[i] = struct {
		result1 *models.SimulationActivity
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PutSimulationActivity(simulationID int32, simulationActivity *models.SimulationActivity) error {
	fake.putSimulationActivityMutex.Lock()
	ret, specificReturn := fake.putSimulationActivityReturnsOnCall[len(fake.putSimulationActivityArgsForCall)]
	fake.putSimulationActivityArgsForCall = append(fake.putSimulationActivityArgsForCall, struct {
		simulationID       int32
		simulationActivity *models.SimulationActivity
	}{simulationID, simulationActivity})
	fake.recordInvocation("PutSimulationActivity", []interface{}{simulationID, simulationActivity})
	fake.putSimulationActivityMutex.Unlock()
	if fake.PutSimulationActivityStub != nil {
		return fake.PutSimulationActivityStub(simulationID, simulationActivity)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.putSimulationActivityReturns.result1
}

func (fake *FakeClient) PutSimulationActivityCallCount() int {
	fake.putSimulationActivityMutex.RLock()
	defer fake.putSimulationActivityMutex.RUnlock()
	return len(fake.putSimulationActivityArgsForCall)
}

func (fake *FakeClient) PutSimulationActivityArgsForCall(i int) (int32, *models.SimulationActivity) {
	fake.putSimulationActivityMutex.RLock()
	defer fake.putSimulationActivityMutex.RUnlock()
	return fake.putSimulationActivityArgsForCall[i].simulationID, fake.putSimulationActivityArgsForCall[i].simulationActivity
}

func (fake *FakeClient) PutSimulationActivityReturns(result1 error) {
	fake.PutSimulationActivityStub = nil
	fake.putSimulationActivityReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PutSimulationActivityReturnsOnCall(i int, result1 error) {
	fake.PutSimulationActivityStub = nil
	if fake.putSimulationActivityReturnsOnCall == nil {
		fake.putSimulationActivityReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.putSimulationActivityReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) AddSimulationOutput(simulationID int32, outputType string, outputFileLocation string) (*models.SimulationOutput, error) {
	fake.addSimulationOutputMutex.Lock()
	ret, specificReturn := fake.addSimulationOutputReturnsOnCall[len(fake.addSimulationOutputArgsForCall)]
	fake.addSimulationOutputArgsForCall = append(fake.addSimulationOutputArgsForCall, struct {
		simulationID       int32
		outputType         string
		outputFileLocation string
	}{simulationID, outputType, outputFileLocation})
	fake.recordInvocation("AddSimulationOutput", []interface{}{simulationID, outputType, outputFileLocation})
	fake.addSimulationOutputMutex.Unlock()
	if fake.AddSimulationOutputStub != nil {
		return fake.AddSimulationOutputStub(simulationID, outputType, outputFileLocation)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.addSimulationOutputReturns.result1, fake.addSimulationOutputReturns.result2
}

func (fake *FakeClient) AddSimulationOutputCallCount() int {
	fake.addSimulationOutputMutex.RLock()
	defer fake.addSimulationOutputMutex.RUnlock()
	return len(fake.addSimulationOutputArgsForCall)
}

func (fake *FakeClient) AddSimulationOutputArgsForCall(i int) (int32, string, string) {
	fake.addSimulationOutputMutex.RLock()
	defer fake.addSimulationOutputMutex.RUnlock()
	return fake.addSimulationOutputArgsForCall[i].simulationID, fake.addSimulationOutputArgsForCall[i].outputType, fake.addSimulationOutputArgsForCall[i].outputFileLocation
}

func (fake *FakeClient) AddSimulationOutputReturns(result1 *models.SimulationOutput, result2 error) {
	fake.AddSimulationOutputStub = nil
	fake.addSimulationOutputReturns = struct {
		result1 *models.SimulationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) AddSimulationOutputReturnsOnCall(i int, result1 *models.SimulationOutput, result2 error) {
	fake.AddSimulationOutputStub = nil
	if fake.addSimulationOutputReturnsOnCall == nil {
		fake.addSimulationOutputReturnsOnCall = make(map[int]struct {
			result1 *models.SimulationOutput
			result2 error
		})
	}
	fake.addSimulationOutputReturnsOnCall[i] = struct {
		result1 *models.SimulationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateSimulationStatus(simulationID int32, status string) error {
	fake.updateSimulationStatusMutex.Lock()
	ret, specificReturn := fake.updateSimulationStatusReturnsOnCall[len(fake.updateSimulationStatusArgsForCall)]
	fake.updateSimulationStatusArgsForCall = append(fake.updateSimulationStatusArgsForCall, struct {
		simulationID int32
		status       string
	}{simulationID, status})
	fake.recordInvocation("UpdateSimulationStatus", []interface{}{simulationID, status})
	fake.updateSimulationStatusMutex.Unlock()
	if fake.UpdateSimulationStatusStub != nil {
		return fake.UpdateSimulationStatusStub(simulationID, status)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.updateSimulationStatusReturns.result1
}

func (fake *FakeClient) UpdateSimulationStatusCallCount() int {
	fake.updateSimulationStatusMutex.RLock()
	defer fake.updateSimulationStatusMutex.RUnlock()
	return len(fake.updateSimulationStatusArgsForCall)
}

func (fake *FakeClient) UpdateSimulationStatusArgsForCall(i int) (int32, string) {
	fake.updateSimulationStatusMutex.RLock()
	defer fake.updateSimulationStatusMutex.RUnlock()
	return fake.updateSimulationStatusArgsForCall[i].simulationID, fake.updateSimulationStatusArgsForCall[i].status
}

func (fake *FakeClient) UpdateSimulationStatusReturns(result1 error) {
	fake.UpdateSimulationStatusStub = nil
	fake.updateSimulationStatusReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) UpdateSimulationStatusReturnsOnCall(i int, result1 error) {
	fake.UpdateSimulationStatusStub = nil
	if fake.updateSimulationStatusReturnsOnCall == nil {
		fake.updateSimulationStatusReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateSimulationStatusReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) RawSimulation(simulationID int32) (map[string]interface{}, error) {
	fake.rawSimulationMutex.Lock()
	ret, specificReturn := fake.rawSimulationReturnsOnCall[len(fake.rawSimulationArgsForCall)]
	fake.rawSimulationArgsForCall = append(fake.rawSimulationArgsForCall, struct {
		simulationID int32
	}{simulationID})
	fake.recordInvocation("RawSimulation", []interface{}{simulationID})
	fake.rawSimulationMutex.Unlock()
	if fake.RawSimulationStub != nil {
		return fake.RawSimulationStub(simulationID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.rawSimulationReturns.result1, fake.rawSimulationReturns.result2
}

func (fake *FakeClient) RawSimulationCallCount() int {
	fake.rawSimulationMutex.RLock()
	defer fake.rawSimulationMutex.RUnlock()
	return len(fake.rawSimulationArgsForCall)
}

func (fake *FakeClient) RawSimulationArgsForCall(i int) int32 {
	fake.rawSimulationMutex.RLock()
	defer fake.rawSimulationMutex.RUnlock()
	return fake.rawSimulationArgsForCall[i].simulationID
}

func (fake *FakeClient) RawSimulationReturns(result1 map[string]interface{}, result2 error) {
	fake.RawSimulationStub = nil
	fake.rawSimulationReturns = struct {
		result1 map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RawSimulationReturnsOnCall(i int, result1 map[string]interface{}, result2 error) {
	fake.RawSimulationStub = nil
	if fake.rawSimulationReturnsOnCall == nil {
		fake.rawSimulationReturnsOnCall = make(map[int]struct {
			result1 map[string]interface{}
			result2 error
		})
	}
	fake.rawSimulationReturnsOnCall[i] = struct {
		result1 map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.simulationsMutex.RLock()
	defer fake.simulationsMutex.RUnlock()
	fake.startSimulationMutex.RLock()
	defer fake.startSimulationMutex.RUnlock()
	fake.thermalSimulationMutex.RLock()
	defer fake.thermalSimulationMutex.RUnlock()
	fake.singleBeadSimulationMutex.RLock()
	defer fake.singleBeadSimulationMutex.RUnlock()
	fake.postAssumedStrainSimulationMutex.RLock()
	defer fake.postAssumedStrainSimulationMutex.RUnlock()
	fake.postPorositySimulationMutex.RLock()
	defer fake.postPorositySimulationMutex.RUnlock()
	fake.postScanPatternSimulationMutex.RLock()
	defer fake.postScanPatternSimulationMutex.RUnlock()
	fake.postSingleBeadSimulationMutex.RLock()
	defer fake.postSingleBeadSimulationMutex.RUnlock()
	fake.postThermalSimulationMutex.RLock()
	defer fake.postThermalSimulationMutex.RUnlock()
	fake.machineMutex.RLock()
	defer fake.machineMutex.RUnlock()
	fake.materialMutex.RLock()
	defer fake.materialMutex.RUnlock()
	fake.simulationMutex.RLock()
	defer fake.simulationMutex.RUnlock()
	fake.scanPatternSimulationMutex.RLock()
	defer fake.scanPatternSimulationMutex.RUnlock()
	fake.assumedStrainSimulationMutex.RLock()
	defer fake.assumedStrainSimulationMutex.RUnlock()
	fake.porositySimulationMutex.RLock()
	defer fake.porositySimulationMutex.RUnlock()
	fake.postLogWithTimeMutex.RLock()
	defer fake.postLogWithTimeMutex.RUnlock()
	fake.postLogMutex.RLock()
	defer fake.postLogMutex.RUnlock()
	fake.patchSimulationMutex.RLock()
	defer fake.patchSimulationMutex.RUnlock()
	fake.multiPatchSimulationMutex.RLock()
	defer fake.multiPatchSimulationMutex.RUnlock()
	fake.postSimulationActivityMutex.RLock()
	defer fake.postSimulationActivityMutex.RUnlock()
	fake.simulationActivityByActivityIDMutex.RLock()
	defer fake.simulationActivityByActivityIDMutex.RUnlock()
	fake.putSimulationActivityMutex.RLock()
	defer fake.putSimulationActivityMutex.RUnlock()
	fake.addSimulationOutputMutex.RLock()
	defer fake.addSimulationOutputMutex.RUnlock()
	fake.updateSimulationStatusMutex.RLock()
	defer fake.updateSimulationStatusMutex.RUnlock()
	fake.rawSimulationMutex.RLock()
	defer fake.rawSimulationMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ simulation.Client = new(FakeClient)
