// Code generated by counterfeiter. DO NOT EDIT.
package simulationfakes

import (
	"sync"

	"github.com/3dsim/simulation-goclient/models"
	"github.com/3dsim/simulation-goclient/simulation"
)

type FakeClient struct {
	AddSimulationOutputStub        func(int32, string, string) (*models.SimulationOutput, error)
	addSimulationOutputMutex       sync.RWMutex
	addSimulationOutputArgsForCall []struct {
		arg1 int32
		arg2 string
		arg3 string
	}
	addSimulationOutputReturns struct {
		result1 *models.SimulationOutput
		result2 error
	}
	addSimulationOutputReturnsOnCall map[int]struct {
		result1 *models.SimulationOutput
		result2 error
	}
	AssumedStrainSimulationStub        func(int32) (*models.AssumedStrainSimulation, error)
	assumedStrainSimulationMutex       sync.RWMutex
	assumedStrainSimulationArgsForCall []struct {
		arg1 int32
	}
	assumedStrainSimulationReturns struct {
		result1 *models.AssumedStrainSimulation
		result2 error
	}
	assumedStrainSimulationReturnsOnCall map[int]struct {
		result1 *models.AssumedStrainSimulation
		result2 error
	}
	BuildFileStub        func(int32) (*models.BuildFile, error)
	buildFileMutex       sync.RWMutex
	buildFileArgsForCall []struct {
		arg1 int32
	}
	buildFileReturns struct {
		result1 *models.BuildFile
		result2 error
	}
	buildFileReturnsOnCall map[int]struct {
		result1 *models.BuildFile
		result2 error
	}
	BuildFilesStub        func(int32, []string, []string, int32, int32) ([]*models.BuildFile, error)
	buildFilesMutex       sync.RWMutex
	buildFilesArgsForCall []struct {
		arg1 int32
		arg2 []string
		arg3 []string
		arg4 int32
		arg5 int32
	}
	buildFilesReturns struct {
		result1 []*models.BuildFile
		result2 error
	}
	buildFilesReturnsOnCall map[int]struct {
		result1 []*models.BuildFile
		result2 error
	}
	MachineStub        func(int32) (*models.Machine, error)
	machineMutex       sync.RWMutex
	machineArgsForCall []struct {
		arg1 int32
	}
	machineReturns struct {
		result1 *models.Machine
		result2 error
	}
	machineReturnsOnCall map[int]struct {
		result1 *models.Machine
		result2 error
	}
	MaterialStub        func(int32) (*models.Material, error)
	materialMutex       sync.RWMutex
	materialArgsForCall []struct {
		arg1 int32
	}
	materialReturns struct {
		result1 *models.Material
		result2 error
	}
	materialReturnsOnCall map[int]struct {
		result1 *models.Material
		result2 error
	}
	MicrostructureSimulationStub        func(int32) (*models.MicrostructureSimulation, error)
	microstructureSimulationMutex       sync.RWMutex
	microstructureSimulationArgsForCall []struct {
		arg1 int32
	}
	microstructureSimulationReturns struct {
		result1 *models.MicrostructureSimulation
		result2 error
	}
	microstructureSimulationReturnsOnCall map[int]struct {
		result1 *models.MicrostructureSimulation
		result2 error
	}
	MultiPatchSimulationStub        func(int32, []*models.PatchDocument) error
	multiPatchSimulationMutex       sync.RWMutex
	multiPatchSimulationArgsForCall []struct {
		arg1 int32
		arg2 []*models.PatchDocument
	}
	multiPatchSimulationReturns struct {
		result1 error
	}
	multiPatchSimulationReturnsOnCall map[int]struct {
		result1 error
	}
	PartStub        func(int32) (*models.Part, error)
	partMutex       sync.RWMutex
	partArgsForCall []struct {
		arg1 int32
	}
	partReturns struct {
		result1 *models.Part
		result2 error
	}
	partReturnsOnCall map[int]struct {
		result1 *models.Part
		result2 error
	}
	PartSupportByIDStub        func(int32) (*models.PartSupport, error)
	partSupportByIDMutex       sync.RWMutex
	partSupportByIDArgsForCall []struct {
		arg1 int32
	}
	partSupportByIDReturns struct {
		result1 *models.PartSupport
		result2 error
	}
	partSupportByIDReturnsOnCall map[int]struct {
		result1 *models.PartSupport
		result2 error
	}
	PatchBuildFileStub        func(int32, []*models.PatchDocument) (*models.BuildFile, error)
	patchBuildFileMutex       sync.RWMutex
	patchBuildFileArgsForCall []struct {
		arg1 int32
		arg2 []*models.PatchDocument
	}
	patchBuildFileReturns struct {
		result1 *models.BuildFile
		result2 error
	}
	patchBuildFileReturnsOnCall map[int]struct {
		result1 *models.BuildFile
		result2 error
	}
	PatchPartStub        func(int32, []*models.PatchDocument) (*models.Part, error)
	patchPartMutex       sync.RWMutex
	patchPartArgsForCall []struct {
		arg1 int32
		arg2 []*models.PatchDocument
	}
	patchPartReturns struct {
		result1 *models.Part
		result2 error
	}
	patchPartReturnsOnCall map[int]struct {
		result1 *models.Part
		result2 error
	}
	PatchPartSupportStub        func(int32, int32, []*models.PatchDocument) (*models.PartSupport, error)
	patchPartSupportMutex       sync.RWMutex
	patchPartSupportArgsForCall []struct {
		arg1 int32
		arg2 int32
		arg3 []*models.PatchDocument
	}
	patchPartSupportReturns struct {
		result1 *models.PartSupport
		result2 error
	}
	patchPartSupportReturnsOnCall map[int]struct {
		result1 *models.PartSupport
		result2 error
	}
	PatchPartSupportByIDStub        func(int32, []*models.PatchDocument) (*models.PartSupport, error)
	patchPartSupportByIDMutex       sync.RWMutex
	patchPartSupportByIDArgsForCall []struct {
		arg1 int32
		arg2 []*models.PatchDocument
	}
	patchPartSupportByIDReturns struct {
		result1 *models.PartSupport
		result2 error
	}
	patchPartSupportByIDReturnsOnCall map[int]struct {
		result1 *models.PartSupport
		result2 error
	}
	PatchSimulationStub        func(int32, *models.PatchDocument) error
	patchSimulationMutex       sync.RWMutex
	patchSimulationArgsForCall []struct {
		arg1 int32
		arg2 *models.PatchDocument
	}
	patchSimulationReturns struct {
		result1 error
	}
	patchSimulationReturnsOnCall map[int]struct {
		result1 error
	}
	PatchSimulationActivityStub        func(int32, string, []*models.PatchDocument) (*models.SimulationActivity, error)
	patchSimulationActivityMutex       sync.RWMutex
	patchSimulationActivityArgsForCall []struct {
		arg1 int32
		arg2 string
		arg3 []*models.PatchDocument
	}
	patchSimulationActivityReturns struct {
		result1 *models.SimulationActivity
		result2 error
	}
	patchSimulationActivityReturnsOnCall map[int]struct {
		result1 *models.SimulationActivity
		result2 error
	}
	PorositySimulationStub        func(int32) (*models.PorositySimulation, error)
	porositySimulationMutex       sync.RWMutex
	porositySimulationArgsForCall []struct {
		arg1 int32
	}
	porositySimulationReturns struct {
		result1 *models.PorositySimulation
		result2 error
	}
	porositySimulationReturnsOnCall map[int]struct {
		result1 *models.PorositySimulation
		result2 error
	}
	PostAssumedStrainSimulationStub        func(*models.AssumedStrainSimulation) (*models.AssumedStrainSimulation, error)
	postAssumedStrainSimulationMutex       sync.RWMutex
	postAssumedStrainSimulationArgsForCall []struct {
		arg1 *models.AssumedStrainSimulation
	}
	postAssumedStrainSimulationReturns struct {
		result1 *models.AssumedStrainSimulation
		result2 error
	}
	postAssumedStrainSimulationReturnsOnCall map[int]struct {
		result1 *models.AssumedStrainSimulation
		result2 error
	}
	PostBuildFileStub        func(*models.BuildFilePost) (*models.BuildFile, error)
	postBuildFileMutex       sync.RWMutex
	postBuildFileArgsForCall []struct {
		arg1 *models.BuildFilePost
	}
	postBuildFileReturns struct {
		result1 *models.BuildFile
		result2 error
	}
	postBuildFileReturnsOnCall map[int]struct {
		result1 *models.BuildFile
		result2 error
	}
	PostLogStub        func(string, string, int32, string) error
	postLogMutex       sync.RWMutex
	postLogArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 int32
		arg4 string
	}
	postLogReturns struct {
		result1 error
	}
	postLogReturnsOnCall map[int]struct {
		result1 error
	}
	PostLogErrorStub        func(string, int32, string) error
	postLogErrorMutex       sync.RWMutex
	postLogErrorArgsForCall []struct {
		arg1 string
		arg2 int32
		arg3 string
	}
	postLogErrorReturns struct {
		result1 error
	}
	postLogErrorReturnsOnCall map[int]struct {
		result1 error
	}
	PostLogInfoStub        func(string, int32, string) error
	postLogInfoMutex       sync.RWMutex
	postLogInfoArgsForCall []struct {
		arg1 string
		arg2 int32
		arg3 string
	}
	postLogInfoReturns struct {
		result1 error
	}
	postLogInfoReturnsOnCall map[int]struct {
		result1 error
	}
	PostLogWarnStub        func(string, int32, string) error
	postLogWarnMutex       sync.RWMutex
	postLogWarnArgsForCall []struct {
		arg1 string
		arg2 int32
		arg3 string
	}
	postLogWarnReturns struct {
		result1 error
	}
	postLogWarnReturnsOnCall map[int]struct {
		result1 error
	}
	PostLogWithObjectStub        func(models.SimulationLog) error
	postLogWithObjectMutex       sync.RWMutex
	postLogWithObjectArgsForCall []struct {
		arg1 models.SimulationLog
	}
	postLogWithObjectReturns struct {
		result1 error
	}
	postLogWithObjectReturnsOnCall map[int]struct {
		result1 error
	}
	PostMicrostructureSimulationStub        func(*models.MicrostructureSimulation) (*models.MicrostructureSimulation, error)
	postMicrostructureSimulationMutex       sync.RWMutex
	postMicrostructureSimulationArgsForCall []struct {
		arg1 *models.MicrostructureSimulation
	}
	postMicrostructureSimulationReturns struct {
		result1 *models.MicrostructureSimulation
		result2 error
	}
	postMicrostructureSimulationReturnsOnCall map[int]struct {
		result1 *models.MicrostructureSimulation
		result2 error
	}
	PostPorositySimulationStub        func(*models.PorositySimulation) (*models.PorositySimulation, error)
	postPorositySimulationMutex       sync.RWMutex
	postPorositySimulationArgsForCall []struct {
		arg1 *models.PorositySimulation
	}
	postPorositySimulationReturns struct {
		result1 *models.PorositySimulation
		result2 error
	}
	postPorositySimulationReturnsOnCall map[int]struct {
		result1 *models.PorositySimulation
		result2 error
	}
	PostScanPatternSimulationStub        func(*models.ScanPatternSimulation) (*models.ScanPatternSimulation, error)
	postScanPatternSimulationMutex       sync.RWMutex
	postScanPatternSimulationArgsForCall []struct {
		arg1 *models.ScanPatternSimulation
	}
	postScanPatternSimulationReturns struct {
		result1 *models.ScanPatternSimulation
		result2 error
	}
	postScanPatternSimulationReturnsOnCall map[int]struct {
		result1 *models.ScanPatternSimulation
		result2 error
	}
	PostSimulationActivityStub        func(int32, *models.SimulationActivity) (*models.SimulationActivity, error)
	postSimulationActivityMutex       sync.RWMutex
	postSimulationActivityArgsForCall []struct {
		arg1 int32
		arg2 *models.SimulationActivity
	}
	postSimulationActivityReturns struct {
		result1 *models.SimulationActivity
		result2 error
	}
	postSimulationActivityReturnsOnCall map[int]struct {
		result1 *models.SimulationActivity
		result2 error
	}
	PostSingleBeadSimulationStub        func(*models.SingleBeadSimulation) (*models.SingleBeadSimulation, error)
	postSingleBeadSimulationMutex       sync.RWMutex
	postSingleBeadSimulationArgsForCall []struct {
		arg1 *models.SingleBeadSimulation
	}
	postSingleBeadSimulationReturns struct {
		result1 *models.SingleBeadSimulation
		result2 error
	}
	postSingleBeadSimulationReturnsOnCall map[int]struct {
		result1 *models.SingleBeadSimulation
		result2 error
	}
	PostThermalSimulationStub        func(*models.ThermalSimulation) (*models.ThermalSimulation, error)
	postThermalSimulationMutex       sync.RWMutex
	postThermalSimulationArgsForCall []struct {
		arg1 *models.ThermalSimulation
	}
	postThermalSimulationReturns struct {
		result1 *models.ThermalSimulation
		result2 error
	}
	postThermalSimulationReturnsOnCall map[int]struct {
		result1 *models.ThermalSimulation
		result2 error
	}
	PutSimulationActivityStub        func(int32, *models.SimulationActivity) error
	putSimulationActivityMutex       sync.RWMutex
	putSimulationActivityArgsForCall []struct {
		arg1 int32
		arg2 *models.SimulationActivity
	}
	putSimulationActivityReturns struct {
		result1 error
	}
	putSimulationActivityReturnsOnCall map[int]struct {
		result1 error
	}
	RawBuildFileStub        func(int32) (map[string]interface{}, error)
	rawBuildFileMutex       sync.RWMutex
	rawBuildFileArgsForCall []struct {
		arg1 int32
	}
	rawBuildFileReturns struct {
		result1 map[string]interface{}
		result2 error
	}
	rawBuildFileReturnsOnCall map[int]struct {
		result1 map[string]interface{}
		result2 error
	}
	RawSimulationStub        func(int32) (map[string]interface{}, error)
	rawSimulationMutex       sync.RWMutex
	rawSimulationArgsForCall []struct {
		arg1 int32
	}
	rawSimulationReturns struct {
		result1 map[string]interface{}
		result2 error
	}
	rawSimulationReturnsOnCall map[int]struct {
		result1 map[string]interface{}
		result2 error
	}
	ScanPatternSimulationStub        func(int32) (*models.ScanPatternSimulation, error)
	scanPatternSimulationMutex       sync.RWMutex
	scanPatternSimulationArgsForCall []struct {
		arg1 int32
	}
	scanPatternSimulationReturns struct {
		result1 *models.ScanPatternSimulation
		result2 error
	}
	scanPatternSimulationReturnsOnCall map[int]struct {
		result1 *models.ScanPatternSimulation
		result2 error
	}
	SimulationStub        func(int32) (*models.Simulation, error)
	simulationMutex       sync.RWMutex
	simulationArgsForCall []struct {
		arg1 int32
	}
	simulationReturns struct {
		result1 *models.Simulation
		result2 error
	}
	simulationReturnsOnCall map[int]struct {
		result1 *models.Simulation
		result2 error
	}
	SimulationActivityByActivityIDStub        func(int32, string) (*models.SimulationActivity, error)
	simulationActivityByActivityIDMutex       sync.RWMutex
	simulationActivityByActivityIDArgsForCall []struct {
		arg1 int32
		arg2 string
	}
	simulationActivityByActivityIDReturns struct {
		result1 *models.SimulationActivity
		result2 error
	}
	simulationActivityByActivityIDReturnsOnCall map[int]struct {
		result1 *models.SimulationActivity
		result2 error
	}
	SimulationChildrenStub        func(int32) ([]*models.Simulation, error)
	simulationChildrenMutex       sync.RWMutex
	simulationChildrenArgsForCall []struct {
		arg1 int32
	}
	simulationChildrenReturns struct {
		result1 []*models.Simulation
		result2 error
	}
	simulationChildrenReturnsOnCall map[int]struct {
		result1 []*models.Simulation
		result2 error
	}
	SimulationOutputsStub        func(int32) ([]*models.SimulationOutput, error)
	simulationOutputsMutex       sync.RWMutex
	simulationOutputsArgsForCall []struct {
		arg1 int32
	}
	simulationOutputsReturns struct {
		result1 []*models.SimulationOutput
		result2 error
	}
	simulationOutputsReturnsOnCall map[int]struct {
		result1 []*models.SimulationOutput
		result2 error
	}
	SimulationsStub        func(int32, []string, []string, int32, int32, *bool, *bool, *bool) ([]*models.Simulation, error)
	simulationsMutex       sync.RWMutex
	simulationsArgsForCall []struct {
		arg1 int32
		arg2 []string
		arg3 []string
		arg4 int32
		arg5 int32
		arg6 *bool
		arg7 *bool
		arg8 *bool
	}
	simulationsReturns struct {
		result1 []*models.Simulation
		result2 error
	}
	simulationsReturnsOnCall map[int]struct {
		result1 []*models.Simulation
		result2 error
	}
	SingleBeadSimulationStub        func(int32) (*models.SingleBeadSimulation, error)
	singleBeadSimulationMutex       sync.RWMutex
	singleBeadSimulationArgsForCall []struct {
		arg1 int32
	}
	singleBeadSimulationReturns struct {
		result1 *models.SingleBeadSimulation
		result2 error
	}
	singleBeadSimulationReturnsOnCall map[int]struct {
		result1 *models.SingleBeadSimulation
		result2 error
	}
	StartSimulationStub        func(int32) error
	startSimulationMutex       sync.RWMutex
	startSimulationArgsForCall []struct {
		arg1 int32
	}
	startSimulationReturns struct {
		result1 error
	}
	startSimulationReturnsOnCall map[int]struct {
		result1 error
	}
	ThermalSimulationStub        func(int32) (*models.ThermalSimulation, error)
	thermalSimulationMutex       sync.RWMutex
	thermalSimulationArgsForCall []struct {
		arg1 int32
	}
	thermalSimulationReturns struct {
		result1 *models.ThermalSimulation
		result2 error
	}
	thermalSimulationReturnsOnCall map[int]struct {
		result1 *models.ThermalSimulation
		result2 error
	}
	UpdateBuildFileAvailabilityStub        func(int32, string) (*models.BuildFile, error)
	updateBuildFileAvailabilityMutex       sync.RWMutex
	updateBuildFileAvailabilityArgsForCall []struct {
		arg1 int32
		arg2 string
	}
	updateBuildFileAvailabilityReturns struct {
		result1 *models.BuildFile
		result2 error
	}
	updateBuildFileAvailabilityReturnsOnCall map[int]struct {
		result1 *models.BuildFile
		result2 error
	}
	UpdatePartAvailabilityStub        func(int32, string) (*models.Part, error)
	updatePartAvailabilityMutex       sync.RWMutex
	updatePartAvailabilityArgsForCall []struct {
		arg1 int32
		arg2 string
	}
	updatePartAvailabilityReturns struct {
		result1 *models.Part
		result2 error
	}
	updatePartAvailabilityReturnsOnCall map[int]struct {
		result1 *models.Part
		result2 error
	}
	UpdatePartSupportAvailabilityStub        func(int32, string) (*models.PartSupport, error)
	updatePartSupportAvailabilityMutex       sync.RWMutex
	updatePartSupportAvailabilityArgsForCall []struct {
		arg1 int32
		arg2 string
	}
	updatePartSupportAvailabilityReturns struct {
		result1 *models.PartSupport
		result2 error
	}
	updatePartSupportAvailabilityReturnsOnCall map[int]struct {
		result1 *models.PartSupport
		result2 error
	}
	UpdateSimulationStatusStub        func(int32, string) error
	updateSimulationStatusMutex       sync.RWMutex
	updateSimulationStatusArgsForCall []struct {
		arg1 int32
		arg2 string
	}
	updateSimulationStatusReturns struct {
		result1 error
	}
	updateSimulationStatusReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) AddSimulationOutput(arg1 int32, arg2 string, arg3 string) (*models.SimulationOutput, error) {
	fake.addSimulationOutputMutex.Lock()
	ret, specificReturn := fake.addSimulationOutputReturnsOnCall[len(fake.addSimulationOutputArgsForCall)]
	fake.addSimulationOutputArgsForCall = append(fake.addSimulationOutputArgsForCall, struct {
		arg1 int32
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("AddSimulationOutput", []interface{}{arg1, arg2, arg3})
	fake.addSimulationOutputMutex.Unlock()
	if fake.AddSimulationOutputStub != nil {
		return fake.AddSimulationOutputStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.addSimulationOutputReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) AddSimulationOutputCallCount() int {
	fake.addSimulationOutputMutex.RLock()
	defer fake.addSimulationOutputMutex.RUnlock()
	return len(fake.addSimulationOutputArgsForCall)
}

func (fake *FakeClient) AddSimulationOutputCalls(stub func(int32, string, string) (*models.SimulationOutput, error)) {
	fake.addSimulationOutputMutex.Lock()
	defer fake.addSimulationOutputMutex.Unlock()
	fake.AddSimulationOutputStub = stub
}

func (fake *FakeClient) AddSimulationOutputArgsForCall(i int) (int32, string, string) {
	fake.addSimulationOutputMutex.RLock()
	defer fake.addSimulationOutputMutex.RUnlock()
	argsForCall := fake.addSimulationOutputArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) AddSimulationOutputReturns(result1 *models.SimulationOutput, result2 error) {
	fake.addSimulationOutputMutex.Lock()
	defer fake.addSimulationOutputMutex.Unlock()
	fake.AddSimulationOutputStub = nil
	fake.addSimulationOutputReturns = struct {
		result1 *models.SimulationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) AddSimulationOutputReturnsOnCall(i int, result1 *models.SimulationOutput, result2 error) {
	fake.addSimulationOutputMutex.Lock()
	defer fake.addSimulationOutputMutex.Unlock()
	fake.AddSimulationOutputStub = nil
	if fake.addSimulationOutputReturnsOnCall == nil {
		fake.addSimulationOutputReturnsOnCall = make(map[int]struct {
			result1 *models.SimulationOutput
			result2 error
		})
	}
	fake.addSimulationOutputReturnsOnCall[i] = struct {
		result1 *models.SimulationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) AssumedStrainSimulation(arg1 int32) (*models.AssumedStrainSimulation, error) {
	fake.assumedStrainSimulationMutex.Lock()
	ret, specificReturn := fake.assumedStrainSimulationReturnsOnCall[len(fake.assumedStrainSimulationArgsForCall)]
	fake.assumedStrainSimulationArgsForCall = append(fake.assumedStrainSimulationArgsForCall, struct {
		arg1 int32
	}{arg1})
	fake.recordInvocation("AssumedStrainSimulation", []interface{}{arg1})
	fake.assumedStrainSimulationMutex.Unlock()
	if fake.AssumedStrainSimulationStub != nil {
		return fake.AssumedStrainSimulationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.assumedStrainSimulationReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) AssumedStrainSimulationCallCount() int {
	fake.assumedStrainSimulationMutex.RLock()
	defer fake.assumedStrainSimulationMutex.RUnlock()
	return len(fake.assumedStrainSimulationArgsForCall)
}

func (fake *FakeClient) AssumedStrainSimulationCalls(stub func(int32) (*models.AssumedStrainSimulation, error)) {
	fake.assumedStrainSimulationMutex.Lock()
	defer fake.assumedStrainSimulationMutex.Unlock()
	fake.AssumedStrainSimulationStub = stub
}

func (fake *FakeClient) AssumedStrainSimulationArgsForCall(i int) int32 {
	fake.assumedStrainSimulationMutex.RLock()
	defer fake.assumedStrainSimulationMutex.RUnlock()
	argsForCall := fake.assumedStrainSimulationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) AssumedStrainSimulationReturns(result1 *models.AssumedStrainSimulation, result2 error) {
	fake.assumedStrainSimulationMutex.Lock()
	defer fake.assumedStrainSimulationMutex.Unlock()
	fake.AssumedStrainSimulationStub = nil
	fake.assumedStrainSimulationReturns = struct {
		result1 *models.AssumedStrainSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) AssumedStrainSimulationReturnsOnCall(i int, result1 *models.AssumedStrainSimulation, result2 error) {
	fake.assumedStrainSimulationMutex.Lock()
	defer fake.assumedStrainSimulationMutex.Unlock()
	fake.AssumedStrainSimulationStub = nil
	if fake.assumedStrainSimulationReturnsOnCall == nil {
		fake.assumedStrainSimulationReturnsOnCall = make(map[int]struct {
			result1 *models.AssumedStrainSimulation
			result2 error
		})
	}
	fake.assumedStrainSimulationReturnsOnCall[i] = struct {
		result1 *models.AssumedStrainSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) BuildFile(arg1 int32) (*models.BuildFile, error) {
	fake.buildFileMutex.Lock()
	ret, specificReturn := fake.buildFileReturnsOnCall[len(fake.buildFileArgsForCall)]
	fake.buildFileArgsForCall = append(fake.buildFileArgsForCall, struct {
		arg1 int32
	}{arg1})
	fake.recordInvocation("BuildFile", []interface{}{arg1})
	fake.buildFileMutex.Unlock()
	if fake.BuildFileStub != nil {
		return fake.BuildFileStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.buildFileReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) BuildFileCallCount() int {
	fake.buildFileMutex.RLock()
	defer fake.buildFileMutex.RUnlock()
	return len(fake.buildFileArgsForCall)
}

func (fake *FakeClient) BuildFileCalls(stub func(int32) (*models.BuildFile, error)) {
	fake.buildFileMutex.Lock()
	defer fake.buildFileMutex.Unlock()
	fake.BuildFileStub = stub
}

func (fake *FakeClient) BuildFileArgsForCall(i int) int32 {
	fake.buildFileMutex.RLock()
	defer fake.buildFileMutex.RUnlock()
	argsForCall := fake.buildFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) BuildFileReturns(result1 *models.BuildFile, result2 error) {
	fake.buildFileMutex.Lock()
	defer fake.buildFileMutex.Unlock()
	fake.BuildFileStub = nil
	fake.buildFileReturns = struct {
		result1 *models.BuildFile
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) BuildFileReturnsOnCall(i int, result1 *models.BuildFile, result2 error) {
	fake.buildFileMutex.Lock()
	defer fake.buildFileMutex.Unlock()
	fake.BuildFileStub = nil
	if fake.buildFileReturnsOnCall == nil {
		fake.buildFileReturnsOnCall = make(map[int]struct {
			result1 *models.BuildFile
			result2 error
		})
	}
	fake.buildFileReturnsOnCall[i] = struct {
		result1 *models.BuildFile
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) BuildFiles(arg1 int32, arg2 []string, arg3 []string, arg4 int32, arg5 int32) ([]*models.BuildFile, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.buildFilesMutex.Lock()
	ret, specificReturn := fake.buildFilesReturnsOnCall[len(fake.buildFilesArgsForCall)]
	fake.buildFilesArgsForCall = append(fake.buildFilesArgsForCall, struct {
		arg1 int32
		arg2 []string
		arg3 []string
		arg4 int32
		arg5 int32
	}{arg1, arg2Copy, arg3Copy, arg4, arg5})
	fake.recordInvocation("BuildFiles", []interface{}{arg1, arg2Copy, arg3Copy, arg4, arg5})
	fake.buildFilesMutex.Unlock()
	if fake.BuildFilesStub != nil {
		return fake.BuildFilesStub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.buildFilesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) BuildFilesCallCount() int {
	fake.buildFilesMutex.RLock()
	defer fake.buildFilesMutex.RUnlock()
	return len(fake.buildFilesArgsForCall)
}

func (fake *FakeClient) BuildFilesCalls(stub func(int32, []string, []string, int32, int32) ([]*models.BuildFile, error)) {
	fake.buildFilesMutex.Lock()
	defer fake.buildFilesMutex.Unlock()
	fake.BuildFilesStub = stub
}

func (fake *FakeClient) BuildFilesArgsForCall(i int) (int32, []string, []string, int32, int32) {
	fake.buildFilesMutex.RLock()
	defer fake.buildFilesMutex.RUnlock()
	argsForCall := fake.buildFilesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) BuildFilesReturns(result1 []*models.BuildFile, result2 error) {
	fake.buildFilesMutex.Lock()
	defer fake.buildFilesMutex.Unlock()
	fake.BuildFilesStub = nil
	fake.buildFilesReturns = struct {
		result1 []*models.BuildFile
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) BuildFilesReturnsOnCall(i int, result1 []*models.BuildFile, result2 error) {
	fake.buildFilesMutex.Lock()
	defer fake.buildFilesMutex.Unlock()
	fake.BuildFilesStub = nil
	if fake.buildFilesReturnsOnCall == nil {
		fake.buildFilesReturnsOnCall = make(map[int]struct {
			result1 []*models.BuildFile
			result2 error
		})
	}
	fake.buildFilesReturnsOnCall[i] = struct {
		result1 []*models.BuildFile
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Machine(arg1 int32) (*models.Machine, error) {
	fake.machineMutex.Lock()
	ret, specificReturn := fake.machineReturnsOnCall[len(fake.machineArgsForCall)]
	fake.machineArgsForCall = append(fake.machineArgsForCall, struct {
		arg1 int32
	}{arg1})
	fake.recordInvocation("Machine", []interface{}{arg1})
	fake.machineMutex.Unlock()
	if fake.MachineStub != nil {
		return fake.MachineStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.machineReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) MachineCallCount() int {
	fake.machineMutex.RLock()
	defer fake.machineMutex.RUnlock()
	return len(fake.machineArgsForCall)
}

func (fake *FakeClient) MachineCalls(stub func(int32) (*models.Machine, error)) {
	fake.machineMutex.Lock()
	defer fake.machineMutex.Unlock()
	fake.MachineStub = stub
}

func (fake *FakeClient) MachineArgsForCall(i int) int32 {
	fake.machineMutex.RLock()
	defer fake.machineMutex.RUnlock()
	argsForCall := fake.machineArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) MachineReturns(result1 *models.Machine, result2 error) {
	fake.machineMutex.Lock()
	defer fake.machineMutex.Unlock()
	fake.MachineStub = nil
	fake.machineReturns = struct {
		result1 *models.Machine
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) MachineReturnsOnCall(i int, result1 *models.Machine, result2 error) {
	fake.machineMutex.Lock()
	defer fake.machineMutex.Unlock()
	fake.MachineStub = nil
	if fake.machineReturnsOnCall == nil {
		fake.machineReturnsOnCall = make(map[int]struct {
			result1 *models.Machine
			result2 error
		})
	}
	fake.machineReturnsOnCall[i] = struct {
		result1 *models.Machine
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Material(arg1 int32) (*models.Material, error) {
	fake.materialMutex.Lock()
	ret, specificReturn := fake.materialReturnsOnCall[len(fake.materialArgsForCall)]
	fake.materialArgsForCall = append(fake.materialArgsForCall, struct {
		arg1 int32
	}{arg1})
	fake.recordInvocation("Material", []interface{}{arg1})
	fake.materialMutex.Unlock()
	if fake.MaterialStub != nil {
		return fake.MaterialStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.materialReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) MaterialCallCount() int {
	fake.materialMutex.RLock()
	defer fake.materialMutex.RUnlock()
	return len(fake.materialArgsForCall)
}

func (fake *FakeClient) MaterialCalls(stub func(int32) (*models.Material, error)) {
	fake.materialMutex.Lock()
	defer fake.materialMutex.Unlock()
	fake.MaterialStub = stub
}

func (fake *FakeClient) MaterialArgsForCall(i int) int32 {
	fake.materialMutex.RLock()
	defer fake.materialMutex.RUnlock()
	argsForCall := fake.materialArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) MaterialReturns(result1 *models.Material, result2 error) {
	fake.materialMutex.Lock()
	defer fake.materialMutex.Unlock()
	fake.MaterialStub = nil
	fake.materialReturns = struct {
		result1 *models.Material
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) MaterialReturnsOnCall(i int, result1 *models.Material, result2 error) {
	fake.materialMutex.Lock()
	defer fake.materialMutex.Unlock()
	fake.MaterialStub = nil
	if fake.materialReturnsOnCall == nil {
		fake.materialReturnsOnCall = make(map[int]struct {
			result1 *models.Material
			result2 error
		})
	}
	fake.materialReturnsOnCall[i] = struct {
		result1 *models.Material
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) MicrostructureSimulation(arg1 int32) (*models.MicrostructureSimulation, error) {
	fake.microstructureSimulationMutex.Lock()
	ret, specificReturn := fake.microstructureSimulationReturnsOnCall[len(fake.microstructureSimulationArgsForCall)]
	fake.microstructureSimulationArgsForCall = append(fake.microstructureSimulationArgsForCall, struct {
		arg1 int32
	}{arg1})
	fake.recordInvocation("MicrostructureSimulation", []interface{}{arg1})
	fake.microstructureSimulationMutex.Unlock()
	if fake.MicrostructureSimulationStub != nil {
		return fake.MicrostructureSimulationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.microstructureSimulationReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) MicrostructureSimulationCallCount() int {
	fake.microstructureSimulationMutex.RLock()
	defer fake.microstructureSimulationMutex.RUnlock()
	return len(fake.microstructureSimulationArgsForCall)
}

func (fake *FakeClient) MicrostructureSimulationCalls(stub func(int32) (*models.MicrostructureSimulation, error)) {
	fake.microstructureSimulationMutex.Lock()
	defer fake.microstructureSimulationMutex.Unlock()
	fake.MicrostructureSimulationStub = stub
}

func (fake *FakeClient) MicrostructureSimulationArgsForCall(i int) int32 {
	fake.microstructureSimulationMutex.RLock()
	defer fake.microstructureSimulationMutex.RUnlock()
	argsForCall := fake.microstructureSimulationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) MicrostructureSimulationReturns(result1 *models.MicrostructureSimulation, result2 error) {
	fake.microstructureSimulationMutex.Lock()
	defer fake.microstructureSimulationMutex.Unlock()
	fake.MicrostructureSimulationStub = nil
	fake.microstructureSimulationReturns = struct {
		result1 *models.MicrostructureSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) MicrostructureSimulationReturnsOnCall(i int, result1 *models.MicrostructureSimulation, result2 error) {
	fake.microstructureSimulationMutex.Lock()
	defer fake.microstructureSimulationMutex.Unlock()
	fake.MicrostructureSimulationStub = nil
	if fake.microstructureSimulationReturnsOnCall == nil {
		fake.microstructureSimulationReturnsOnCall = make(map[int]struct {
			result1 *models.MicrostructureSimulation
			result2 error
		})
	}
	fake.microstructureSimulationReturnsOnCall[i] = struct {
		result1 *models.MicrostructureSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) MultiPatchSimulation(arg1 int32, arg2 []*models.PatchDocument) error {
	var arg2Copy []*models.PatchDocument
	if arg2 != nil {
		arg2Copy = make([]*models.PatchDocument, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.multiPatchSimulationMutex.Lock()
	ret, specificReturn := fake.multiPatchSimulationReturnsOnCall[len(fake.multiPatchSimulationArgsForCall)]
	fake.multiPatchSimulationArgsForCall = append(fake.multiPatchSimulationArgsForCall, struct {
		arg1 int32
		arg2 []*models.PatchDocument
	}{arg1, arg2Copy})
	fake.recordInvocation("MultiPatchSimulation", []interface{}{arg1, arg2Copy})
	fake.multiPatchSimulationMutex.Unlock()
	if fake.MultiPatchSimulationStub != nil {
		return fake.MultiPatchSimulationStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.multiPatchSimulationReturns
	return fakeReturns.result1
}

func (fake *FakeClient) MultiPatchSimulationCallCount() int {
	fake.multiPatchSimulationMutex.RLock()
	defer fake.multiPatchSimulationMutex.RUnlock()
	return len(fake.multiPatchSimulationArgsForCall)
}

func (fake *FakeClient) MultiPatchSimulationCalls(stub func(int32, []*models.PatchDocument) error) {
	fake.multiPatchSimulationMutex.Lock()
	defer fake.multiPatchSimulationMutex.Unlock()
	fake.MultiPatchSimulationStub = stub
}

func (fake *FakeClient) MultiPatchSimulationArgsForCall(i int) (int32, []*models.PatchDocument) {
	fake.multiPatchSimulationMutex.RLock()
	defer fake.multiPatchSimulationMutex.RUnlock()
	argsForCall := fake.multiPatchSimulationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) MultiPatchSimulationReturns(result1 error) {
	fake.multiPatchSimulationMutex.Lock()
	defer fake.multiPatchSimulationMutex.Unlock()
	fake.MultiPatchSimulationStub = nil
	fake.multiPatchSimulationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) MultiPatchSimulationReturnsOnCall(i int, result1 error) {
	fake.multiPatchSimulationMutex.Lock()
	defer fake.multiPatchSimulationMutex.Unlock()
	fake.MultiPatchSimulationStub = nil
	if fake.multiPatchSimulationReturnsOnCall == nil {
		fake.multiPatchSimulationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.multiPatchSimulationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Part(arg1 int32) (*models.Part, error) {
	fake.partMutex.Lock()
	ret, specificReturn := fake.partReturnsOnCall[len(fake.partArgsForCall)]
	fake.partArgsForCall = append(fake.partArgsForCall, struct {
		arg1 int32
	}{arg1})
	fake.recordInvocation("Part", []interface{}{arg1})
	fake.partMutex.Unlock()
	if fake.PartStub != nil {
		return fake.PartStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.partReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) PartCallCount() int {
	fake.partMutex.RLock()
	defer fake.partMutex.RUnlock()
	return len(fake.partArgsForCall)
}

func (fake *FakeClient) PartCalls(stub func(int32) (*models.Part, error)) {
	fake.partMutex.Lock()
	defer fake.partMutex.Unlock()
	fake.PartStub = stub
}

func (fake *FakeClient) PartArgsForCall(i int) int32 {
	fake.partMutex.RLock()
	defer fake.partMutex.RUnlock()
	argsForCall := fake.partArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) PartReturns(result1 *models.Part, result2 error) {
	fake.partMutex.Lock()
	defer fake.partMutex.Unlock()
	fake.PartStub = nil
	fake.partReturns = struct {
		result1 *models.Part
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PartReturnsOnCall(i int, result1 *models.Part, result2 error) {
	fake.partMutex.Lock()
	defer fake.partMutex.Unlock()
	fake.PartStub = nil
	if fake.partReturnsOnCall == nil {
		fake.partReturnsOnCall = make(map[int]struct {
			result1 *models.Part
			result2 error
		})
	}
	fake.partReturnsOnCall[i] = struct {
		result1 *models.Part
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PartSupportByID(arg1 int32) (*models.PartSupport, error) {
	fake.partSupportByIDMutex.Lock()
	ret, specificReturn := fake.partSupportByIDReturnsOnCall[len(fake.partSupportByIDArgsForCall)]
	fake.partSupportByIDArgsForCall = append(fake.partSupportByIDArgsForCall, struct {
		arg1 int32
	}{arg1})
	fake.recordInvocation("PartSupportByID", []interface{}{arg1})
	fake.partSupportByIDMutex.Unlock()
	if fake.PartSupportByIDStub != nil {
		return fake.PartSupportByIDStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.partSupportByIDReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) PartSupportByIDCallCount() int {
	fake.partSupportByIDMutex.RLock()
	defer fake.partSupportByIDMutex.RUnlock()
	return len(fake.partSupportByIDArgsForCall)
}

func (fake *FakeClient) PartSupportByIDCalls(stub func(int32) (*models.PartSupport, error)) {
	fake.partSupportByIDMutex.Lock()
	defer fake.partSupportByIDMutex.Unlock()
	fake.PartSupportByIDStub = stub
}

func (fake *FakeClient) PartSupportByIDArgsForCall(i int) int32 {
	fake.partSupportByIDMutex.RLock()
	defer fake.partSupportByIDMutex.RUnlock()
	argsForCall := fake.partSupportByIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) PartSupportByIDReturns(result1 *models.PartSupport, result2 error) {
	fake.partSupportByIDMutex.Lock()
	defer fake.partSupportByIDMutex.Unlock()
	fake.PartSupportByIDStub = nil
	fake.partSupportByIDReturns = struct {
		result1 *models.PartSupport
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PartSupportByIDReturnsOnCall(i int, result1 *models.PartSupport, result2 error) {
	fake.partSupportByIDMutex.Lock()
	defer fake.partSupportByIDMutex.Unlock()
	fake.PartSupportByIDStub = nil
	if fake.partSupportByIDReturnsOnCall == nil {
		fake.partSupportByIDReturnsOnCall = make(map[int]struct {
			result1 *models.PartSupport
			result2 error
		})
	}
	fake.partSupportByIDReturnsOnCall[i] = struct {
		result1 *models.PartSupport
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PatchBuildFile(arg1 int32, arg2 []*models.PatchDocument) (*models.BuildFile, error) {
	var arg2Copy []*models.PatchDocument
	if arg2 != nil {
		arg2Copy = make([]*models.PatchDocument, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.patchBuildFileMutex.Lock()
	ret, specificReturn := fake.patchBuildFileReturnsOnCall[len(fake.patchBuildFileArgsForCall)]
	fake.patchBuildFileArgsForCall = append(fake.patchBuildFileArgsForCall, struct {
		arg1 int32
		arg2 []*models.PatchDocument
	}{arg1, arg2Copy})
	fake.recordInvocation("PatchBuildFile", []interface{}{arg1, arg2Copy})
	fake.patchBuildFileMutex.Unlock()
	if fake.PatchBuildFileStub != nil {
		return fake.PatchBuildFileStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.patchBuildFileReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) PatchBuildFileCallCount() int {
	fake.patchBuildFileMutex.RLock()
	defer fake.patchBuildFileMutex.RUnlock()
	return len(fake.patchBuildFileArgsForCall)
}

func (fake *FakeClient) PatchBuildFileCalls(stub func(int32, []*models.PatchDocument) (*models.BuildFile, error)) {
	fake.patchBuildFileMutex.Lock()
	defer fake.patchBuildFileMutex.Unlock()
	fake.PatchBuildFileStub = stub
}

func (fake *FakeClient) PatchBuildFileArgsForCall(i int) (int32, []*models.PatchDocument) {
	fake.patchBuildFileMutex.RLock()
	defer fake.patchBuildFileMutex.RUnlock()
	argsForCall := fake.patchBuildFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) PatchBuildFileReturns(result1 *models.BuildFile, result2 error) {
	fake.patchBuildFileMutex.Lock()
	defer fake.patchBuildFileMutex.Unlock()
	fake.PatchBuildFileStub = nil
	fake.patchBuildFileReturns = struct {
		result1 *models.BuildFile
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PatchBuildFileReturnsOnCall(i int, result1 *models.BuildFile, result2 error) {
	fake.patchBuildFileMutex.Lock()
	defer fake.patchBuildFileMutex.Unlock()
	fake.PatchBuildFileStub = nil
	if fake.patchBuildFileReturnsOnCall == nil {
		fake.patchBuildFileReturnsOnCall = make(map[int]struct {
			result1 *models.BuildFile
			result2 error
		})
	}
	fake.patchBuildFileReturnsOnCall[i] = struct {
		result1 *models.BuildFile
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PatchPart(arg1 int32, arg2 []*models.PatchDocument) (*models.Part, error) {
	var arg2Copy []*models.PatchDocument
	if arg2 != nil {
		arg2Copy = make([]*models.PatchDocument, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.patchPartMutex.Lock()
	ret, specificReturn := fake.patchPartReturnsOnCall[len(fake.patchPartArgsForCall)]
	fake.patchPartArgsForCall = append(fake.patchPartArgsForCall, struct {
		arg1 int32
		arg2 []*models.PatchDocument
	}{arg1, arg2Copy})
	fake.recordInvocation("PatchPart", []interface{}{arg1, arg2Copy})
	fake.patchPartMutex.Unlock()
	if fake.PatchPartStub != nil {
		return fake.PatchPartStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.patchPartReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) PatchPartCallCount() int {
	fake.patchPartMutex.RLock()
	defer fake.patchPartMutex.RUnlock()
	return len(fake.patchPartArgsForCall)
}

func (fake *FakeClient) PatchPartCalls(stub func(int32, []*models.PatchDocument) (*models.Part, error)) {
	fake.patchPartMutex.Lock()
	defer fake.patchPartMutex.Unlock()
	fake.PatchPartStub = stub
}

func (fake *FakeClient) PatchPartArgsForCall(i int) (int32, []*models.PatchDocument) {
	fake.patchPartMutex.RLock()
	defer fake.patchPartMutex.RUnlock()
	argsForCall := fake.patchPartArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) PatchPartReturns(result1 *models.Part, result2 error) {
	fake.patchPartMutex.Lock()
	defer fake.patchPartMutex.Unlock()
	fake.PatchPartStub = nil
	fake.patchPartReturns = struct {
		result1 *models.Part
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PatchPartReturnsOnCall(i int, result1 *models.Part, result2 error) {
	fake.patchPartMutex.Lock()
	defer fake.patchPartMutex.Unlock()
	fake.PatchPartStub = nil
	if fake.patchPartReturnsOnCall == nil {
		fake.patchPartReturnsOnCall = make(map[int]struct {
			result1 *models.Part
			result2 error
		})
	}
	fake.patchPartReturnsOnCall[i] = struct {
		result1 *models.Part
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PatchPartSupport(arg1 int32, arg2 int32, arg3 []*models.PatchDocument) (*models.PartSupport, error) {
	var arg3Copy []*models.PatchDocument
	if arg3 != nil {
		arg3Copy = make([]*models.PatchDocument, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.patchPartSupportMutex.Lock()
	ret, specificReturn := fake.patchPartSupportReturnsOnCall[len(fake.patchPartSupportArgsForCall)]
	fake.patchPartSupportArgsForCall = append(fake.patchPartSupportArgsForCall, struct {
		arg1 int32
		arg2 int32
		arg3 []*models.PatchDocument
	}{arg1, arg2, arg3Copy})
	fake.recordInvocation("PatchPartSupport", []interface{}{arg1, arg2, arg3Copy})
	fake.patchPartSupportMutex.Unlock()
	if fake.PatchPartSupportStub != nil {
		return fake.PatchPartSupportStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.patchPartSupportReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) PatchPartSupportCallCount() int {
	fake.patchPartSupportMutex.RLock()
	defer fake.patchPartSupportMutex.RUnlock()
	return len(fake.patchPartSupportArgsForCall)
}

func (fake *FakeClient) PatchPartSupportCalls(stub func(int32, int32, []*models.PatchDocument) (*models.PartSupport, error)) {
	fake.patchPartSupportMutex.Lock()
	defer fake.patchPartSupportMutex.Unlock()
	fake.PatchPartSupportStub = stub
}

func (fake *FakeClient) PatchPartSupportArgsForCall(i int) (int32, int32, []*models.PatchDocument) {
	fake.patchPartSupportMutex.RLock()
	defer fake.patchPartSupportMutex.RUnlock()
	argsForCall := fake.patchPartSupportArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) PatchPartSupportReturns(result1 *models.PartSupport, result2 error) {
	fake.patchPartSupportMutex.Lock()
	defer fake.patchPartSupportMutex.Unlock()
	fake.PatchPartSupportStub = nil
	fake.patchPartSupportReturns = struct {
		result1 *models.PartSupport
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PatchPartSupportReturnsOnCall(i int, result1 *models.PartSupport, result2 error) {
	fake.patchPartSupportMutex.Lock()
	defer fake.patchPartSupportMutex.Unlock()
	fake.PatchPartSupportStub = nil
	if fake.patchPartSupportReturnsOnCall == nil {
		fake.patchPartSupportReturnsOnCall = make(map[int]struct {
			result1 *models.PartSupport
			result2 error
		})
	}
	fake.patchPartSupportReturnsOnCall[i] = struct {
		result1 *models.PartSupport
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PatchPartSupportByID(arg1 int32, arg2 []*models.PatchDocument) (*models.PartSupport, error) {
	var arg2Copy []*models.PatchDocument
	if arg2 != nil {
		arg2Copy = make([]*models.PatchDocument, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.patchPartSupportByIDMutex.Lock()
	ret, specificReturn := fake.patchPartSupportByIDReturnsOnCall[len(fake.patchPartSupportByIDArgsForCall)]
	fake.patchPartSupportByIDArgsForCall = append(fake.patchPartSupportByIDArgsForCall, struct {
		arg1 int32
		arg2 []*models.PatchDocument
	}{arg1, arg2Copy})
	fake.recordInvocation("PatchPartSupportByID", []interface{}{arg1, arg2Copy})
	fake.patchPartSupportByIDMutex.Unlock()
	if fake.PatchPartSupportByIDStub != nil {
		return fake.PatchPartSupportByIDStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.patchPartSupportByIDReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) PatchPartSupportByIDCallCount() int {
	fake.patchPartSupportByIDMutex.RLock()
	defer fake.patchPartSupportByIDMutex.RUnlock()
	return len(fake.patchPartSupportByIDArgsForCall)
}

func (fake *FakeClient) PatchPartSupportByIDCalls(stub func(int32, []*models.PatchDocument) (*models.PartSupport, error)) {
	fake.patchPartSupportByIDMutex.Lock()
	defer fake.patchPartSupportByIDMutex.Unlock()
	fake.PatchPartSupportByIDStub = stub
}

func (fake *FakeClient) PatchPartSupportByIDArgsForCall(i int) (int32, []*models.PatchDocument) {
	fake.patchPartSupportByIDMutex.RLock()
	defer fake.patchPartSupportByIDMutex.RUnlock()
	argsForCall := fake.patchPartSupportByIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) PatchPartSupportByIDReturns(result1 *models.PartSupport, result2 error) {
	fake.patchPartSupportByIDMutex.Lock()
	defer fake.patchPartSupportByIDMutex.Unlock()
	fake.PatchPartSupportByIDStub = nil
	fake.patchPartSupportByIDReturns = struct {
		result1 *models.PartSupport
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PatchPartSupportByIDReturnsOnCall(i int, result1 *models.PartSupport, result2 error) {
	fake.patchPartSupportByIDMutex.Lock()
	defer fake.patchPartSupportByIDMutex.Unlock()
	fake.PatchPartSupportByIDStub = nil
	if fake.patchPartSupportByIDReturnsOnCall == nil {
		fake.patchPartSupportByIDReturnsOnCall = make(map[int]struct {
			result1 *models.PartSupport
			result2 error
		})
	}
	fake.patchPartSupportByIDReturnsOnCall[i] = struct {
		result1 *models.PartSupport
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PatchSimulation(arg1 int32, arg2 *models.PatchDocument) error {
	fake.patchSimulationMutex.Lock()
	ret, specificReturn := fake.patchSimulationReturnsOnCall[len(fake.patchSimulationArgsForCall)]
	fake.patchSimulationArgsForCall = append(fake.patchSimulationArgsForCall, struct {
		arg1 int32
		arg2 *models.PatchDocument
	}{arg1, arg2})
	fake.recordInvocation("PatchSimulation", []interface{}{arg1, arg2})
	fake.patchSimulationMutex.Unlock()
	if fake.PatchSimulationStub != nil {
		return fake.PatchSimulationStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.patchSimulationReturns
	return fakeReturns.result1
}

func (fake *FakeClient) PatchSimulationCallCount() int {
	fake.patchSimulationMutex.RLock()
	defer fake.patchSimulationMutex.RUnlock()
	return len(fake.patchSimulationArgsForCall)
}

func (fake *FakeClient) PatchSimulationCalls(stub func(int32, *models.PatchDocument) error) {
	fake.patchSimulationMutex.Lock()
	defer fake.patchSimulationMutex.Unlock()
	fake.PatchSimulationStub = stub
}

func (fake *FakeClient) PatchSimulationArgsForCall(i int) (int32, *models.PatchDocument) {
	fake.patchSimulationMutex.RLock()
	defer fake.patchSimulationMutex.RUnlock()
	argsForCall := fake.patchSimulationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) PatchSimulationReturns(result1 error) {
	fake.patchSimulationMutex.Lock()
	defer fake.patchSimulationMutex.Unlock()
	fake.PatchSimulationStub = nil
	fake.patchSimulationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PatchSimulationReturnsOnCall(i int, result1 error) {
	fake.patchSimulationMutex.Lock()
	defer fake.patchSimulationMutex.Unlock()
	fake.PatchSimulationStub = nil
	if fake.patchSimulationReturnsOnCall == nil {
		fake.patchSimulationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.patchSimulationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PatchSimulationActivity(arg1 int32, arg2 string, arg3 []*models.PatchDocument) (*models.SimulationActivity, error) {
	var arg3Copy []*models.PatchDocument
	if arg3 != nil {
		arg3Copy = make([]*models.PatchDocument, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.patchSimulationActivityMutex.Lock()
	ret, specificReturn := fake.patchSimulationActivityReturnsOnCall[len(fake.patchSimulationActivityArgsForCall)]
	fake.patchSimulationActivityArgsForCall = append(fake.patchSimulationActivityArgsForCall, struct {
		arg1 int32
		arg2 string
		arg3 []*models.PatchDocument
	}{arg1, arg2, arg3Copy})
	fake.recordInvocation("PatchSimulationActivity", []interface{}{arg1, arg2, arg3Copy})
	fake.patchSimulationActivityMutex.Unlock()
	if fake.PatchSimulationActivityStub != nil {
		return fake.PatchSimulationActivityStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.patchSimulationActivityReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) PatchSimulationActivityCallCount() int {
	fake.patchSimulationActivityMutex.RLock()
	defer fake.patchSimulationActivityMutex.RUnlock()
	return len(fake.patchSimulationActivityArgsForCall)
}

func (fake *FakeClient) PatchSimulationActivityCalls(stub func(int32, string, []*models.PatchDocument) (*models.SimulationActivity, error)) {
	fake.patchSimulationActivityMutex.Lock()
	defer fake.patchSimulationActivityMutex.Unlock()
	fake.PatchSimulationActivityStub = stub
}

func (fake *FakeClient) PatchSimulationActivityArgsForCall(i int) (int32, string, []*models.PatchDocument) {
	fake.patchSimulationActivityMutex.RLock()
	defer fake.patchSimulationActivityMutex.RUnlock()
	argsForCall := fake.patchSimulationActivityArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) PatchSimulationActivityReturns(result1 *models.SimulationActivity, result2 error) {
	fake.patchSimulationActivityMutex.Lock()
	defer fake.patchSimulationActivityMutex.Unlock()
	fake.PatchSimulationActivityStub = nil
	fake.patchSimulationActivityReturns = struct {
		result1 *models.SimulationActivity
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PatchSimulationActivityReturnsOnCall(i int, result1 *models.SimulationActivity, result2 error) {
	fake.patchSimulationActivityMutex.Lock()
	defer fake.patchSimulationActivityMutex.Unlock()
	fake.PatchSimulationActivityStub = nil
	if fake.patchSimulationActivityReturnsOnCall == nil {
		fake.patchSimulationActivityReturnsOnCall = make(map[int]struct {
			result1 *models.SimulationActivity
			result2 error
		})
	}
	fake.patchSimulationActivityReturnsOnCall[i] = struct {
		result1 *models.SimulationActivity
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PorositySimulation(arg1 int32) (*models.PorositySimulation, error) {
	fake.porositySimulationMutex.Lock()
	ret, specificReturn := fake.porositySimulationReturnsOnCall[len(fake.porositySimulationArgsForCall)]
	fake.porositySimulationArgsForCall = append(fake.porositySimulationArgsForCall, struct {
		arg1 int32
	}{arg1})
	fake.recordInvocation("PorositySimulation", []interface{}{arg1})
	fake.porositySimulationMutex.Unlock()
	if fake.PorositySimulationStub != nil {
		return fake.PorositySimulationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.porositySimulationReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) PorositySimulationCallCount() int {
	fake.porositySimulationMutex.RLock()
	defer fake.porositySimulationMutex.RUnlock()
	return len(fake.porositySimulationArgsForCall)
}

func (fake *FakeClient) PorositySimulationCalls(stub func(int32) (*models.PorositySimulation, error)) {
	fake.porositySimulationMutex.Lock()
	defer fake.porositySimulationMutex.Unlock()
	fake.PorositySimulationStub = stub
}

func (fake *FakeClient) PorositySimulationArgsForCall(i int) int32 {
	fake.porositySimulationMutex.RLock()
	defer fake.porositySimulationMutex.RUnlock()
	argsForCall := fake.porositySimulationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) PorositySimulationReturns(result1 *models.PorositySimulation, result2 error) {
	fake.porositySimulationMutex.Lock()
	defer fake.porositySimulationMutex.Unlock()
	fake.PorositySimulationStub = nil
	fake.porositySimulationReturns = struct {
		result1 *models.PorositySimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PorositySimulationReturnsOnCall(i int, result1 *models.PorositySimulation, result2 error) {
	fake.porositySimulationMutex.Lock()
	defer fake.porositySimulationMutex.Unlock()
	fake.PorositySimulationStub = nil
	if fake.porositySimulationReturnsOnCall == nil {
		fake.porositySimulationReturnsOnCall = make(map[int]struct {
			result1 *models.PorositySimulation
			result2 error
		})
	}
	fake.porositySimulationReturnsOnCall[i] = struct {
		result1 *models.PorositySimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostAssumedStrainSimulation(arg1 *models.AssumedStrainSimulation) (*models.AssumedStrainSimulation, error) {
	fake.postAssumedStrainSimulationMutex.Lock()
	ret, specificReturn := fake.postAssumedStrainSimulationReturnsOnCall[len(fake.postAssumedStrainSimulationArgsForCall)]
	fake.postAssumedStrainSimulationArgsForCall = append(fake.postAssumedStrainSimulationArgsForCall, struct {
		arg1 *models.AssumedStrainSimulation
	}{arg1})
	fake.recordInvocation("PostAssumedStrainSimulation", []interface{}{arg1})
	fake.postAssumedStrainSimulationMutex.Unlock()
	if fake.PostAssumedStrainSimulationStub != nil {
		return fake.PostAssumedStrainSimulationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.postAssumedStrainSimulationReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) PostAssumedStrainSimulationCallCount() int {
	fake.postAssumedStrainSimulationMutex.RLock()
	defer fake.postAssumedStrainSimulationMutex.RUnlock()
	return len(fake.postAssumedStrainSimulationArgsForCall)
}

func (fake *FakeClient) PostAssumedStrainSimulationCalls(stub func(*models.AssumedStrainSimulation) (*models.AssumedStrainSimulation, error)) {
	fake.postAssumedStrainSimulationMutex.Lock()
	defer fake.postAssumedStrainSimulationMutex.Unlock()
	fake.PostAssumedStrainSimulationStub = stub
}

func (fake *FakeClient) PostAssumedStrainSimulationArgsForCall(i int) *models.AssumedStrainSimulation {
	fake.postAssumedStrainSimulationMutex.RLock()
	defer fake.postAssumedStrainSimulationMutex.RUnlock()
	argsForCall := fake.postAssumedStrainSimulationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) PostAssumedStrainSimulationReturns(result1 *models.AssumedStrainSimulation, result2 error) {
	fake.postAssumedStrainSimulationMutex.Lock()
	defer fake.postAssumedStrainSimulationMutex.Unlock()
	fake.PostAssumedStrainSimulationStub = nil
	fake.postAssumedStrainSimulationReturns = struct {
		result1 *models.AssumedStrainSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostAssumedStrainSimulationReturnsOnCall(i int, result1 *models.AssumedStrainSimulation, result2 error) {
	fake.postAssumedStrainSimulationMutex.Lock()
	defer fake.postAssumedStrainSimulationMutex.Unlock()
	fake.PostAssumedStrainSimulationStub = nil
	if fake.postAssumedStrainSimulationReturnsOnCall == nil {
		fake.postAssumedStrainSimulationReturnsOnCall = make(map[int]struct {
			result1 *models.AssumedStrainSimulation
			result2 error
		})
	}
	fake.postAssumedStrainSimulationReturnsOnCall[i] = struct {
		result1 *models.AssumedStrainSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostBuildFile(arg1 *models.BuildFilePost) (*models.BuildFile, error) {
	fake.postBuildFileMutex.Lock()
	ret, specificReturn := fake.postBuildFileReturnsOnCall[len(fake.postBuildFileArgsForCall)]
	fake.postBuildFileArgsForCall = append(fake.postBuildFileArgsForCall, struct {
		arg1 *models.BuildFilePost
	}{arg1})
	fake.recordInvocation("PostBuildFile", []interface{}{arg1})
	fake.postBuildFileMutex.Unlock()
	if fake.PostBuildFileStub != nil {
		return fake.PostBuildFileStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.postBuildFileReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) PostBuildFileCallCount() int {
	fake.postBuildFileMutex.RLock()
	defer fake.postBuildFileMutex.RUnlock()
	return len(fake.postBuildFileArgsForCall)
}

func (fake *FakeClient) PostBuildFileCalls(stub func(*models.BuildFilePost) (*models.BuildFile, error)) {
	fake.postBuildFileMutex.Lock()
	defer fake.postBuildFileMutex.Unlock()
	fake.PostBuildFileStub = stub
}

func (fake *FakeClient) PostBuildFileArgsForCall(i int) *models.BuildFilePost {
	fake.postBuildFileMutex.RLock()
	defer fake.postBuildFileMutex.RUnlock()
	argsForCall := fake.postBuildFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) PostBuildFileReturns(result1 *models.BuildFile, result2 error) {
	fake.postBuildFileMutex.Lock()
	defer fake.postBuildFileMutex.Unlock()
	fake.PostBuildFileStub = nil
	fake.postBuildFileReturns = struct {
		result1 *models.BuildFile
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostBuildFileReturnsOnCall(i int, result1 *models.BuildFile, result2 error) {
	fake.postBuildFileMutex.Lock()
	defer fake.postBuildFileMutex.Unlock()
	fake.PostBuildFileStub = nil
	if fake.postBuildFileReturnsOnCall == nil {
		fake.postBuildFileReturnsOnCall = make(map[int]struct {
			result1 *models.BuildFile
			result2 error
		})
	}
	fake.postBuildFileReturnsOnCall[i] = struct {
		result1 *models.BuildFile
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostLog(arg1 string, arg2 string, arg3 int32, arg4 string) error {
	fake.postLogMutex.Lock()
	ret, specificReturn := fake.postLogReturnsOnCall[len(fake.postLogArgsForCall)]
	fake.postLogArgsForCall = append(fake.postLogArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 int32
		arg4 string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("PostLog", []interface{}{arg1, arg2, arg3, arg4})
	fake.postLogMutex.Unlock()
	if fake.PostLogStub != nil {
		return fake.PostLogStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.postLogReturns
	return fakeReturns.result1
}

func (fake *FakeClient) PostLogCallCount() int {
	fake.postLogMutex.RLock()
	defer fake.postLogMutex.RUnlock()
	return len(fake.postLogArgsForCall)
}

func (fake *FakeClient) PostLogCalls(stub func(string, string, int32, string) error) {
	fake.postLogMutex.Lock()
	defer fake.postLogMutex.Unlock()
	fake.PostLogStub = stub
}

func (fake *FakeClient) PostLogArgsForCall(i int) (string, string, int32, string) {
	fake.postLogMutex.RLock()
	defer fake.postLogMutex.RUnlock()
	argsForCall := fake.postLogArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) PostLogReturns(result1 error) {
	fake.postLogMutex.Lock()
	defer fake.postLogMutex.Unlock()
	fake.PostLogStub = nil
	fake.postLogReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PostLogReturnsOnCall(i int, result1 error) {
	fake.postLogMutex.Lock()
	defer fake.postLogMutex.Unlock()
	fake.PostLogStub = nil
	if fake.postLogReturnsOnCall == nil {
		fake.postLogReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.postLogReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PostLogError(arg1 string, arg2 int32, arg3 string) error {
	fake.postLogErrorMutex.Lock()
	ret, specificReturn := fake.postLogErrorReturnsOnCall[len(fake.postLogErrorArgsForCall)]
	fake.postLogErrorArgsForCall = append(fake.postLogErrorArgsForCall, struct {
		arg1 string
		arg2 int32
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("PostLogError", []interface{}{arg1, arg2, arg3})
	fake.postLogErrorMutex.Unlock()
	if fake.PostLogErrorStub != nil {
		return fake.PostLogErrorStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.postLogErrorReturns
	return fakeReturns.result1
}

func (fake *FakeClient) PostLogErrorCallCount() int {
	fake.postLogErrorMutex.RLock()
	defer fake.postLogErrorMutex.RUnlock()
	return len(fake.postLogErrorArgsForCall)
}

func (fake *FakeClient) PostLogErrorCalls(stub func(string, int32, string) error) {
	fake.postLogErrorMutex.Lock()
	defer fake.postLogErrorMutex.Unlock()
	fake.PostLogErrorStub = stub
}

func (fake *FakeClient) PostLogErrorArgsForCall(i int) (string, int32, string) {
	fake.postLogErrorMutex.RLock()
	defer fake.postLogErrorMutex.RUnlock()
	argsForCall := fake.postLogErrorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) PostLogErrorReturns(result1 error) {
	fake.postLogErrorMutex.Lock()
	defer fake.postLogErrorMutex.Unlock()
	fake.PostLogErrorStub = nil
	fake.postLogErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PostLogErrorReturnsOnCall(i int, result1 error) {
	fake.postLogErrorMutex.Lock()
	defer fake.postLogErrorMutex.Unlock()
	fake.PostLogErrorStub = nil
	if fake.postLogErrorReturnsOnCall == nil {
		fake.postLogErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.postLogErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PostLogInfo(arg1 string, arg2 int32, arg3 string) error {
	fake.postLogInfoMutex.Lock()
	ret, specificReturn := fake.postLogInfoReturnsOnCall[len(fake.postLogInfoArgsForCall)]
	fake.postLogInfoArgsForCall = append(fake.postLogInfoArgsForCall, struct {
		arg1 string
		arg2 int32
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("PostLogInfo", []interface{}{arg1, arg2, arg3})
	fake.postLogInfoMutex.Unlock()
	if fake.PostLogInfoStub != nil {
		return fake.PostLogInfoStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.postLogInfoReturns
	return fakeReturns.result1
}

func (fake *FakeClient) PostLogInfoCallCount() int {
	fake.postLogInfoMutex.RLock()
	defer fake.postLogInfoMutex.RUnlock()
	return len(fake.postLogInfoArgsForCall)
}

func (fake *FakeClient) PostLogInfoCalls(stub func(string, int32, string) error) {
	fake.postLogInfoMutex.Lock()
	defer fake.postLogInfoMutex.Unlock()
	fake.PostLogInfoStub = stub
}

func (fake *FakeClient) PostLogInfoArgsForCall(i int) (string, int32, string) {
	fake.postLogInfoMutex.RLock()
	defer fake.postLogInfoMutex.RUnlock()
	argsForCall := fake.postLogInfoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) PostLogInfoReturns(result1 error) {
	fake.postLogInfoMutex.Lock()
	defer fake.postLogInfoMutex.Unlock()
	fake.PostLogInfoStub = nil
	fake.postLogInfoReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PostLogInfoReturnsOnCall(i int, result1 error) {
	fake.postLogInfoMutex.Lock()
	defer fake.postLogInfoMutex.Unlock()
	fake.PostLogInfoStub = nil
	if fake.postLogInfoReturnsOnCall == nil {
		fake.postLogInfoReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.postLogInfoReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PostLogWarn(arg1 string, arg2 int32, arg3 string) error {
	fake.postLogWarnMutex.Lock()
	ret, specificReturn := fake.postLogWarnReturnsOnCall[len(fake.postLogWarnArgsForCall)]
	fake.postLogWarnArgsForCall = append(fake.postLogWarnArgsForCall, struct {
		arg1 string
		arg2 int32
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("PostLogWarn", []interface{}{arg1, arg2, arg3})
	fake.postLogWarnMutex.Unlock()
	if fake.PostLogWarnStub != nil {
		return fake.PostLogWarnStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.postLogWarnReturns
	return fakeReturns.result1
}

func (fake *FakeClient) PostLogWarnCallCount() int {
	fake.postLogWarnMutex.RLock()
	defer fake.postLogWarnMutex.RUnlock()
	return len(fake.postLogWarnArgsForCall)
}

func (fake *FakeClient) PostLogWarnCalls(stub func(string, int32, string) error) {
	fake.postLogWarnMutex.Lock()
	defer fake.postLogWarnMutex.Unlock()
	fake.PostLogWarnStub = stub
}

func (fake *FakeClient) PostLogWarnArgsForCall(i int) (string, int32, string) {
	fake.postLogWarnMutex.RLock()
	defer fake.postLogWarnMutex.RUnlock()
	argsForCall := fake.postLogWarnArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) PostLogWarnReturns(result1 error) {
	fake.postLogWarnMutex.Lock()
	defer fake.postLogWarnMutex.Unlock()
	fake.PostLogWarnStub = nil
	fake.postLogWarnReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PostLogWarnReturnsOnCall(i int, result1 error) {
	fake.postLogWarnMutex.Lock()
	defer fake.postLogWarnMutex.Unlock()
	fake.PostLogWarnStub = nil
	if fake.postLogWarnReturnsOnCall == nil {
		fake.postLogWarnReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.postLogWarnReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PostLogWithObject(arg1 models.SimulationLog) error {
	fake.postLogWithObjectMutex.Lock()
	ret, specificReturn := fake.postLogWithObjectReturnsOnCall[len(fake.postLogWithObjectArgsForCall)]
	fake.postLogWithObjectArgsForCall = append(fake.postLogWithObjectArgsForCall, struct {
		arg1 models.SimulationLog
	}{arg1})
	fake.recordInvocation("PostLogWithObject", []interface{}{arg1})
	fake.postLogWithObjectMutex.Unlock()
	if fake.PostLogWithObjectStub != nil {
		return fake.PostLogWithObjectStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.postLogWithObjectReturns
	return fakeReturns.result1
}

func (fake *FakeClient) PostLogWithObjectCallCount() int {
	fake.postLogWithObjectMutex.RLock()
	defer fake.postLogWithObjectMutex.RUnlock()
	return len(fake.postLogWithObjectArgsForCall)
}

func (fake *FakeClient) PostLogWithObjectCalls(stub func(models.SimulationLog) error) {
	fake.postLogWithObjectMutex.Lock()
	defer fake.postLogWithObjectMutex.Unlock()
	fake.PostLogWithObjectStub = stub
}

func (fake *FakeClient) PostLogWithObjectArgsForCall(i int) models.SimulationLog {
	fake.postLogWithObjectMutex.RLock()
	defer fake.postLogWithObjectMutex.RUnlock()
	argsForCall := fake.postLogWithObjectArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) PostLogWithObjectReturns(result1 error) {
	fake.postLogWithObjectMutex.Lock()
	defer fake.postLogWithObjectMutex.Unlock()
	fake.PostLogWithObjectStub = nil
	fake.postLogWithObjectReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PostLogWithObjectReturnsOnCall(i int, result1 error) {
	fake.postLogWithObjectMutex.Lock()
	defer fake.postLogWithObjectMutex.Unlock()
	fake.PostLogWithObjectStub = nil
	if fake.postLogWithObjectReturnsOnCall == nil {
		fake.postLogWithObjectReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.postLogWithObjectReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PostMicrostructureSimulation(arg1 *models.MicrostructureSimulation) (*models.MicrostructureSimulation, error) {
	fake.postMicrostructureSimulationMutex.Lock()
	ret, specificReturn := fake.postMicrostructureSimulationReturnsOnCall[len(fake.postMicrostructureSimulationArgsForCall)]
	fake.postMicrostructureSimulationArgsForCall = append(fake.postMicrostructureSimulationArgsForCall, struct {
		arg1 *models.MicrostructureSimulation
	}{arg1})
	fake.recordInvocation("PostMicrostructureSimulation", []interface{}{arg1})
	fake.postMicrostructureSimulationMutex.Unlock()
	if fake.PostMicrostructureSimulationStub != nil {
		return fake.PostMicrostructureSimulationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.postMicrostructureSimulationReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) PostMicrostructureSimulationCallCount() int {
	fake.postMicrostructureSimulationMutex.RLock()
	defer fake.postMicrostructureSimulationMutex.RUnlock()
	return len(fake.postMicrostructureSimulationArgsForCall)
}

func (fake *FakeClient) PostMicrostructureSimulationCalls(stub func(*models.MicrostructureSimulation) (*models.MicrostructureSimulation, error)) {
	fake.postMicrostructureSimulationMutex.Lock()
	defer fake.postMicrostructureSimulationMutex.Unlock()
	fake.PostMicrostructureSimulationStub = stub
}

func (fake *FakeClient) PostMicrostructureSimulationArgsForCall(i int) *models.MicrostructureSimulation {
	fake.postMicrostructureSimulationMutex.RLock()
	defer fake.postMicrostructureSimulationMutex.RUnlock()
	argsForCall := fake.postMicrostructureSimulationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) PostMicrostructureSimulationReturns(result1 *models.MicrostructureSimulation, result2 error) {
	fake.postMicrostructureSimulationMutex.Lock()
	defer fake.postMicrostructureSimulationMutex.Unlock()
	fake.PostMicrostructureSimulationStub = nil
	fake.postMicrostructureSimulationReturns = struct {
		result1 *models.MicrostructureSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostMicrostructureSimulationReturnsOnCall(i int, result1 *models.MicrostructureSimulation, result2 error) {
	fake.postMicrostructureSimulationMutex.Lock()
	defer fake.postMicrostructureSimulationMutex.Unlock()
	fake.PostMicrostructureSimulationStub = nil
	if fake.postMicrostructureSimulationReturnsOnCall == nil {
		fake.postMicrostructureSimulationReturnsOnCall = make(map[int]struct {
			result1 *models.MicrostructureSimulation
			result2 error
		})
	}
	fake.postMicrostructureSimulationReturnsOnCall[i] = struct {
		result1 *models.MicrostructureSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostPorositySimulation(arg1 *models.PorositySimulation) (*models.PorositySimulation, error) {
	fake.postPorositySimulationMutex.Lock()
	ret, specificReturn := fake.postPorositySimulationReturnsOnCall[len(fake.postPorositySimulationArgsForCall)]
	fake.postPorositySimulationArgsForCall = append(fake.postPorositySimulationArgsForCall, struct {
		arg1 *models.PorositySimulation
	}{arg1})
	fake.recordInvocation("PostPorositySimulation", []interface{}{arg1})
	fake.postPorositySimulationMutex.Unlock()
	if fake.PostPorositySimulationStub != nil {
		return fake.PostPorositySimulationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.postPorositySimulationReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) PostPorositySimulationCallCount() int {
	fake.postPorositySimulationMutex.RLock()
	defer fake.postPorositySimulationMutex.RUnlock()
	return len(fake.postPorositySimulationArgsForCall)
}

func (fake *FakeClient) PostPorositySimulationCalls(stub func(*models.PorositySimulation) (*models.PorositySimulation, error)) {
	fake.postPorositySimulationMutex.Lock()
	defer fake.postPorositySimulationMutex.Unlock()
	fake.PostPorositySimulationStub = stub
}

func (fake *FakeClient) PostPorositySimulationArgsForCall(i int) *models.PorositySimulation {
	fake.postPorositySimulationMutex.RLock()
	defer fake.postPorositySimulationMutex.RUnlock()
	argsForCall := fake.postPorositySimulationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) PostPorositySimulationReturns(result1 *models.PorositySimulation, result2 error) {
	fake.postPorositySimulationMutex.Lock()
	defer fake.postPorositySimulationMutex.Unlock()
	fake.PostPorositySimulationStub = nil
	fake.postPorositySimulationReturns = struct {
		result1 *models.PorositySimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostPorositySimulationReturnsOnCall(i int, result1 *models.PorositySimulation, result2 error) {
	fake.postPorositySimulationMutex.Lock()
	defer fake.postPorositySimulationMutex.Unlock()
	fake.PostPorositySimulationStub = nil
	if fake.postPorositySimulationReturnsOnCall == nil {
		fake.postPorositySimulationReturnsOnCall = make(map[int]struct {
			result1 *models.PorositySimulation
			result2 error
		})
	}
	fake.postPorositySimulationReturnsOnCall[i] = struct {
		result1 *models.PorositySimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostScanPatternSimulation(arg1 *models.ScanPatternSimulation) (*models.ScanPatternSimulation, error) {
	fake.postScanPatternSimulationMutex.Lock()
	ret, specificReturn := fake.postScanPatternSimulationReturnsOnCall[len(fake.postScanPatternSimulationArgsForCall)]
	fake.postScanPatternSimulationArgsForCall = append(fake.postScanPatternSimulationArgsForCall, struct {
		arg1 *models.ScanPatternSimulation
	}{arg1})
	fake.recordInvocation("PostScanPatternSimulation", []interface{}{arg1})
	fake.postScanPatternSimulationMutex.Unlock()
	if fake.PostScanPatternSimulationStub != nil {
		return fake.PostScanPatternSimulationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.postScanPatternSimulationReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) PostScanPatternSimulationCallCount() int {
	fake.postScanPatternSimulationMutex.RLock()
	defer fake.postScanPatternSimulationMutex.RUnlock()
	return len(fake.postScanPatternSimulationArgsForCall)
}

func (fake *FakeClient) PostScanPatternSimulationCalls(stub func(*models.ScanPatternSimulation) (*models.ScanPatternSimulation, error)) {
	fake.postScanPatternSimulationMutex.Lock()
	defer fake.postScanPatternSimulationMutex.Unlock()
	fake.PostScanPatternSimulationStub = stub
}

func (fake *FakeClient) PostScanPatternSimulationArgsForCall(i int) *models.ScanPatternSimulation {
	fake.postScanPatternSimulationMutex.RLock()
	defer fake.postScanPatternSimulationMutex.RUnlock()
	argsForCall := fake.postScanPatternSimulationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) PostScanPatternSimulationReturns(result1 *models.ScanPatternSimulation, result2 error) {
	fake.postScanPatternSimulationMutex.Lock()
	defer fake.postScanPatternSimulationMutex.Unlock()
	fake.PostScanPatternSimulationStub = nil
	fake.postScanPatternSimulationReturns = struct {
		result1 *models.ScanPatternSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostScanPatternSimulationReturnsOnCall(i int, result1 *models.ScanPatternSimulation, result2 error) {
	fake.postScanPatternSimulationMutex.Lock()
	defer fake.postScanPatternSimulationMutex.Unlock()
	fake.PostScanPatternSimulationStub = nil
	if fake.postScanPatternSimulationReturnsOnCall == nil {
		fake.postScanPatternSimulationReturnsOnCall = make(map[int]struct {
			result1 *models.ScanPatternSimulation
			result2 error
		})
	}
	fake.postScanPatternSimulationReturnsOnCall[i] = struct {
		result1 *models.ScanPatternSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostSimulationActivity(arg1 int32, arg2 *models.SimulationActivity) (*models.SimulationActivity, error) {
	fake.postSimulationActivityMutex.Lock()
	ret, specificReturn := fake.postSimulationActivityReturnsOnCall[len(fake.postSimulationActivityArgsForCall)]
	fake.postSimulationActivityArgsForCall = append(fake.postSimulationActivityArgsForCall, struct {
		arg1 int32
		arg2 *models.SimulationActivity
	}{arg1, arg2})
	fake.recordInvocation("PostSimulationActivity", []interface{}{arg1, arg2})
	fake.postSimulationActivityMutex.Unlock()
	if fake.PostSimulationActivityStub != nil {
		return fake.PostSimulationActivityStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.postSimulationActivityReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) PostSimulationActivityCallCount() int {
	fake.postSimulationActivityMutex.RLock()
	defer fake.postSimulationActivityMutex.RUnlock()
	return len(fake.postSimulationActivityArgsForCall)
}

func (fake *FakeClient) PostSimulationActivityCalls(stub func(int32, *models.SimulationActivity) (*models.SimulationActivity, error)) {
	fake.postSimulationActivityMutex.Lock()
	defer fake.postSimulationActivityMutex.Unlock()
	fake.PostSimulationActivityStub = stub
}

func (fake *FakeClient) PostSimulationActivityArgsForCall(i int) (int32, *models.SimulationActivity) {
	fake.postSimulationActivityMutex.RLock()
	defer fake.postSimulationActivityMutex.RUnlock()
	argsForCall := fake.postSimulationActivityArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) PostSimulationActivityReturns(result1 *models.SimulationActivity, result2 error) {
	fake.postSimulationActivityMutex.Lock()
	defer fake.postSimulationActivityMutex.Unlock()
	fake.PostSimulationActivityStub = nil
	fake.postSimulationActivityReturns = struct {
		result1 *models.SimulationActivity
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostSimulationActivityReturnsOnCall(i int, result1 *models.SimulationActivity, result2 error) {
	fake.postSimulationActivityMutex.Lock()
	defer fake.postSimulationActivityMutex.Unlock()
	fake.PostSimulationActivityStub = nil
	if fake.postSimulationActivityReturnsOnCall == nil {
		fake.postSimulationActivityReturnsOnCall = make(map[int]struct {
			result1 *models.SimulationActivity
			result2 error
		})
	}
	fake.postSimulationActivityReturnsOnCall[i] = struct {
		result1 *models.SimulationActivity
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostSingleBeadSimulation(arg1 *models.SingleBeadSimulation) (*models.SingleBeadSimulation, error) {
	fake.postSingleBeadSimulationMutex.Lock()
	ret, specificReturn := fake.postSingleBeadSimulationReturnsOnCall[len(fake.postSingleBeadSimulationArgsForCall)]
	fake.postSingleBeadSimulationArgsForCall = append(fake.postSingleBeadSimulationArgsForCall, struct {
		arg1 *models.SingleBeadSimulation
	}{arg1})
	fake.recordInvocation("PostSingleBeadSimulation", []interface{}{arg1})
	fake.postSingleBeadSimulationMutex.Unlock()
	if fake.PostSingleBeadSimulationStub != nil {
		return fake.PostSingleBeadSimulationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.postSingleBeadSimulationReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) PostSingleBeadSimulationCallCount() int {
	fake.postSingleBeadSimulationMutex.RLock()
	defer fake.postSingleBeadSimulationMutex.RUnlock()
	return len(fake.postSingleBeadSimulationArgsForCall)
}

func (fake *FakeClient) PostSingleBeadSimulationCalls(stub func(*models.SingleBeadSimulation) (*models.SingleBeadSimulation, error)) {
	fake.postSingleBeadSimulationMutex.Lock()
	defer fake.postSingleBeadSimulationMutex.Unlock()
	fake.PostSingleBeadSimulationStub = stub
}

func (fake *FakeClient) PostSingleBeadSimulationArgsForCall(i int) *models.SingleBeadSimulation {
	fake.postSingleBeadSimulationMutex.RLock()
	defer fake.postSingleBeadSimulationMutex.RUnlock()
	argsForCall := fake.postSingleBeadSimulationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) PostSingleBeadSimulationReturns(result1 *models.SingleBeadSimulation, result2 error) {
	fake.postSingleBeadSimulationMutex.Lock()
	defer fake.postSingleBeadSimulationMutex.Unlock()
	fake.PostSingleBeadSimulationStub = nil
	fake.postSingleBeadSimulationReturns = struct {
		result1 *models.SingleBeadSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostSingleBeadSimulationReturnsOnCall(i int, result1 *models.SingleBeadSimulation, result2 error) {
	fake.postSingleBeadSimulationMutex.Lock()
	defer fake.postSingleBeadSimulationMutex.Unlock()
	fake.PostSingleBeadSimulationStub = nil
	if fake.postSingleBeadSimulationReturnsOnCall == nil {
		fake.postSingleBeadSimulationReturnsOnCall = make(map[int]struct {
			result1 *models.SingleBeadSimulation
			result2 error
		})
	}
	fake.postSingleBeadSimulationReturnsOnCall[i] = struct {
		result1 *models.SingleBeadSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostThermalSimulation(arg1 *models.ThermalSimulation) (*models.ThermalSimulation, error) {
	fake.postThermalSimulationMutex.Lock()
	ret, specificReturn := fake.postThermalSimulationReturnsOnCall[len(fake.postThermalSimulationArgsForCall)]
	fake.postThermalSimulationArgsForCall = append(fake.postThermalSimulationArgsForCall, struct {
		arg1 *models.ThermalSimulation
	}{arg1})
	fake.recordInvocation("PostThermalSimulation", []interface{}{arg1})
	fake.postThermalSimulationMutex.Unlock()
	if fake.PostThermalSimulationStub != nil {
		return fake.PostThermalSimulationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.postThermalSimulationReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) PostThermalSimulationCallCount() int {
	fake.postThermalSimulationMutex.RLock()
	defer fake.postThermalSimulationMutex.RUnlock()
	return len(fake.postThermalSimulationArgsForCall)
}

func (fake *FakeClient) PostThermalSimulationCalls(stub func(*models.ThermalSimulation) (*models.ThermalSimulation, error)) {
	fake.postThermalSimulationMutex.Lock()
	defer fake.postThermalSimulationMutex.Unlock()
	fake.PostThermalSimulationStub = stub
}

func (fake *FakeClient) PostThermalSimulationArgsForCall(i int) *models.ThermalSimulation {
	fake.postThermalSimulationMutex.RLock()
	defer fake.postThermalSimulationMutex.RUnlock()
	argsForCall := fake.postThermalSimulationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) PostThermalSimulationReturns(result1 *models.ThermalSimulation, result2 error) {
	fake.postThermalSimulationMutex.Lock()
	defer fake.postThermalSimulationMutex.Unlock()
	fake.PostThermalSimulationStub = nil
	fake.postThermalSimulationReturns = struct {
		result1 *models.ThermalSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostThermalSimulationReturnsOnCall(i int, result1 *models.ThermalSimulation, result2 error) {
	fake.postThermalSimulationMutex.Lock()
	defer fake.postThermalSimulationMutex.Unlock()
	fake.PostThermalSimulationStub = nil
	if fake.postThermalSimulationReturnsOnCall == nil {
		fake.postThermalSimulationReturnsOnCall = make(map[int]struct {
			result1 *models.ThermalSimulation
			result2 error
		})
	}
	fake.postThermalSimulationReturnsOnCall[i] = struct {
		result1 *models.ThermalSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PutSimulationActivity(arg1 int32, arg2 *models.SimulationActivity) error {
	fake.putSimulationActivityMutex.Lock()
	ret, specificReturn := fake.putSimulationActivityReturnsOnCall[len(fake.putSimulationActivityArgsForCall)]
	fake.putSimulationActivityArgsForCall = append(fake.putSimulationActivityArgsForCall, struct {
		arg1 int32
		arg2 *models.SimulationActivity
	}{arg1, arg2})
	fake.recordInvocation("PutSimulationActivity", []interface{}{arg1, arg2})
	fake.putSimulationActivityMutex.Unlock()
	if fake.PutSimulationActivityStub != nil {
		return fake.PutSimulationActivityStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.putSimulationActivityReturns
	return fakeReturns.result1
}

func (fake *FakeClient) PutSimulationActivityCallCount() int {
	fake.putSimulationActivityMutex.RLock()
	defer fake.putSimulationActivityMutex.RUnlock()
	return len(fake.putSimulationActivityArgsForCall)
}

func (fake *FakeClient) PutSimulationActivityCalls(stub func(int32, *models.SimulationActivity) error) {
	fake.putSimulationActivityMutex.Lock()
	defer fake.putSimulationActivityMutex.Unlock()
	fake.PutSimulationActivityStub = stub
}

func (fake *FakeClient) PutSimulationActivityArgsForCall(i int) (int32, *models.SimulationActivity) {
	fake.putSimulationActivityMutex.RLock()
	defer fake.putSimulationActivityMutex.RUnlock()
	argsForCall := fake.putSimulationActivityArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) PutSimulationActivityReturns(result1 error) {
	fake.putSimulationActivityMutex.Lock()
	defer fake.putSimulationActivityMutex.Unlock()
	fake.PutSimulationActivityStub = nil
	fake.putSimulationActivityReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PutSimulationActivityReturnsOnCall(i int, result1 error) {
	fake.putSimulationActivityMutex.Lock()
	defer fake.putSimulationActivityMutex.Unlock()
	fake.PutSimulationActivityStub = nil
	if fake.putSimulationActivityReturnsOnCall == nil {
		fake.putSimulationActivityReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.putSimulationActivityReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) RawBuildFile(arg1 int32) (map[string]interface{}, error) {
	fake.rawBuildFileMutex.Lock()
	ret, specificReturn := fake.rawBuildFileReturnsOnCall[len(fake.rawBuildFileArgsForCall)]
	fake.rawBuildFileArgsForCall = append(fake.rawBuildFileArgsForCall, struct {
		arg1 int32
	}{arg1})
	fake.recordInvocation("RawBuildFile", []interface{}{arg1})
	fake.rawBuildFileMutex.Unlock()
	if fake.RawBuildFileStub != nil {
		return fake.RawBuildFileStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.rawBuildFileReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) RawBuildFileCallCount() int {
	fake.rawBuildFileMutex.RLock()
	defer fake.rawBuildFileMutex.RUnlock()
	return len(fake.rawBuildFileArgsForCall)
}

func (fake *FakeClient) RawBuildFileCalls(stub func(int32) (map[string]interface{}, error)) {
	fake.rawBuildFileMutex.Lock()
	defer fake.rawBuildFileMutex.Unlock()
	fake.RawBuildFileStub = stub
}

func (fake *FakeClient) RawBuildFileArgsForCall(i int) int32 {
	fake.rawBuildFileMutex.RLock()
	defer fake.rawBuildFileMutex.RUnlock()
	argsForCall := fake.rawBuildFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) RawBuildFileReturns(result1 map[string]interface{}, result2 error) {
	fake.rawBuildFileMutex.Lock()
	defer fake.rawBuildFileMutex.Unlock()
	fake.RawBuildFileStub = nil
	fake.rawBuildFileReturns = struct {
		result1 map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RawBuildFileReturnsOnCall(i int, result1 map[string]interface{}, result2 error) {
	fake.rawBuildFileMutex.Lock()
	defer fake.rawBuildFileMutex.Unlock()
	fake.RawBuildFileStub = nil
	if fake.rawBuildFileReturnsOnCall == nil {
		fake.rawBuildFileReturnsOnCall = make(map[int]struct {
			result1 map[string]interface{}
			result2 error
		})
	}
	fake.rawBuildFileReturnsOnCall[i] = struct {
		result1 map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RawSimulation(arg1 int32) (map[string]interface{}, error) {
	fake.rawSimulationMutex.Lock()
	ret, specificReturn := fake.rawSimulationReturnsOnCall[len(fake.rawSimulationArgsForCall)]
	fake.rawSimulationArgsForCall = append(fake.rawSimulationArgsForCall, struct {
		arg1 int32
	}{arg1})
	fake.recordInvocation("RawSimulation", []interface{}{arg1})
	fake.rawSimulationMutex.Unlock()
	if fake.RawSimulationStub != nil {
		return fake.RawSimulationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.rawSimulationReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) RawSimulationCallCount() int {
	fake.rawSimulationMutex.RLock()
	defer fake.rawSimulationMutex.RUnlock()
	return len(fake.rawSimulationArgsForCall)
}

func (fake *FakeClient) RawSimulationCalls(stub func(int32) (map[string]interface{}, error)) {
	fake.rawSimulationMutex.Lock()
	defer fake.rawSimulationMutex.Unlock()
	fake.RawSimulationStub = stub
}

func (fake *FakeClient) RawSimulationArgsForCall(i int) int32 {
	fake.rawSimulationMutex.RLock()
	defer fake.rawSimulationMutex.RUnlock()
	argsForCall := fake.rawSimulationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) RawSimulationReturns(result1 map[string]interface{}, result2 error) {
	fake.rawSimulationMutex.Lock()
	defer fake.rawSimulationMutex.Unlock()
	fake.RawSimulationStub = nil
	fake.rawSimulationReturns = struct {
		result1 map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RawSimulationReturnsOnCall(i int, result1 map[string]interface{}, result2 error) {
	fake.rawSimulationMutex.Lock()
	defer fake.rawSimulationMutex.Unlock()
	fake.RawSimulationStub = nil
	if fake.rawSimulationReturnsOnCall == nil {
		fake.rawSimulationReturnsOnCall = make(map[int]struct {
			result1 map[string]interface{}
			result2 error
		})
	}
	fake.rawSimulationReturnsOnCall[i] = struct {
		result1 map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ScanPatternSimulation(arg1 int32) (*models.ScanPatternSimulation, error) {
	fake.scanPatternSimulationMutex.Lock()
	ret, specificReturn := fake.scanPatternSimulationReturnsOnCall[len(fake.scanPatternSimulationArgsForCall)]
	fake.scanPatternSimulationArgsForCall = append(fake.scanPatternSimulationArgsForCall, struct {
		arg1 int32
	}{arg1})
	fake.recordInvocation("ScanPatternSimulation", []interface{}{arg1})
	fake.scanPatternSimulationMutex.Unlock()
	if fake.ScanPatternSimulationStub != nil {
		return fake.ScanPatternSimulationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.scanPatternSimulationReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ScanPatternSimulationCallCount() int {
	fake.scanPatternSimulationMutex.RLock()
	defer fake.scanPatternSimulationMutex.RUnlock()
	return len(fake.scanPatternSimulationArgsForCall)
}

func (fake *FakeClient) ScanPatternSimulationCalls(stub func(int32) (*models.ScanPatternSimulation, error)) {
	fake.scanPatternSimulationMutex.Lock()
	defer fake.scanPatternSimulationMutex.Unlock()
	fake.ScanPatternSimulationStub = stub
}

func (fake *FakeClient) ScanPatternSimulationArgsForCall(i int) int32 {
	fake.scanPatternSimulationMutex.RLock()
	defer fake.scanPatternSimulationMutex.RUnlock()
	argsForCall := fake.scanPatternSimulationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ScanPatternSimulationReturns(result1 *models.ScanPatternSimulation, result2 error) {
	fake.scanPatternSimulationMutex.Lock()
	defer fake.scanPatternSimulationMutex.Unlock()
	fake.ScanPatternSimulationStub = nil
	fake.scanPatternSimulationReturns = struct {
		result1 *models.ScanPatternSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ScanPatternSimulationReturnsOnCall(i int, result1 *models.ScanPatternSimulation, result2 error) {
	fake.scanPatternSimulationMutex.Lock()
	defer fake.scanPatternSimulationMutex.Unlock()
	fake.ScanPatternSimulationStub = nil
	if fake.scanPatternSimulationReturnsOnCall == nil {
		fake.scanPatternSimulationReturnsOnCall = make(map[int]struct {
			result1 *models.ScanPatternSimulation
			result2 error
		})
	}
	fake.scanPatternSimulationReturnsOnCall[i] = struct {
		result1 *models.ScanPatternSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Simulation(arg1 int32) (*models.Simulation, error) {
	fake.simulationMutex.Lock()
	ret, specificReturn := fake.simulationReturnsOnCall[len(fake.simulationArgsForCall)]
	fake.simulationArgsForCall = append(fake.simulationArgsForCall, struct {
		arg1 int32
	}{arg1})
	fake.recordInvocation("Simulation", []interface{}{arg1})
	fake.simulationMutex.Unlock()
	if fake.SimulationStub != nil {
		return fake.SimulationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.simulationReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) SimulationCallCount() int {
	fake.simulationMutex.RLock()
	defer fake.simulationMutex.RUnlock()
	return len(fake.simulationArgsForCall)
}

func (fake *FakeClient) SimulationCalls(stub func(int32) (*models.Simulation, error)) {
	fake.simulationMutex.Lock()
	defer fake.simulationMutex.Unlock()
	fake.SimulationStub = stub
}

func (fake *FakeClient) SimulationArgsForCall(i int) int32 {
	fake.simulationMutex.RLock()
	defer fake.simulationMutex.RUnlock()
	argsForCall := fake.simulationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) SimulationReturns(result1 *models.Simulation, result2 error) {
	fake.simulationMutex.Lock()
	defer fake.simulationMutex.Unlock()
	fake.SimulationStub = nil
	fake.simulationReturns = struct {
		result1 *models.Simulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SimulationReturnsOnCall(i int, result1 *models.Simulation, result2 error) {
	fake.simulationMutex.Lock()
	defer fake.simulationMutex.Unlock()
	fake.SimulationStub = nil
	if fake.simulationReturnsOnCall == nil {
		fake.simulationReturnsOnCall = make(map[int]struct {
			result1 *models.Simulation
			result2 error
		})
	}
	fake.simulationReturnsOnCall[i] = struct {
		result1 *models.Simulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SimulationActivityByActivityID(arg1 int32, arg2 string) (*models.SimulationActivity, error) {
	fake.simulationActivityByActivityIDMutex.Lock()
	ret, specificReturn := fake.simulationActivityByActivityIDReturnsOnCall[len(fake.simulationActivityByActivityIDArgsForCall)]
	fake.simulationActivityByActivityIDArgsForCall = append(fake.simulationActivityByActivityIDArgsForCall, struct {
		arg1 int32
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("SimulationActivityByActivityID", []interface{}{arg1, arg2})
	fake.simulationActivityByActivityIDMutex.Unlock()
	if fake.SimulationActivityByActivityIDStub != nil {
		return fake.SimulationActivityByActivityIDStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.simulationActivityByActivityIDReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) SimulationActivityByActivityIDCallCount() int {
	fake.simulationActivityByActivityIDMutex.RLock()
	defer fake.simulationActivityByActivityIDMutex.RUnlock()
	return len(fake.simulationActivityByActivityIDArgsForCall)
}

func (fake *FakeClient) SimulationActivityByActivityIDCalls(stub func(int32, string) (*models.SimulationActivity, error)) {
	fake.simulationActivityByActivityIDMutex.Lock()
	defer fake.simulationActivityByActivityIDMutex.Unlock()
	fake.SimulationActivityByActivityIDStub = stub
}

func (fake *FakeClient) SimulationActivityByActivityIDArgsForCall(i int) (int32, string) {
	fake.simulationActivityByActivityIDMutex.RLock()
	defer fake.simulationActivityByActivityIDMutex.RUnlock()
	argsForCall := fake.simulationActivityByActivityIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) SimulationActivityByActivityIDReturns(result1 *models.SimulationActivity, result2 error) {
	fake.simulationActivityByActivityIDMutex.Lock()
	defer fake.simulationActivityByActivityIDMutex.Unlock()
	fake.SimulationActivityByActivityIDStub = nil
	fake.simulationActivityByActivityIDReturns = struct {
		result1 *models.SimulationActivity
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SimulationActivityByActivityIDReturnsOnCall(i int, result1 *models.SimulationActivity, result2 error) {
	fake.simulationActivityByActivityIDMutex.Lock()
	defer fake.simulationActivityByActivityIDMutex.Unlock()
	fake.SimulationActivityByActivityIDStub = nil
	if fake.simulationActivityByActivityIDReturnsOnCall == nil {
		fake.simulationActivityByActivityIDReturnsOnCall = make(map[int]struct {
			result1 *models.SimulationActivity
			result2 error
		})
	}
	fake.simulationActivityByActivityIDReturnsOnCall[i] = struct {
		result1 *models.SimulationActivity
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SimulationChildren(arg1 int32) ([]*models.Simulation, error) {
	fake.simulationChildrenMutex.Lock()
	ret, specificReturn := fake.simulationChildrenReturnsOnCall[len(fake.simulationChildrenArgsForCall)]
	fake.simulationChildrenArgsForCall = append(fake.simulationChildrenArgsForCall, struct {
		arg1 int32
	}{arg1})
	fake.recordInvocation("SimulationChildren", []interface{}{arg1})
	fake.simulationChildrenMutex.Unlock()
	if fake.SimulationChildrenStub != nil {
		return fake.SimulationChildrenStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.simulationChildrenReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) SimulationChildrenCallCount() int {
	fake.simulationChildrenMutex.RLock()
	defer fake.simulationChildrenMutex.RUnlock()
	return len(fake.simulationChildrenArgsForCall)
}

func (fake *FakeClient) SimulationChildrenCalls(stub func(int32) ([]*models.Simulation, error)) {
	fake.simulationChildrenMutex.Lock()
	defer fake.simulationChildrenMutex.Unlock()
	fake.SimulationChildrenStub = stub
}

func (fake *FakeClient) SimulationChildrenArgsForCall(i int) int32 {
	fake.simulationChildrenMutex.RLock()
	defer fake.simulationChildrenMutex.RUnlock()
	argsForCall := fake.simulationChildrenArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) SimulationChildrenReturns(result1 []*models.Simulation, result2 error) {
	fake.simulationChildrenMutex.Lock()
	defer fake.simulationChildrenMutex.Unlock()
	fake.SimulationChildrenStub = nil
	fake.simulationChildrenReturns = struct {
		result1 []*models.Simulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SimulationChildrenReturnsOnCall(i int, result1 []*models.Simulation, result2 error) {
	fake.simulationChildrenMutex.Lock()
	defer fake.simulationChildrenMutex.Unlock()
	fake.SimulationChildrenStub = nil
	if fake.simulationChildrenReturnsOnCall == nil {
		fake.simulationChildrenReturnsOnCall = make(map[int]struct {
			result1 []*models.Simulation
			result2 error
		})
	}
	fake.simulationChildrenReturnsOnCall[i] = struct {
		result1 []*models.Simulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SimulationOutputs(arg1 int32) ([]*models.SimulationOutput, error) {
	fake.simulationOutputsMutex.Lock()
	ret, specificReturn := fake.simulationOutputsReturnsOnCall[len(fake.simulationOutputsArgsForCall)]
	fake.simulationOutputsArgsForCall = append(fake.simulationOutputsArgsForCall, struct {
		arg1 int32
	}{arg1})
	fake.recordInvocation("SimulationOutputs", []interface{}{arg1})
	fake.simulationOutputsMutex.Unlock()
	if fake.SimulationOutputsStub != nil {
		return fake.SimulationOutputsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.simulationOutputsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) SimulationOutputsCallCount() int {
	fake.simulationOutputsMutex.RLock()
	defer fake.simulationOutputsMutex.RUnlock()
	return len(fake.simulationOutputsArgsForCall)
}

func (fake *FakeClient) SimulationOutputsCalls(stub func(int32) ([]*models.SimulationOutput, error)) {
	fake.simulationOutputsMutex.Lock()
	defer fake.simulationOutputsMutex.Unlock()
	fake.SimulationOutputsStub = stub
}

func (fake *FakeClient) SimulationOutputsArgsForCall(i int) int32 {
	fake.simulationOutputsMutex.RLock()
	defer fake.simulationOutputsMutex.RUnlock()
	argsForCall := fake.simulationOutputsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) SimulationOutputsReturns(result1 []*models.SimulationOutput, result2 error) {
	fake.simulationOutputsMutex.Lock()
	defer fake.simulationOutputsMutex.Unlock()
	fake.SimulationOutputsStub = nil
	fake.simulationOutputsReturns = struct {
		result1 []*models.SimulationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SimulationOutputsReturnsOnCall(i int, result1 []*models.SimulationOutput, result2 error) {
	fake.simulationOutputsMutex.Lock()
	defer fake.simulationOutputsMutex.Unlock()
	fake.SimulationOutputsStub = nil
	if fake.simulationOutputsReturnsOnCall == nil {
		fake.simulationOutputsReturnsOnCall = make(map[int]struct {
			result1 []*models.SimulationOutput
			result2 error
		})
	}
	fake.simulationOutputsReturnsOnCall[i] = struct {
		result1 []*models.SimulationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Simulations(arg1 int32, arg2 []string, arg3 []string, arg4 int32, arg5 int32, arg6 *bool, arg7 *bool, arg8 *bool) ([]*models.Simulation, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.simulationsMutex.Lock()
	ret, specificReturn := fake.simulationsReturnsOnCall[len(fake.simulationsArgsForCall)]
	fake.simulationsArgsForCall = append(fake.simulationsArgsForCall, struct {
		arg1 int32
		arg2 []string
		arg3 []string
		arg4 int32
		arg5 int32
		arg6 *bool
		arg7 *bool
		arg8 *bool
	}{arg1, arg2Copy, arg3Copy, arg4, arg5, arg6, arg7, arg8})
	fake.recordInvocation("Simulations", []interface{}{arg1, arg2Copy, arg3Copy, arg4, arg5, arg6, arg7, arg8})
	fake.simulationsMutex.Unlock()
	if fake.SimulationsStub != nil {
		return fake.SimulationsStub(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.simulationsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) SimulationsCallCount() int {
	fake.simulationsMutex.RLock()
	defer fake.simulationsMutex.RUnlock()
	return len(fake.simulationsArgsForCall)
}

func (fake *FakeClient) SimulationsCalls(stub func(int32, []string, []string, int32, int32, *bool, *bool, *bool) ([]*models.Simulation, error)) {
	fake.simulationsMutex.Lock()
	defer fake.simulationsMutex.Unlock()
	fake.SimulationsStub = stub
}

func (fake *FakeClient) SimulationsArgsForCall(i int) (int32, []string, []string, int32, int32, *bool, *bool, *bool) {
	fake.simulationsMutex.RLock()
	defer fake.simulationsMutex.RUnlock()
	argsForCall := fake.simulationsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7, argsForCall.arg8
}

func (fake *FakeClient) SimulationsReturns(result1 []*models.Simulation, result2 error) {
	fake.simulationsMutex.Lock()
	defer fake.simulationsMutex.Unlock()
	fake.SimulationsStub = nil
	fake.simulationsReturns = struct {
		result1 []*models.Simulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SimulationsReturnsOnCall(i int, result1 []*models.Simulation, result2 error) {
	fake.simulationsMutex.Lock()
	defer fake.simulationsMutex.Unlock()
	fake.SimulationsStub = nil
	if fake.simulationsReturnsOnCall == nil {
		fake.simulationsReturnsOnCall = make(map[int]struct {
			result1 []*models.Simulation
			result2 error
		})
	}
	fake.simulationsReturnsOnCall[i] = struct {
		result1 []*models.Simulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SingleBeadSimulation(arg1 int32) (*models.SingleBeadSimulation, error) {
	fake.singleBeadSimulationMutex.Lock()
	ret, specificReturn := fake.singleBeadSimulationReturnsOnCall[len(fake.singleBeadSimulationArgsForCall)]
	fake.singleBeadSimulationArgsForCall = append(fake.singleBeadSimulationArgsForCall, struct {
		arg1 int32
	}{arg1})
	fake.recordInvocation("SingleBeadSimulation", []interface{}{arg1})
	fake.singleBeadSimulationMutex.Unlock()
	if fake.SingleBeadSimulationStub != nil {
		return fake.SingleBeadSimulationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.singleBeadSimulationReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) SingleBeadSimulationCallCount() int {
	fake.singleBeadSimulationMutex.RLock()
	defer fake.singleBeadSimulationMutex.RUnlock()
	return len(fake.singleBeadSimulationArgsForCall)
}

func (fake *FakeClient) SingleBeadSimulationCalls(stub func(int32) (*models.SingleBeadSimulation, error)) {
	fake.singleBeadSimulationMutex.Lock()
	defer fake.singleBeadSimulationMutex.Unlock()
	fake.SingleBeadSimulationStub = stub
}

func (fake *FakeClient) SingleBeadSimulationArgsForCall(i int) int32 {
	fake.singleBeadSimulationMutex.RLock()
	defer fake.singleBeadSimulationMutex.RUnlock()
	argsForCall := fake.singleBeadSimulationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) SingleBeadSimulationReturns(result1 *models.SingleBeadSimulation, result2 error) {
	fake.singleBeadSimulationMutex.Lock()
	defer fake.singleBeadSimulationMutex.Unlock()
	fake.SingleBeadSimulationStub = nil
	fake.singleBeadSimulationReturns = struct {
		result1 *models.SingleBeadSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SingleBeadSimulationReturnsOnCall(i int, result1 *models.SingleBeadSimulation, result2 error) {
	fake.singleBeadSimulationMutex.Lock()
	defer fake.singleBeadSimulationMutex.Unlock()
	fake.SingleBeadSimulationStub = nil
	if fake.singleBeadSimulationReturnsOnCall == nil {
		fake.singleBeadSimulationReturnsOnCall = make(map[int]struct {
			result1 *models.SingleBeadSimulation
			result2 error
		})
	}
	fake.singleBeadSimulationReturnsOnCall[i] = struct {
		result1 *models.SingleBeadSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) StartSimulation(arg1 int32) error {
	fake.startSimulationMutex.Lock()
	ret, specificReturn := fake.startSimulationReturnsOnCall[len(fake.startSimulationArgsForCall)]
	fake.startSimulationArgsForCall = append(fake.startSimulationArgsForCall, struct {
		arg1 int32
	}{arg1})
	fake.recordInvocation("StartSimulation", []interface{}{arg1})
	fake.startSimulationMutex.Unlock()
	if fake.StartSimulationStub != nil {
		return fake.StartSimulationStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.startSimulationReturns
	return fakeReturns.result1
}

func (fake *FakeClient) StartSimulationCallCount() int {
	fake.startSimulationMutex.RLock()
	defer fake.startSimulationMutex.RUnlock()
	return len(fake.startSimulationArgsForCall)
}

func (fake *FakeClient) StartSimulationCalls(stub func(int32) error) {
	fake.startSimulationMutex.Lock()
	defer fake.startSimulationMutex.Unlock()
	fake.StartSimulationStub = stub
}

func (fake *FakeClient) StartSimulationArgsForCall(i int) int32 {
	fake.startSimulationMutex.RLock()
	defer fake.startSimulationMutex.RUnlock()
	argsForCall := fake.startSimulationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) StartSimulationReturns(result1 error) {
	fake.startSimulationMutex.Lock()
	defer fake.startSimulationMutex.Unlock()
	fake.StartSimulationStub = nil
	fake.startSimulationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) StartSimulationReturnsOnCall(i int, result1 error) {
	fake.startSimulationMutex.Lock()
	defer fake.startSimulationMutex.Unlock()
	fake.StartSimulationStub = nil
	if fake.startSimulationReturnsOnCall == nil {
		fake.startSimulationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startSimulationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ThermalSimulation(arg1 int32) (*models.ThermalSimulation, error) {
	fake.thermalSimulationMutex.Lock()
	ret, specificReturn := fake.thermalSimulationReturnsOnCall[len(fake.thermalSimulationArgsForCall)]
	fake.thermalSimulationArgsForCall = append(fake.thermalSimulationArgsForCall, struct {
		arg1 int32
	}{arg1})
	fake.recordInvocation("ThermalSimulation", []interface{}{arg1})
	fake.thermalSimulationMutex.Unlock()
	if fake.ThermalSimulationStub != nil {
		return fake.ThermalSimulationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.thermalSimulationReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ThermalSimulationCallCount() int {
	fake.thermalSimulationMutex.RLock()
	defer fake.thermalSimulationMutex.RUnlock()
	return len(fake.thermalSimulationArgsForCall)
}

func (fake *FakeClient) ThermalSimulationCalls(stub func(int32) (*models.ThermalSimulation, error)) {
	fake.thermalSimulationMutex.Lock()
	defer fake.thermalSimulationMutex.Unlock()
	fake.ThermalSimulationStub = stub
}

func (fake *FakeClient) ThermalSimulationArgsForCall(i int) int32 {
	fake.thermalSimulationMutex.RLock()
	defer fake.thermalSimulationMutex.RUnlock()
	argsForCall := fake.thermalSimulationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ThermalSimulationReturns(result1 *models.ThermalSimulation, result2 error) {
	fake.thermalSimulationMutex.Lock()
	defer fake.thermalSimulationMutex.Unlock()
	fake.ThermalSimulationStub = nil
	fake.thermalSimulationReturns = struct {
		result1 *models.ThermalSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ThermalSimulationReturnsOnCall(i int, result1 *models.ThermalSimulation, result2 error) {
	fake.thermalSimulationMutex.Lock()
	defer fake.thermalSimulationMutex.Unlock()
	fake.ThermalSimulationStub = nil
	if fake.thermalSimulationReturnsOnCall == nil {
		fake.thermalSimulationReturnsOnCall = make(map[int]struct {
			result1 *models.ThermalSimulation
			result2 error
		})
	}
	fake.thermalSimulationReturnsOnCall[i] = struct {
		result1 *models.ThermalSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateBuildFileAvailability(arg1 int32, arg2 string) (*models.BuildFile, error) {
	fake.updateBuildFileAvailabilityMutex.Lock()
	ret, specificReturn := fake.updateBuildFileAvailabilityReturnsOnCall[len(fake.updateBuildFileAvailabilityArgsForCall)]
	fake.updateBuildFileAvailabilityArgsForCall = append(fake.updateBuildFileAvailabilityArgsForCall, struct {
		arg1 int32
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("UpdateBuildFileAvailability", []interface{}{arg1, arg2})
	fake.updateBuildFileAvailabilityMutex.Unlock()
	if fake.UpdateBuildFileAvailabilityStub != nil {
		return fake.UpdateBuildFileAvailabilityStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateBuildFileAvailabilityReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) UpdateBuildFileAvailabilityCallCount() int {
	fake.updateBuildFileAvailabilityMutex.RLock()
	defer fake.updateBuildFileAvailabilityMutex.RUnlock()
	return len(fake.updateBuildFileAvailabilityArgsForCall)
}

func (fake *FakeClient) UpdateBuildFileAvailabilityCalls(stub func(int32, string) (*models.BuildFile, error)) {
	fake.updateBuildFileAvailabilityMutex.Lock()
	defer fake.updateBuildFileAvailabilityMutex.Unlock()
	fake.UpdateBuildFileAvailabilityStub = stub
}

func (fake *FakeClient) UpdateBuildFileAvailabilityArgsForCall(i int) (int32, string) {
	fake.updateBuildFileAvailabilityMutex.RLock()
	defer fake.updateBuildFileAvailabilityMutex.RUnlock()
	argsForCall := fake.updateBuildFileAvailabilityArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) UpdateBuildFileAvailabilityReturns(result1 *models.BuildFile, result2 error) {
	fake.updateBuildFileAvailabilityMutex.Lock()
	defer fake.updateBuildFileAvailabilityMutex.Unlock()
	fake.UpdateBuildFileAvailabilityStub = nil
	fake.updateBuildFileAvailabilityReturns = struct {
		result1 *models.BuildFile
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateBuildFileAvailabilityReturnsOnCall(i int, result1 *models.BuildFile, result2 error) {
	fake.updateBuildFileAvailabilityMutex.Lock()
	defer fake.updateBuildFileAvailabilityMutex.Unlock()
	fake.UpdateBuildFileAvailabilityStub = nil
	if fake.updateBuildFileAvailabilityReturnsOnCall == nil {
		fake.updateBuildFileAvailabilityReturnsOnCall = make(map[int]struct {
			result1 *models.BuildFile
			result2 error
		})
	}
	fake.updateBuildFileAvailabilityReturnsOnCall[i] = struct {
		result1 *models.BuildFile
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdatePartAvailability(arg1 int32, arg2 string) (*models.Part, error) {
	fake.updatePartAvailabilityMutex.Lock()
	ret, specificReturn := fake.updatePartAvailabilityReturnsOnCall[len(fake.updatePartAvailabilityArgsForCall)]
	fake.updatePartAvailabilityArgsForCall = append(fake.updatePartAvailabilityArgsForCall, struct {
		arg1 int32
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("UpdatePartAvailability", []interface{}{arg1, arg2})
	fake.updatePartAvailabilityMutex.Unlock()
	if fake.UpdatePartAvailabilityStub != nil {
		return fake.UpdatePartAvailabilityStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updatePartAvailabilityReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) UpdatePartAvailabilityCallCount() int {
	fake.updatePartAvailabilityMutex.RLock()
	defer fake.updatePartAvailabilityMutex.RUnlock()
	return len(fake.updatePartAvailabilityArgsForCall)
}

func (fake *FakeClient) UpdatePartAvailabilityCalls(stub func(int32, string) (*models.Part, error)) {
	fake.updatePartAvailabilityMutex.Lock()
	defer fake.updatePartAvailabilityMutex.Unlock()
	fake.UpdatePartAvailabilityStub = stub
}

func (fake *FakeClient) UpdatePartAvailabilityArgsForCall(i int) (int32, string) {
	fake.updatePartAvailabilityMutex.RLock()
	defer fake.updatePartAvailabilityMutex.RUnlock()
	argsForCall := fake.updatePartAvailabilityArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) UpdatePartAvailabilityReturns(result1 *models.Part, result2 error) {
	fake.updatePartAvailabilityMutex.Lock()
	defer fake.updatePartAvailabilityMutex.Unlock()
	fake.UpdatePartAvailabilityStub = nil
	fake.updatePartAvailabilityReturns = struct {
		result1 *models.Part
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdatePartAvailabilityReturnsOnCall(i int, result1 *models.Part, result2 error) {
	fake.updatePartAvailabilityMutex.Lock()
	defer fake.updatePartAvailabilityMutex.Unlock()
	fake.UpdatePartAvailabilityStub = nil
	if fake.updatePartAvailabilityReturnsOnCall == nil {
		fake.updatePartAvailabilityReturnsOnCall = make(map[int]struct {
			result1 *models.Part
			result2 error
		})
	}
	fake.updatePartAvailabilityReturnsOnCall[i] = struct {
		result1 *models.Part
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdatePartSupportAvailability(arg1 int32, arg2 string) (*models.PartSupport, error) {
	fake.updatePartSupportAvailabilityMutex.Lock()
	ret, specificReturn := fake.updatePartSupportAvailabilityReturnsOnCall[len(fake.updatePartSupportAvailabilityArgsForCall)]
	fake.updatePartSupportAvailabilityArgsForCall = append(fake.updatePartSupportAvailabilityArgsForCall, struct {
		arg1 int32
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("UpdatePartSupportAvailability", []interface{}{arg1, arg2})
	fake.updatePartSupportAvailabilityMutex.Unlock()
	if fake.UpdatePartSupportAvailabilityStub != nil {
		return fake.UpdatePartSupportAvailabilityStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updatePartSupportAvailabilityReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) UpdatePartSupportAvailabilityCallCount() int {
	fake.updatePartSupportAvailabilityMutex.RLock()
	defer fake.updatePartSupportAvailabilityMutex.RUnlock()
	return len(fake.updatePartSupportAvailabilityArgsForCall)
}

func (fake *FakeClient) UpdatePartSupportAvailabilityCalls(stub func(int32, string) (*models.PartSupport, error)) {
	fake.updatePartSupportAvailabilityMutex.Lock()
	defer fake.updatePartSupportAvailabilityMutex.Unlock()
	fake.UpdatePartSupportAvailabilityStub = stub
}

func (fake *FakeClient) UpdatePartSupportAvailabilityArgsForCall(i int) (int32, string) {
	fake.updatePartSupportAvailabilityMutex.RLock()
	defer fake.updatePartSupportAvailabilityMutex.RUnlock()
	argsForCall := fake.updatePartSupportAvailabilityArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) UpdatePartSupportAvailabilityReturns(result1 *models.PartSupport, result2 error) {
	fake.updatePartSupportAvailabilityMutex.Lock()
	defer fake.updatePartSupportAvailabilityMutex.Unlock()
	fake.UpdatePartSupportAvailabilityStub = nil
	fake.updatePartSupportAvailabilityReturns = struct {
		result1 *models.PartSupport
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdatePartSupportAvailabilityReturnsOnCall(i int, result1 *models.PartSupport, result2 error) {
	fake.updatePartSupportAvailabilityMutex.Lock()
	defer fake.updatePartSupportAvailabilityMutex.Unlock()
	fake.UpdatePartSupportAvailabilityStub = nil
	if fake.updatePartSupportAvailabilityReturnsOnCall == nil {
		fake.updatePartSupportAvailabilityReturnsOnCall = make(map[int]struct {
			result1 *models.PartSupport
			result2 error
		})
	}
	fake.updatePartSupportAvailabilityReturnsOnCall[i] = struct {
		result1 *models.PartSupport
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateSimulationStatus(arg1 int32, arg2 string) error {
	fake.updateSimulationStatusMutex.Lock()
	ret, specificReturn := fake.updateSimulationStatusReturnsOnCall[len(fake.updateSimulationStatusArgsForCall)]
	fake.updateSimulationStatusArgsForCall = append(fake.updateSimulationStatusArgsForCall, struct {
		arg1 int32
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("UpdateSimulationStatus", []interface{}{arg1, arg2})
	fake.updateSimulationStatusMutex.Unlock()
	if fake.UpdateSimulationStatusStub != nil {
		return fake.UpdateSimulationStatusStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateSimulationStatusReturns
	return fakeReturns.result1
}

func (fake *FakeClient) UpdateSimulationStatusCallCount() int {
	fake.updateSimulationStatusMutex.RLock()
	defer fake.updateSimulationStatusMutex.RUnlock()
	return len(fake.updateSimulationStatusArgsForCall)
}

func (fake *FakeClient) UpdateSimulationStatusCalls(stub func(int32, string) error) {
	fake.updateSimulationStatusMutex.Lock()
	defer fake.updateSimulationStatusMutex.Unlock()
	fake.UpdateSimulationStatusStub = stub
}

func (fake *FakeClient) UpdateSimulationStatusArgsForCall(i int) (int32, string) {
	fake.updateSimulationStatusMutex.RLock()
	defer fake.updateSimulationStatusMutex.RUnlock()
	argsForCall := fake.updateSimulationStatusArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) UpdateSimulationStatusReturns(result1 error) {
	fake.updateSimulationStatusMutex.Lock()
	defer fake.updateSimulationStatusMutex.Unlock()
	fake.UpdateSimulationStatusStub = nil
	fake.updateSimulationStatusReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) UpdateSimulationStatusReturnsOnCall(i int, result1 error) {
	fake.updateSimulationStatusMutex.Lock()
	defer fake.updateSimulationStatusMutex.Unlock()
	fake.UpdateSimulationStatusStub = nil
	if fake.updateSimulationStatusReturnsOnCall == nil {
		fake.updateSimulationStatusReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateSimulationStatusReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addSimulationOutputMutex.RLock()
	defer fake.addSimulationOutputMutex.RUnlock()
	fake.assumedStrainSimulationMutex.RLock()
	defer fake.assumedStrainSimulationMutex.RUnlock()
	fake.buildFileMutex.RLock()
	defer fake.buildFileMutex.RUnlock()
	fake.buildFilesMutex.RLock()
	defer fake.buildFilesMutex.RUnlock()
	fake.machineMutex.RLock()
	defer fake.machineMutex.RUnlock()
	fake.materialMutex.RLock()
	defer fake.materialMutex.RUnlock()
	fake.microstructureSimulationMutex.RLock()
	defer fake.microstructureSimulationMutex.RUnlock()
	fake.multiPatchSimulationMutex.RLock()
	defer fake.multiPatchSimulationMutex.RUnlock()
	fake.partMutex.RLock()
	defer fake.partMutex.RUnlock()
	fake.partSupportByIDMutex.RLock()
	defer fake.partSupportByIDMutex.RUnlock()
	fake.patchBuildFileMutex.RLock()
	defer fake.patchBuildFileMutex.RUnlock()
	fake.patchPartMutex.RLock()
	defer fake.patchPartMutex.RUnlock()
	fake.patchPartSupportMutex.RLock()
	defer fake.patchPartSupportMutex.RUnlock()
	fake.patchPartSupportByIDMutex.RLock()
	defer fake.patchPartSupportByIDMutex.RUnlock()
	fake.patchSimulationMutex.RLock()
	defer fake.patchSimulationMutex.RUnlock()
	fake.patchSimulationActivityMutex.RLock()
	defer fake.patchSimulationActivityMutex.RUnlock()
	fake.porositySimulationMutex.RLock()
	defer fake.porositySimulationMutex.RUnlock()
	fake.postAssumedStrainSimulationMutex.RLock()
	defer fake.postAssumedStrainSimulationMutex.RUnlock()
	fake.postBuildFileMutex.RLock()
	defer fake.postBuildFileMutex.RUnlock()
	fake.postLogMutex.RLock()
	defer fake.postLogMutex.RUnlock()
	fake.postLogErrorMutex.RLock()
	defer fake.postLogErrorMutex.RUnlock()
	fake.postLogInfoMutex.RLock()
	defer fake.postLogInfoMutex.RUnlock()
	fake.postLogWarnMutex.RLock()
	defer fake.postLogWarnMutex.RUnlock()
	fake.postLogWithObjectMutex.RLock()
	defer fake.postLogWithObjectMutex.RUnlock()
	fake.postMicrostructureSimulationMutex.RLock()
	defer fake.postMicrostructureSimulationMutex.RUnlock()
	fake.postPorositySimulationMutex.RLock()
	defer fake.postPorositySimulationMutex.RUnlock()
	fake.postScanPatternSimulationMutex.RLock()
	defer fake.postScanPatternSimulationMutex.RUnlock()
	fake.postSimulationActivityMutex.RLock()
	defer fake.postSimulationActivityMutex.RUnlock()
	fake.postSingleBeadSimulationMutex.RLock()
	defer fake.postSingleBeadSimulationMutex.RUnlock()
	fake.postThermalSimulationMutex.RLock()
	defer fake.postThermalSimulationMutex.RUnlock()
	fake.putSimulationActivityMutex.RLock()
	defer fake.putSimulationActivityMutex.RUnlock()
	fake.rawBuildFileMutex.RLock()
	defer fake.rawBuildFileMutex.RUnlock()
	fake.rawSimulationMutex.RLock()
	defer fake.rawSimulationMutex.RUnlock()
	fake.scanPatternSimulationMutex.RLock()
	defer fake.scanPatternSimulationMutex.RUnlock()
	fake.simulationMutex.RLock()
	defer fake.simulationMutex.RUnlock()
	fake.simulationActivityByActivityIDMutex.RLock()
	defer fake.simulationActivityByActivityIDMutex.RUnlock()
	fake.simulationChildrenMutex.RLock()
	defer fake.simulationChildrenMutex.RUnlock()
	fake.simulationOutputsMutex.RLock()
	defer fake.simulationOutputsMutex.RUnlock()
	fake.simulationsMutex.RLock()
	defer fake.simulationsMutex.RUnlock()
	fake.singleBeadSimulationMutex.RLock()
	defer fake.singleBeadSimulationMutex.RUnlock()
	fake.startSimulationMutex.RLock()
	defer fake.startSimulationMutex.RUnlock()
	fake.thermalSimulationMutex.RLock()
	defer fake.thermalSimulationMutex.RUnlock()
	fake.updateBuildFileAvailabilityMutex.RLock()
	defer fake.updateBuildFileAvailabilityMutex.RUnlock()
	fake.updatePartAvailabilityMutex.RLock()
	defer fake.updatePartAvailabilityMutex.RUnlock()
	fake.updatePartSupportAvailabilityMutex.RLock()
	defer fake.updatePartSupportAvailabilityMutex.RUnlock()
	fake.updateSimulationStatusMutex.RLock()
	defer fake.updateSimulationStatusMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ simulation.Client = new(FakeClient)
