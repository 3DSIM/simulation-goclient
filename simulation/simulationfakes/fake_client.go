// This file was generated by counterfeiter
package simulationfakes

import (
	"sync"

	"github.com/3dsim/simulation-goclient/models"
	"github.com/3dsim/simulation-goclient/simulation"
)

type FakeClient struct {
	SimulationsStub        func(organizationID int32, status []string, sort []string, offset, limit int32, archived, isParent, requiresLicense *bool) ([]*models.Simulation, error)
	simulationsMutex       sync.RWMutex
	simulationsArgsForCall []struct {
		organizationID  int32
		status          []string
		sort            []string
		offset          int32
		limit           int32
		archived        *bool
		isParent        *bool
		requiresLicense *bool
	}
	simulationsReturns struct {
		result1 []*models.Simulation
		result2 error
	}
	simulationsReturnsOnCall map[int]struct {
		result1 []*models.Simulation
		result2 error
	}
	StartSimulationStub        func(simulationID int32) error
	startSimulationMutex       sync.RWMutex
	startSimulationArgsForCall []struct {
		simulationID int32
	}
	startSimulationReturns struct {
		result1 error
	}
	startSimulationReturnsOnCall map[int]struct {
		result1 error
	}
	ThermalSimulationStub        func(simulationID int32) (*models.ThermalSimulation, error)
	thermalSimulationMutex       sync.RWMutex
	thermalSimulationArgsForCall []struct {
		simulationID int32
	}
	thermalSimulationReturns struct {
		result1 *models.ThermalSimulation
		result2 error
	}
	thermalSimulationReturnsOnCall map[int]struct {
		result1 *models.ThermalSimulation
		result2 error
	}
	SingleBeadSimulationStub        func(simulationID int32) (*models.SingleBeadSimulation, error)
	singleBeadSimulationMutex       sync.RWMutex
	singleBeadSimulationArgsForCall []struct {
		simulationID int32
	}
	singleBeadSimulationReturns struct {
		result1 *models.SingleBeadSimulation
		result2 error
	}
	singleBeadSimulationReturnsOnCall map[int]struct {
		result1 *models.SingleBeadSimulation
		result2 error
	}
	PostAssumedStrainSimulationStub        func(*models.AssumedStrainSimulation) (*models.AssumedStrainSimulation, error)
	postAssumedStrainSimulationMutex       sync.RWMutex
	postAssumedStrainSimulationArgsForCall []struct {
		arg1 *models.AssumedStrainSimulation
	}
	postAssumedStrainSimulationReturns struct {
		result1 *models.AssumedStrainSimulation
		result2 error
	}
	postAssumedStrainSimulationReturnsOnCall map[int]struct {
		result1 *models.AssumedStrainSimulation
		result2 error
	}
	PostPorositySimulationStub        func(*models.PorositySimulation) (*models.PorositySimulation, error)
	postPorositySimulationMutex       sync.RWMutex
	postPorositySimulationArgsForCall []struct {
		arg1 *models.PorositySimulation
	}
	postPorositySimulationReturns struct {
		result1 *models.PorositySimulation
		result2 error
	}
	postPorositySimulationReturnsOnCall map[int]struct {
		result1 *models.PorositySimulation
		result2 error
	}
	PostScanPatternSimulationStub        func(*models.ScanPatternSimulation) (*models.ScanPatternSimulation, error)
	postScanPatternSimulationMutex       sync.RWMutex
	postScanPatternSimulationArgsForCall []struct {
		arg1 *models.ScanPatternSimulation
	}
	postScanPatternSimulationReturns struct {
		result1 *models.ScanPatternSimulation
		result2 error
	}
	postScanPatternSimulationReturnsOnCall map[int]struct {
		result1 *models.ScanPatternSimulation
		result2 error
	}
	PostSingleBeadSimulationStub        func(*models.SingleBeadSimulation) (*models.SingleBeadSimulation, error)
	postSingleBeadSimulationMutex       sync.RWMutex
	postSingleBeadSimulationArgsForCall []struct {
		arg1 *models.SingleBeadSimulation
	}
	postSingleBeadSimulationReturns struct {
		result1 *models.SingleBeadSimulation
		result2 error
	}
	postSingleBeadSimulationReturnsOnCall map[int]struct {
		result1 *models.SingleBeadSimulation
		result2 error
	}
	PostThermalSimulationStub        func(*models.ThermalSimulation) (*models.ThermalSimulation, error)
	postThermalSimulationMutex       sync.RWMutex
	postThermalSimulationArgsForCall []struct {
		arg1 *models.ThermalSimulation
	}
	postThermalSimulationReturns struct {
		result1 *models.ThermalSimulation
		result2 error
	}
	postThermalSimulationReturnsOnCall map[int]struct {
		result1 *models.ThermalSimulation
		result2 error
	}
	MachineStub        func(machineID int32) (*models.Machine, error)
	machineMutex       sync.RWMutex
	machineArgsForCall []struct {
		machineID int32
	}
	machineReturns struct {
		result1 *models.Machine
		result2 error
	}
	machineReturnsOnCall map[int]struct {
		result1 *models.Machine
		result2 error
	}
	MaterialStub        func(materialID int32) (*models.Material, error)
	materialMutex       sync.RWMutex
	materialArgsForCall []struct {
		materialID int32
	}
	materialReturns struct {
		result1 *models.Material
		result2 error
	}
	materialReturnsOnCall map[int]struct {
		result1 *models.Material
		result2 error
	}
	SimulationStub        func(simulationID int32) (*models.Simulation, error)
	simulationMutex       sync.RWMutex
	simulationArgsForCall []struct {
		simulationID int32
	}
	simulationReturns struct {
		result1 *models.Simulation
		result2 error
	}
	simulationReturnsOnCall map[int]struct {
		result1 *models.Simulation
		result2 error
	}
	ScanPatternSimulationStub        func(simulationID int32) (*models.ScanPatternSimulation, error)
	scanPatternSimulationMutex       sync.RWMutex
	scanPatternSimulationArgsForCall []struct {
		simulationID int32
	}
	scanPatternSimulationReturns struct {
		result1 *models.ScanPatternSimulation
		result2 error
	}
	scanPatternSimulationReturnsOnCall map[int]struct {
		result1 *models.ScanPatternSimulation
		result2 error
	}
	AssumedStrainSimulationStub        func(simulationID int32) (*models.AssumedStrainSimulation, error)
	assumedStrainSimulationMutex       sync.RWMutex
	assumedStrainSimulationArgsForCall []struct {
		simulationID int32
	}
	assumedStrainSimulationReturns struct {
		result1 *models.AssumedStrainSimulation
		result2 error
	}
	assumedStrainSimulationReturnsOnCall map[int]struct {
		result1 *models.AssumedStrainSimulation
		result2 error
	}
	PorositySimulationStub        func(simulationID int32) (*models.PorositySimulation, error)
	porositySimulationMutex       sync.RWMutex
	porositySimulationArgsForCall []struct {
		simulationID int32
	}
	porositySimulationReturns struct {
		result1 *models.PorositySimulation
		result2 error
	}
	porositySimulationReturnsOnCall map[int]struct {
		result1 *models.PorositySimulation
		result2 error
	}
	PostLogStub        func(level string, message string, simulationID int32, activityID string) (err error)
	postLogMutex       sync.RWMutex
	postLogArgsForCall []struct {
		level        string
		message      string
		simulationID int32
		activityID   string
	}
	postLogReturns struct {
		result1 error
	}
	postLogReturnsOnCall map[int]struct {
		result1 error
	}
	PostLogWithObjectStub        func(simulationLog models.SimulationLog) (err error)
	postLogWithObjectMutex       sync.RWMutex
	postLogWithObjectArgsForCall []struct {
		simulationLog models.SimulationLog
	}
	postLogWithObjectReturns struct {
		result1 error
	}
	postLogWithObjectReturnsOnCall map[int]struct {
		result1 error
	}
	PostLogInfoStub        func(message string, simulationID int32, activityID string) (err error)
	postLogInfoMutex       sync.RWMutex
	postLogInfoArgsForCall []struct {
		message      string
		simulationID int32
		activityID   string
	}
	postLogInfoReturns struct {
		result1 error
	}
	postLogInfoReturnsOnCall map[int]struct {
		result1 error
	}
	PostLogWarnStub        func(message string, simulationID int32, activityID string) (err error)
	postLogWarnMutex       sync.RWMutex
	postLogWarnArgsForCall []struct {
		message      string
		simulationID int32
		activityID   string
	}
	postLogWarnReturns struct {
		result1 error
	}
	postLogWarnReturnsOnCall map[int]struct {
		result1 error
	}
	PostLogErrorStub        func(message string, simulationID int32, activityID string) (err error)
	postLogErrorMutex       sync.RWMutex
	postLogErrorArgsForCall []struct {
		message      string
		simulationID int32
		activityID   string
	}
	postLogErrorReturns struct {
		result1 error
	}
	postLogErrorReturnsOnCall map[int]struct {
		result1 error
	}
	PatchSimulationStub        func(simulationID int32, patch *models.PatchDocument) error
	patchSimulationMutex       sync.RWMutex
	patchSimulationArgsForCall []struct {
		simulationID int32
		patch        *models.PatchDocument
	}
	patchSimulationReturns struct {
		result1 error
	}
	patchSimulationReturnsOnCall map[int]struct {
		result1 error
	}
	MultiPatchSimulationStub        func(simulationID int32, patches []*models.PatchDocument) error
	multiPatchSimulationMutex       sync.RWMutex
	multiPatchSimulationArgsForCall []struct {
		simulationID int32
		patches      []*models.PatchDocument
	}
	multiPatchSimulationReturns struct {
		result1 error
	}
	multiPatchSimulationReturnsOnCall map[int]struct {
		result1 error
	}
	PostSimulationActivityStub        func(simulationID int32, simulationActivity *models.SimulationActivity) (*models.SimulationActivity, error)
	postSimulationActivityMutex       sync.RWMutex
	postSimulationActivityArgsForCall []struct {
		simulationID       int32
		simulationActivity *models.SimulationActivity
	}
	postSimulationActivityReturns struct {
		result1 *models.SimulationActivity
		result2 error
	}
	postSimulationActivityReturnsOnCall map[int]struct {
		result1 *models.SimulationActivity
		result2 error
	}
	SimulationActivityByActivityIDStub        func(simulationID int32, activityID string) (*models.SimulationActivity, error)
	simulationActivityByActivityIDMutex       sync.RWMutex
	simulationActivityByActivityIDArgsForCall []struct {
		simulationID int32
		activityID   string
	}
	simulationActivityByActivityIDReturns struct {
		result1 *models.SimulationActivity
		result2 error
	}
	simulationActivityByActivityIDReturnsOnCall map[int]struct {
		result1 *models.SimulationActivity
		result2 error
	}
	PutSimulationActivityStub        func(simulationID int32, simulationActivity *models.SimulationActivity) error
	putSimulationActivityMutex       sync.RWMutex
	putSimulationActivityArgsForCall []struct {
		simulationID       int32
		simulationActivity *models.SimulationActivity
	}
	putSimulationActivityReturns struct {
		result1 error
	}
	putSimulationActivityReturnsOnCall map[int]struct {
		result1 error
	}
	PatchSimulationActivityStub        func(simulationID int32, activityID string, patches []*models.PatchDocument) (*models.SimulationActivity, error)
	patchSimulationActivityMutex       sync.RWMutex
	patchSimulationActivityArgsForCall []struct {
		simulationID int32
		activityID   string
		patches      []*models.PatchDocument
	}
	patchSimulationActivityReturns struct {
		result1 *models.SimulationActivity
		result2 error
	}
	patchSimulationActivityReturnsOnCall map[int]struct {
		result1 *models.SimulationActivity
		result2 error
	}
	AddSimulationOutputStub        func(simulationID int32, outputType, outputFileLocation string) (*models.SimulationOutput, error)
	addSimulationOutputMutex       sync.RWMutex
	addSimulationOutputArgsForCall []struct {
		simulationID       int32
		outputType         string
		outputFileLocation string
	}
	addSimulationOutputReturns struct {
		result1 *models.SimulationOutput
		result2 error
	}
	addSimulationOutputReturnsOnCall map[int]struct {
		result1 *models.SimulationOutput
		result2 error
	}
	UpdateSimulationStatusStub        func(simulationID int32, status string) error
	updateSimulationStatusMutex       sync.RWMutex
	updateSimulationStatusArgsForCall []struct {
		simulationID int32
		status       string
	}
	updateSimulationStatusReturns struct {
		result1 error
	}
	updateSimulationStatusReturnsOnCall map[int]struct {
		result1 error
	}
	RawSimulationStub        func(simulationID int32) (map[string]interface{}, error)
	rawSimulationMutex       sync.RWMutex
	rawSimulationArgsForCall []struct {
		simulationID int32
	}
	rawSimulationReturns struct {
		result1 map[string]interface{}
		result2 error
	}
	rawSimulationReturnsOnCall map[int]struct {
		result1 map[string]interface{}
		result2 error
	}
	BuildFilesStub        func(organizationID int32, availability []string, sort []string, offset, limit int32) ([]*models.BuildFile, error)
	buildFilesMutex       sync.RWMutex
	buildFilesArgsForCall []struct {
		organizationID int32
		availability   []string
		sort           []string
		offset         int32
		limit          int32
	}
	buildFilesReturns struct {
		result1 []*models.BuildFile
		result2 error
	}
	buildFilesReturnsOnCall map[int]struct {
		result1 []*models.BuildFile
		result2 error
	}
	BuildFileStub        func(buildFileID int32) (*models.BuildFile, error)
	buildFileMutex       sync.RWMutex
	buildFileArgsForCall []struct {
		buildFileID int32
	}
	buildFileReturns struct {
		result1 *models.BuildFile
		result2 error
	}
	buildFileReturnsOnCall map[int]struct {
		result1 *models.BuildFile
		result2 error
	}
	PostBuildFileStub        func(*models.BuildFilePost) (*models.BuildFile, error)
	postBuildFileMutex       sync.RWMutex
	postBuildFileArgsForCall []struct {
		arg1 *models.BuildFilePost
	}
	postBuildFileReturns struct {
		result1 *models.BuildFile
		result2 error
	}
	postBuildFileReturnsOnCall map[int]struct {
		result1 *models.BuildFile
		result2 error
	}
	PatchBuildFileStub        func(buildFileID int32, patches []*models.PatchDocument) (*models.BuildFile, error)
	patchBuildFileMutex       sync.RWMutex
	patchBuildFileArgsForCall []struct {
		buildFileID int32
		patches     []*models.PatchDocument
	}
	patchBuildFileReturns struct {
		result1 *models.BuildFile
		result2 error
	}
	patchBuildFileReturnsOnCall map[int]struct {
		result1 *models.BuildFile
		result2 error
	}
	UpdateBuildFileAvailabilityStub        func(buildFileID int32, availability string) (*models.BuildFile, error)
	updateBuildFileAvailabilityMutex       sync.RWMutex
	updateBuildFileAvailabilityArgsForCall []struct {
		buildFileID  int32
		availability string
	}
	updateBuildFileAvailabilityReturns struct {
		result1 *models.BuildFile
		result2 error
	}
	updateBuildFileAvailabilityReturnsOnCall map[int]struct {
		result1 *models.BuildFile
		result2 error
	}
	RawBuildFileStub        func(buildFileID int32) (map[string]interface{}, error)
	rawBuildFileMutex       sync.RWMutex
	rawBuildFileArgsForCall []struct {
		buildFileID int32
	}
	rawBuildFileReturns struct {
		result1 map[string]interface{}
		result2 error
	}
	rawBuildFileReturnsOnCall map[int]struct {
		result1 map[string]interface{}
		result2 error
	}
	PartStub        func(partID int32) (*models.Part, error)
	partMutex       sync.RWMutex
	partArgsForCall []struct {
		partID int32
	}
	partReturns struct {
		result1 *models.Part
		result2 error
	}
	partReturnsOnCall map[int]struct {
		result1 *models.Part
		result2 error
	}
	UpdatePartAvailabilityStub        func(partID int32, availability string) (*models.Part, error)
	updatePartAvailabilityMutex       sync.RWMutex
	updatePartAvailabilityArgsForCall []struct {
		partID       int32
		availability string
	}
	updatePartAvailabilityReturns struct {
		result1 *models.Part
		result2 error
	}
	updatePartAvailabilityReturnsOnCall map[int]struct {
		result1 *models.Part
		result2 error
	}
	PatchPartStub        func(partID int32, patches []*models.PatchDocument) (*models.Part, error)
	patchPartMutex       sync.RWMutex
	patchPartArgsForCall []struct {
		partID  int32
		patches []*models.PatchDocument
	}
	patchPartReturns struct {
		result1 *models.Part
		result2 error
	}
	patchPartReturnsOnCall map[int]struct {
		result1 *models.Part
		result2 error
	}
	SimulationOutputsStub        func(simulationID int32) (so []*models.SimulationOutput, err error)
	simulationOutputsMutex       sync.RWMutex
	simulationOutputsArgsForCall []struct {
		simulationID int32
	}
	simulationOutputsReturns struct {
		result1 []*models.SimulationOutput
		result2 error
	}
	simulationOutputsReturnsOnCall map[int]struct {
		result1 []*models.SimulationOutput
		result2 error
	}
	SimulationChildrenStub        func(simulationID int32) (simulation []*models.Simulation, err error)
	simulationChildrenMutex       sync.RWMutex
	simulationChildrenArgsForCall []struct {
		simulationID int32
	}
	simulationChildrenReturns struct {
		result1 []*models.Simulation
		result2 error
	}
	simulationChildrenReturnsOnCall map[int]struct {
		result1 []*models.Simulation
		result2 error
	}
	PartSupportByIDStub        func(supportID int32) (*models.PartSupport, error)
	partSupportByIDMutex       sync.RWMutex
	partSupportByIDArgsForCall []struct {
		supportID int32
	}
	partSupportByIDReturns struct {
		result1 *models.PartSupport
		result2 error
	}
	partSupportByIDReturnsOnCall map[int]struct {
		result1 *models.PartSupport
		result2 error
	}
	PatchPartSupportStub        func(partID, supportID int32, patches []*models.PatchDocument) (*models.PartSupport, error)
	patchPartSupportMutex       sync.RWMutex
	patchPartSupportArgsForCall []struct {
		partID    int32
		supportID int32
		patches   []*models.PatchDocument
	}
	patchPartSupportReturns struct {
		result1 *models.PartSupport
		result2 error
	}
	patchPartSupportReturnsOnCall map[int]struct {
		result1 *models.PartSupport
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) Simulations(organizationID int32, status []string, sort []string, offset int32, limit int32, archived *bool, isParent *bool, requiresLicense *bool) ([]*models.Simulation, error) {
	var statusCopy []string
	if status != nil {
		statusCopy = make([]string, len(status))
		copy(statusCopy, status)
	}
	var sortCopy []string
	if sort != nil {
		sortCopy = make([]string, len(sort))
		copy(sortCopy, sort)
	}
	fake.simulationsMutex.Lock()
	ret, specificReturn := fake.simulationsReturnsOnCall[len(fake.simulationsArgsForCall)]
	fake.simulationsArgsForCall = append(fake.simulationsArgsForCall, struct {
		organizationID  int32
		status          []string
		sort            []string
		offset          int32
		limit           int32
		archived        *bool
		isParent        *bool
		requiresLicense *bool
	}{organizationID, statusCopy, sortCopy, offset, limit, archived, isParent, requiresLicense})
	fake.recordInvocation("Simulations", []interface{}{organizationID, statusCopy, sortCopy, offset, limit, archived, isParent, requiresLicense})
	fake.simulationsMutex.Unlock()
	if fake.SimulationsStub != nil {
		return fake.SimulationsStub(organizationID, status, sort, offset, limit, archived, isParent, requiresLicense)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.simulationsReturns.result1, fake.simulationsReturns.result2
}

func (fake *FakeClient) SimulationsCallCount() int {
	fake.simulationsMutex.RLock()
	defer fake.simulationsMutex.RUnlock()
	return len(fake.simulationsArgsForCall)
}

func (fake *FakeClient) SimulationsArgsForCall(i int) (int32, []string, []string, int32, int32, *bool, *bool, *bool) {
	fake.simulationsMutex.RLock()
	defer fake.simulationsMutex.RUnlock()
	return fake.simulationsArgsForCall[i].organizationID, fake.simulationsArgsForCall[i].status, fake.simulationsArgsForCall[i].sort, fake.simulationsArgsForCall[i].offset, fake.simulationsArgsForCall[i].limit, fake.simulationsArgsForCall[i].archived, fake.simulationsArgsForCall[i].isParent, fake.simulationsArgsForCall[i].requiresLicense
}

func (fake *FakeClient) SimulationsReturns(result1 []*models.Simulation, result2 error) {
	fake.SimulationsStub = nil
	fake.simulationsReturns = struct {
		result1 []*models.Simulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SimulationsReturnsOnCall(i int, result1 []*models.Simulation, result2 error) {
	fake.SimulationsStub = nil
	if fake.simulationsReturnsOnCall == nil {
		fake.simulationsReturnsOnCall = make(map[int]struct {
			result1 []*models.Simulation
			result2 error
		})
	}
	fake.simulationsReturnsOnCall[i] = struct {
		result1 []*models.Simulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) StartSimulation(simulationID int32) error {
	fake.startSimulationMutex.Lock()
	ret, specificReturn := fake.startSimulationReturnsOnCall[len(fake.startSimulationArgsForCall)]
	fake.startSimulationArgsForCall = append(fake.startSimulationArgsForCall, struct {
		simulationID int32
	}{simulationID})
	fake.recordInvocation("StartSimulation", []interface{}{simulationID})
	fake.startSimulationMutex.Unlock()
	if fake.StartSimulationStub != nil {
		return fake.StartSimulationStub(simulationID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.startSimulationReturns.result1
}

func (fake *FakeClient) StartSimulationCallCount() int {
	fake.startSimulationMutex.RLock()
	defer fake.startSimulationMutex.RUnlock()
	return len(fake.startSimulationArgsForCall)
}

func (fake *FakeClient) StartSimulationArgsForCall(i int) int32 {
	fake.startSimulationMutex.RLock()
	defer fake.startSimulationMutex.RUnlock()
	return fake.startSimulationArgsForCall[i].simulationID
}

func (fake *FakeClient) StartSimulationReturns(result1 error) {
	fake.StartSimulationStub = nil
	fake.startSimulationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) StartSimulationReturnsOnCall(i int, result1 error) {
	fake.StartSimulationStub = nil
	if fake.startSimulationReturnsOnCall == nil {
		fake.startSimulationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startSimulationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ThermalSimulation(simulationID int32) (*models.ThermalSimulation, error) {
	fake.thermalSimulationMutex.Lock()
	ret, specificReturn := fake.thermalSimulationReturnsOnCall[len(fake.thermalSimulationArgsForCall)]
	fake.thermalSimulationArgsForCall = append(fake.thermalSimulationArgsForCall, struct {
		simulationID int32
	}{simulationID})
	fake.recordInvocation("ThermalSimulation", []interface{}{simulationID})
	fake.thermalSimulationMutex.Unlock()
	if fake.ThermalSimulationStub != nil {
		return fake.ThermalSimulationStub(simulationID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.thermalSimulationReturns.result1, fake.thermalSimulationReturns.result2
}

func (fake *FakeClient) ThermalSimulationCallCount() int {
	fake.thermalSimulationMutex.RLock()
	defer fake.thermalSimulationMutex.RUnlock()
	return len(fake.thermalSimulationArgsForCall)
}

func (fake *FakeClient) ThermalSimulationArgsForCall(i int) int32 {
	fake.thermalSimulationMutex.RLock()
	defer fake.thermalSimulationMutex.RUnlock()
	return fake.thermalSimulationArgsForCall[i].simulationID
}

func (fake *FakeClient) ThermalSimulationReturns(result1 *models.ThermalSimulation, result2 error) {
	fake.ThermalSimulationStub = nil
	fake.thermalSimulationReturns = struct {
		result1 *models.ThermalSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ThermalSimulationReturnsOnCall(i int, result1 *models.ThermalSimulation, result2 error) {
	fake.ThermalSimulationStub = nil
	if fake.thermalSimulationReturnsOnCall == nil {
		fake.thermalSimulationReturnsOnCall = make(map[int]struct {
			result1 *models.ThermalSimulation
			result2 error
		})
	}
	fake.thermalSimulationReturnsOnCall[i] = struct {
		result1 *models.ThermalSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SingleBeadSimulation(simulationID int32) (*models.SingleBeadSimulation, error) {
	fake.singleBeadSimulationMutex.Lock()
	ret, specificReturn := fake.singleBeadSimulationReturnsOnCall[len(fake.singleBeadSimulationArgsForCall)]
	fake.singleBeadSimulationArgsForCall = append(fake.singleBeadSimulationArgsForCall, struct {
		simulationID int32
	}{simulationID})
	fake.recordInvocation("SingleBeadSimulation", []interface{}{simulationID})
	fake.singleBeadSimulationMutex.Unlock()
	if fake.SingleBeadSimulationStub != nil {
		return fake.SingleBeadSimulationStub(simulationID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.singleBeadSimulationReturns.result1, fake.singleBeadSimulationReturns.result2
}

func (fake *FakeClient) SingleBeadSimulationCallCount() int {
	fake.singleBeadSimulationMutex.RLock()
	defer fake.singleBeadSimulationMutex.RUnlock()
	return len(fake.singleBeadSimulationArgsForCall)
}

func (fake *FakeClient) SingleBeadSimulationArgsForCall(i int) int32 {
	fake.singleBeadSimulationMutex.RLock()
	defer fake.singleBeadSimulationMutex.RUnlock()
	return fake.singleBeadSimulationArgsForCall[i].simulationID
}

func (fake *FakeClient) SingleBeadSimulationReturns(result1 *models.SingleBeadSimulation, result2 error) {
	fake.SingleBeadSimulationStub = nil
	fake.singleBeadSimulationReturns = struct {
		result1 *models.SingleBeadSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SingleBeadSimulationReturnsOnCall(i int, result1 *models.SingleBeadSimulation, result2 error) {
	fake.SingleBeadSimulationStub = nil
	if fake.singleBeadSimulationReturnsOnCall == nil {
		fake.singleBeadSimulationReturnsOnCall = make(map[int]struct {
			result1 *models.SingleBeadSimulation
			result2 error
		})
	}
	fake.singleBeadSimulationReturnsOnCall[i] = struct {
		result1 *models.SingleBeadSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostAssumedStrainSimulation(arg1 *models.AssumedStrainSimulation) (*models.AssumedStrainSimulation, error) {
	fake.postAssumedStrainSimulationMutex.Lock()
	ret, specificReturn := fake.postAssumedStrainSimulationReturnsOnCall[len(fake.postAssumedStrainSimulationArgsForCall)]
	fake.postAssumedStrainSimulationArgsForCall = append(fake.postAssumedStrainSimulationArgsForCall, struct {
		arg1 *models.AssumedStrainSimulation
	}{arg1})
	fake.recordInvocation("PostAssumedStrainSimulation", []interface{}{arg1})
	fake.postAssumedStrainSimulationMutex.Unlock()
	if fake.PostAssumedStrainSimulationStub != nil {
		return fake.PostAssumedStrainSimulationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.postAssumedStrainSimulationReturns.result1, fake.postAssumedStrainSimulationReturns.result2
}

func (fake *FakeClient) PostAssumedStrainSimulationCallCount() int {
	fake.postAssumedStrainSimulationMutex.RLock()
	defer fake.postAssumedStrainSimulationMutex.RUnlock()
	return len(fake.postAssumedStrainSimulationArgsForCall)
}

func (fake *FakeClient) PostAssumedStrainSimulationArgsForCall(i int) *models.AssumedStrainSimulation {
	fake.postAssumedStrainSimulationMutex.RLock()
	defer fake.postAssumedStrainSimulationMutex.RUnlock()
	return fake.postAssumedStrainSimulationArgsForCall[i].arg1
}

func (fake *FakeClient) PostAssumedStrainSimulationReturns(result1 *models.AssumedStrainSimulation, result2 error) {
	fake.PostAssumedStrainSimulationStub = nil
	fake.postAssumedStrainSimulationReturns = struct {
		result1 *models.AssumedStrainSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostAssumedStrainSimulationReturnsOnCall(i int, result1 *models.AssumedStrainSimulation, result2 error) {
	fake.PostAssumedStrainSimulationStub = nil
	if fake.postAssumedStrainSimulationReturnsOnCall == nil {
		fake.postAssumedStrainSimulationReturnsOnCall = make(map[int]struct {
			result1 *models.AssumedStrainSimulation
			result2 error
		})
	}
	fake.postAssumedStrainSimulationReturnsOnCall[i] = struct {
		result1 *models.AssumedStrainSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostPorositySimulation(arg1 *models.PorositySimulation) (*models.PorositySimulation, error) {
	fake.postPorositySimulationMutex.Lock()
	ret, specificReturn := fake.postPorositySimulationReturnsOnCall[len(fake.postPorositySimulationArgsForCall)]
	fake.postPorositySimulationArgsForCall = append(fake.postPorositySimulationArgsForCall, struct {
		arg1 *models.PorositySimulation
	}{arg1})
	fake.recordInvocation("PostPorositySimulation", []interface{}{arg1})
	fake.postPorositySimulationMutex.Unlock()
	if fake.PostPorositySimulationStub != nil {
		return fake.PostPorositySimulationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.postPorositySimulationReturns.result1, fake.postPorositySimulationReturns.result2
}

func (fake *FakeClient) PostPorositySimulationCallCount() int {
	fake.postPorositySimulationMutex.RLock()
	defer fake.postPorositySimulationMutex.RUnlock()
	return len(fake.postPorositySimulationArgsForCall)
}

func (fake *FakeClient) PostPorositySimulationArgsForCall(i int) *models.PorositySimulation {
	fake.postPorositySimulationMutex.RLock()
	defer fake.postPorositySimulationMutex.RUnlock()
	return fake.postPorositySimulationArgsForCall[i].arg1
}

func (fake *FakeClient) PostPorositySimulationReturns(result1 *models.PorositySimulation, result2 error) {
	fake.PostPorositySimulationStub = nil
	fake.postPorositySimulationReturns = struct {
		result1 *models.PorositySimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostPorositySimulationReturnsOnCall(i int, result1 *models.PorositySimulation, result2 error) {
	fake.PostPorositySimulationStub = nil
	if fake.postPorositySimulationReturnsOnCall == nil {
		fake.postPorositySimulationReturnsOnCall = make(map[int]struct {
			result1 *models.PorositySimulation
			result2 error
		})
	}
	fake.postPorositySimulationReturnsOnCall[i] = struct {
		result1 *models.PorositySimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostScanPatternSimulation(arg1 *models.ScanPatternSimulation) (*models.ScanPatternSimulation, error) {
	fake.postScanPatternSimulationMutex.Lock()
	ret, specificReturn := fake.postScanPatternSimulationReturnsOnCall[len(fake.postScanPatternSimulationArgsForCall)]
	fake.postScanPatternSimulationArgsForCall = append(fake.postScanPatternSimulationArgsForCall, struct {
		arg1 *models.ScanPatternSimulation
	}{arg1})
	fake.recordInvocation("PostScanPatternSimulation", []interface{}{arg1})
	fake.postScanPatternSimulationMutex.Unlock()
	if fake.PostScanPatternSimulationStub != nil {
		return fake.PostScanPatternSimulationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.postScanPatternSimulationReturns.result1, fake.postScanPatternSimulationReturns.result2
}

func (fake *FakeClient) PostScanPatternSimulationCallCount() int {
	fake.postScanPatternSimulationMutex.RLock()
	defer fake.postScanPatternSimulationMutex.RUnlock()
	return len(fake.postScanPatternSimulationArgsForCall)
}

func (fake *FakeClient) PostScanPatternSimulationArgsForCall(i int) *models.ScanPatternSimulation {
	fake.postScanPatternSimulationMutex.RLock()
	defer fake.postScanPatternSimulationMutex.RUnlock()
	return fake.postScanPatternSimulationArgsForCall[i].arg1
}

func (fake *FakeClient) PostScanPatternSimulationReturns(result1 *models.ScanPatternSimulation, result2 error) {
	fake.PostScanPatternSimulationStub = nil
	fake.postScanPatternSimulationReturns = struct {
		result1 *models.ScanPatternSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostScanPatternSimulationReturnsOnCall(i int, result1 *models.ScanPatternSimulation, result2 error) {
	fake.PostScanPatternSimulationStub = nil
	if fake.postScanPatternSimulationReturnsOnCall == nil {
		fake.postScanPatternSimulationReturnsOnCall = make(map[int]struct {
			result1 *models.ScanPatternSimulation
			result2 error
		})
	}
	fake.postScanPatternSimulationReturnsOnCall[i] = struct {
		result1 *models.ScanPatternSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostSingleBeadSimulation(arg1 *models.SingleBeadSimulation) (*models.SingleBeadSimulation, error) {
	fake.postSingleBeadSimulationMutex.Lock()
	ret, specificReturn := fake.postSingleBeadSimulationReturnsOnCall[len(fake.postSingleBeadSimulationArgsForCall)]
	fake.postSingleBeadSimulationArgsForCall = append(fake.postSingleBeadSimulationArgsForCall, struct {
		arg1 *models.SingleBeadSimulation
	}{arg1})
	fake.recordInvocation("PostSingleBeadSimulation", []interface{}{arg1})
	fake.postSingleBeadSimulationMutex.Unlock()
	if fake.PostSingleBeadSimulationStub != nil {
		return fake.PostSingleBeadSimulationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.postSingleBeadSimulationReturns.result1, fake.postSingleBeadSimulationReturns.result2
}

func (fake *FakeClient) PostSingleBeadSimulationCallCount() int {
	fake.postSingleBeadSimulationMutex.RLock()
	defer fake.postSingleBeadSimulationMutex.RUnlock()
	return len(fake.postSingleBeadSimulationArgsForCall)
}

func (fake *FakeClient) PostSingleBeadSimulationArgsForCall(i int) *models.SingleBeadSimulation {
	fake.postSingleBeadSimulationMutex.RLock()
	defer fake.postSingleBeadSimulationMutex.RUnlock()
	return fake.postSingleBeadSimulationArgsForCall[i].arg1
}

func (fake *FakeClient) PostSingleBeadSimulationReturns(result1 *models.SingleBeadSimulation, result2 error) {
	fake.PostSingleBeadSimulationStub = nil
	fake.postSingleBeadSimulationReturns = struct {
		result1 *models.SingleBeadSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostSingleBeadSimulationReturnsOnCall(i int, result1 *models.SingleBeadSimulation, result2 error) {
	fake.PostSingleBeadSimulationStub = nil
	if fake.postSingleBeadSimulationReturnsOnCall == nil {
		fake.postSingleBeadSimulationReturnsOnCall = make(map[int]struct {
			result1 *models.SingleBeadSimulation
			result2 error
		})
	}
	fake.postSingleBeadSimulationReturnsOnCall[i] = struct {
		result1 *models.SingleBeadSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostThermalSimulation(arg1 *models.ThermalSimulation) (*models.ThermalSimulation, error) {
	fake.postThermalSimulationMutex.Lock()
	ret, specificReturn := fake.postThermalSimulationReturnsOnCall[len(fake.postThermalSimulationArgsForCall)]
	fake.postThermalSimulationArgsForCall = append(fake.postThermalSimulationArgsForCall, struct {
		arg1 *models.ThermalSimulation
	}{arg1})
	fake.recordInvocation("PostThermalSimulation", []interface{}{arg1})
	fake.postThermalSimulationMutex.Unlock()
	if fake.PostThermalSimulationStub != nil {
		return fake.PostThermalSimulationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.postThermalSimulationReturns.result1, fake.postThermalSimulationReturns.result2
}

func (fake *FakeClient) PostThermalSimulationCallCount() int {
	fake.postThermalSimulationMutex.RLock()
	defer fake.postThermalSimulationMutex.RUnlock()
	return len(fake.postThermalSimulationArgsForCall)
}

func (fake *FakeClient) PostThermalSimulationArgsForCall(i int) *models.ThermalSimulation {
	fake.postThermalSimulationMutex.RLock()
	defer fake.postThermalSimulationMutex.RUnlock()
	return fake.postThermalSimulationArgsForCall[i].arg1
}

func (fake *FakeClient) PostThermalSimulationReturns(result1 *models.ThermalSimulation, result2 error) {
	fake.PostThermalSimulationStub = nil
	fake.postThermalSimulationReturns = struct {
		result1 *models.ThermalSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostThermalSimulationReturnsOnCall(i int, result1 *models.ThermalSimulation, result2 error) {
	fake.PostThermalSimulationStub = nil
	if fake.postThermalSimulationReturnsOnCall == nil {
		fake.postThermalSimulationReturnsOnCall = make(map[int]struct {
			result1 *models.ThermalSimulation
			result2 error
		})
	}
	fake.postThermalSimulationReturnsOnCall[i] = struct {
		result1 *models.ThermalSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Machine(machineID int32) (*models.Machine, error) {
	fake.machineMutex.Lock()
	ret, specificReturn := fake.machineReturnsOnCall[len(fake.machineArgsForCall)]
	fake.machineArgsForCall = append(fake.machineArgsForCall, struct {
		machineID int32
	}{machineID})
	fake.recordInvocation("Machine", []interface{}{machineID})
	fake.machineMutex.Unlock()
	if fake.MachineStub != nil {
		return fake.MachineStub(machineID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.machineReturns.result1, fake.machineReturns.result2
}

func (fake *FakeClient) MachineCallCount() int {
	fake.machineMutex.RLock()
	defer fake.machineMutex.RUnlock()
	return len(fake.machineArgsForCall)
}

func (fake *FakeClient) MachineArgsForCall(i int) int32 {
	fake.machineMutex.RLock()
	defer fake.machineMutex.RUnlock()
	return fake.machineArgsForCall[i].machineID
}

func (fake *FakeClient) MachineReturns(result1 *models.Machine, result2 error) {
	fake.MachineStub = nil
	fake.machineReturns = struct {
		result1 *models.Machine
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) MachineReturnsOnCall(i int, result1 *models.Machine, result2 error) {
	fake.MachineStub = nil
	if fake.machineReturnsOnCall == nil {
		fake.machineReturnsOnCall = make(map[int]struct {
			result1 *models.Machine
			result2 error
		})
	}
	fake.machineReturnsOnCall[i] = struct {
		result1 *models.Machine
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Material(materialID int32) (*models.Material, error) {
	fake.materialMutex.Lock()
	ret, specificReturn := fake.materialReturnsOnCall[len(fake.materialArgsForCall)]
	fake.materialArgsForCall = append(fake.materialArgsForCall, struct {
		materialID int32
	}{materialID})
	fake.recordInvocation("Material", []interface{}{materialID})
	fake.materialMutex.Unlock()
	if fake.MaterialStub != nil {
		return fake.MaterialStub(materialID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.materialReturns.result1, fake.materialReturns.result2
}

func (fake *FakeClient) MaterialCallCount() int {
	fake.materialMutex.RLock()
	defer fake.materialMutex.RUnlock()
	return len(fake.materialArgsForCall)
}

func (fake *FakeClient) MaterialArgsForCall(i int) int32 {
	fake.materialMutex.RLock()
	defer fake.materialMutex.RUnlock()
	return fake.materialArgsForCall[i].materialID
}

func (fake *FakeClient) MaterialReturns(result1 *models.Material, result2 error) {
	fake.MaterialStub = nil
	fake.materialReturns = struct {
		result1 *models.Material
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) MaterialReturnsOnCall(i int, result1 *models.Material, result2 error) {
	fake.MaterialStub = nil
	if fake.materialReturnsOnCall == nil {
		fake.materialReturnsOnCall = make(map[int]struct {
			result1 *models.Material
			result2 error
		})
	}
	fake.materialReturnsOnCall[i] = struct {
		result1 *models.Material
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Simulation(simulationID int32) (*models.Simulation, error) {
	fake.simulationMutex.Lock()
	ret, specificReturn := fake.simulationReturnsOnCall[len(fake.simulationArgsForCall)]
	fake.simulationArgsForCall = append(fake.simulationArgsForCall, struct {
		simulationID int32
	}{simulationID})
	fake.recordInvocation("Simulation", []interface{}{simulationID})
	fake.simulationMutex.Unlock()
	if fake.SimulationStub != nil {
		return fake.SimulationStub(simulationID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.simulationReturns.result1, fake.simulationReturns.result2
}

func (fake *FakeClient) SimulationCallCount() int {
	fake.simulationMutex.RLock()
	defer fake.simulationMutex.RUnlock()
	return len(fake.simulationArgsForCall)
}

func (fake *FakeClient) SimulationArgsForCall(i int) int32 {
	fake.simulationMutex.RLock()
	defer fake.simulationMutex.RUnlock()
	return fake.simulationArgsForCall[i].simulationID
}

func (fake *FakeClient) SimulationReturns(result1 *models.Simulation, result2 error) {
	fake.SimulationStub = nil
	fake.simulationReturns = struct {
		result1 *models.Simulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SimulationReturnsOnCall(i int, result1 *models.Simulation, result2 error) {
	fake.SimulationStub = nil
	if fake.simulationReturnsOnCall == nil {
		fake.simulationReturnsOnCall = make(map[int]struct {
			result1 *models.Simulation
			result2 error
		})
	}
	fake.simulationReturnsOnCall[i] = struct {
		result1 *models.Simulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ScanPatternSimulation(simulationID int32) (*models.ScanPatternSimulation, error) {
	fake.scanPatternSimulationMutex.Lock()
	ret, specificReturn := fake.scanPatternSimulationReturnsOnCall[len(fake.scanPatternSimulationArgsForCall)]
	fake.scanPatternSimulationArgsForCall = append(fake.scanPatternSimulationArgsForCall, struct {
		simulationID int32
	}{simulationID})
	fake.recordInvocation("ScanPatternSimulation", []interface{}{simulationID})
	fake.scanPatternSimulationMutex.Unlock()
	if fake.ScanPatternSimulationStub != nil {
		return fake.ScanPatternSimulationStub(simulationID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.scanPatternSimulationReturns.result1, fake.scanPatternSimulationReturns.result2
}

func (fake *FakeClient) ScanPatternSimulationCallCount() int {
	fake.scanPatternSimulationMutex.RLock()
	defer fake.scanPatternSimulationMutex.RUnlock()
	return len(fake.scanPatternSimulationArgsForCall)
}

func (fake *FakeClient) ScanPatternSimulationArgsForCall(i int) int32 {
	fake.scanPatternSimulationMutex.RLock()
	defer fake.scanPatternSimulationMutex.RUnlock()
	return fake.scanPatternSimulationArgsForCall[i].simulationID
}

func (fake *FakeClient) ScanPatternSimulationReturns(result1 *models.ScanPatternSimulation, result2 error) {
	fake.ScanPatternSimulationStub = nil
	fake.scanPatternSimulationReturns = struct {
		result1 *models.ScanPatternSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ScanPatternSimulationReturnsOnCall(i int, result1 *models.ScanPatternSimulation, result2 error) {
	fake.ScanPatternSimulationStub = nil
	if fake.scanPatternSimulationReturnsOnCall == nil {
		fake.scanPatternSimulationReturnsOnCall = make(map[int]struct {
			result1 *models.ScanPatternSimulation
			result2 error
		})
	}
	fake.scanPatternSimulationReturnsOnCall[i] = struct {
		result1 *models.ScanPatternSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) AssumedStrainSimulation(simulationID int32) (*models.AssumedStrainSimulation, error) {
	fake.assumedStrainSimulationMutex.Lock()
	ret, specificReturn := fake.assumedStrainSimulationReturnsOnCall[len(fake.assumedStrainSimulationArgsForCall)]
	fake.assumedStrainSimulationArgsForCall = append(fake.assumedStrainSimulationArgsForCall, struct {
		simulationID int32
	}{simulationID})
	fake.recordInvocation("AssumedStrainSimulation", []interface{}{simulationID})
	fake.assumedStrainSimulationMutex.Unlock()
	if fake.AssumedStrainSimulationStub != nil {
		return fake.AssumedStrainSimulationStub(simulationID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.assumedStrainSimulationReturns.result1, fake.assumedStrainSimulationReturns.result2
}

func (fake *FakeClient) AssumedStrainSimulationCallCount() int {
	fake.assumedStrainSimulationMutex.RLock()
	defer fake.assumedStrainSimulationMutex.RUnlock()
	return len(fake.assumedStrainSimulationArgsForCall)
}

func (fake *FakeClient) AssumedStrainSimulationArgsForCall(i int) int32 {
	fake.assumedStrainSimulationMutex.RLock()
	defer fake.assumedStrainSimulationMutex.RUnlock()
	return fake.assumedStrainSimulationArgsForCall[i].simulationID
}

func (fake *FakeClient) AssumedStrainSimulationReturns(result1 *models.AssumedStrainSimulation, result2 error) {
	fake.AssumedStrainSimulationStub = nil
	fake.assumedStrainSimulationReturns = struct {
		result1 *models.AssumedStrainSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) AssumedStrainSimulationReturnsOnCall(i int, result1 *models.AssumedStrainSimulation, result2 error) {
	fake.AssumedStrainSimulationStub = nil
	if fake.assumedStrainSimulationReturnsOnCall == nil {
		fake.assumedStrainSimulationReturnsOnCall = make(map[int]struct {
			result1 *models.AssumedStrainSimulation
			result2 error
		})
	}
	fake.assumedStrainSimulationReturnsOnCall[i] = struct {
		result1 *models.AssumedStrainSimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PorositySimulation(simulationID int32) (*models.PorositySimulation, error) {
	fake.porositySimulationMutex.Lock()
	ret, specificReturn := fake.porositySimulationReturnsOnCall[len(fake.porositySimulationArgsForCall)]
	fake.porositySimulationArgsForCall = append(fake.porositySimulationArgsForCall, struct {
		simulationID int32
	}{simulationID})
	fake.recordInvocation("PorositySimulation", []interface{}{simulationID})
	fake.porositySimulationMutex.Unlock()
	if fake.PorositySimulationStub != nil {
		return fake.PorositySimulationStub(simulationID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.porositySimulationReturns.result1, fake.porositySimulationReturns.result2
}

func (fake *FakeClient) PorositySimulationCallCount() int {
	fake.porositySimulationMutex.RLock()
	defer fake.porositySimulationMutex.RUnlock()
	return len(fake.porositySimulationArgsForCall)
}

func (fake *FakeClient) PorositySimulationArgsForCall(i int) int32 {
	fake.porositySimulationMutex.RLock()
	defer fake.porositySimulationMutex.RUnlock()
	return fake.porositySimulationArgsForCall[i].simulationID
}

func (fake *FakeClient) PorositySimulationReturns(result1 *models.PorositySimulation, result2 error) {
	fake.PorositySimulationStub = nil
	fake.porositySimulationReturns = struct {
		result1 *models.PorositySimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PorositySimulationReturnsOnCall(i int, result1 *models.PorositySimulation, result2 error) {
	fake.PorositySimulationStub = nil
	if fake.porositySimulationReturnsOnCall == nil {
		fake.porositySimulationReturnsOnCall = make(map[int]struct {
			result1 *models.PorositySimulation
			result2 error
		})
	}
	fake.porositySimulationReturnsOnCall[i] = struct {
		result1 *models.PorositySimulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostLog(level string, message string, simulationID int32, activityID string) (err error) {
	fake.postLogMutex.Lock()
	ret, specificReturn := fake.postLogReturnsOnCall[len(fake.postLogArgsForCall)]
	fake.postLogArgsForCall = append(fake.postLogArgsForCall, struct {
		level        string
		message      string
		simulationID int32
		activityID   string
	}{level, message, simulationID, activityID})
	fake.recordInvocation("PostLog", []interface{}{level, message, simulationID, activityID})
	fake.postLogMutex.Unlock()
	if fake.PostLogStub != nil {
		return fake.PostLogStub(level, message, simulationID, activityID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.postLogReturns.result1
}

func (fake *FakeClient) PostLogCallCount() int {
	fake.postLogMutex.RLock()
	defer fake.postLogMutex.RUnlock()
	return len(fake.postLogArgsForCall)
}

func (fake *FakeClient) PostLogArgsForCall(i int) (string, string, int32, string) {
	fake.postLogMutex.RLock()
	defer fake.postLogMutex.RUnlock()
	return fake.postLogArgsForCall[i].level, fake.postLogArgsForCall[i].message, fake.postLogArgsForCall[i].simulationID, fake.postLogArgsForCall[i].activityID
}

func (fake *FakeClient) PostLogReturns(result1 error) {
	fake.PostLogStub = nil
	fake.postLogReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PostLogReturnsOnCall(i int, result1 error) {
	fake.PostLogStub = nil
	if fake.postLogReturnsOnCall == nil {
		fake.postLogReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.postLogReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PostLogWithObject(simulationLog models.SimulationLog) (err error) {
	fake.postLogWithObjectMutex.Lock()
	ret, specificReturn := fake.postLogWithObjectReturnsOnCall[len(fake.postLogWithObjectArgsForCall)]
	fake.postLogWithObjectArgsForCall = append(fake.postLogWithObjectArgsForCall, struct {
		simulationLog models.SimulationLog
	}{simulationLog})
	fake.recordInvocation("PostLogWithObject", []interface{}{simulationLog})
	fake.postLogWithObjectMutex.Unlock()
	if fake.PostLogWithObjectStub != nil {
		return fake.PostLogWithObjectStub(simulationLog)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.postLogWithObjectReturns.result1
}

func (fake *FakeClient) PostLogWithObjectCallCount() int {
	fake.postLogWithObjectMutex.RLock()
	defer fake.postLogWithObjectMutex.RUnlock()
	return len(fake.postLogWithObjectArgsForCall)
}

func (fake *FakeClient) PostLogWithObjectArgsForCall(i int) models.SimulationLog {
	fake.postLogWithObjectMutex.RLock()
	defer fake.postLogWithObjectMutex.RUnlock()
	return fake.postLogWithObjectArgsForCall[i].simulationLog
}

func (fake *FakeClient) PostLogWithObjectReturns(result1 error) {
	fake.PostLogWithObjectStub = nil
	fake.postLogWithObjectReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PostLogWithObjectReturnsOnCall(i int, result1 error) {
	fake.PostLogWithObjectStub = nil
	if fake.postLogWithObjectReturnsOnCall == nil {
		fake.postLogWithObjectReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.postLogWithObjectReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PostLogInfo(message string, simulationID int32, activityID string) (err error) {
	fake.postLogInfoMutex.Lock()
	ret, specificReturn := fake.postLogInfoReturnsOnCall[len(fake.postLogInfoArgsForCall)]
	fake.postLogInfoArgsForCall = append(fake.postLogInfoArgsForCall, struct {
		message      string
		simulationID int32
		activityID   string
	}{message, simulationID, activityID})
	fake.recordInvocation("PostLogInfo", []interface{}{message, simulationID, activityID})
	fake.postLogInfoMutex.Unlock()
	if fake.PostLogInfoStub != nil {
		return fake.PostLogInfoStub(message, simulationID, activityID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.postLogInfoReturns.result1
}

func (fake *FakeClient) PostLogInfoCallCount() int {
	fake.postLogInfoMutex.RLock()
	defer fake.postLogInfoMutex.RUnlock()
	return len(fake.postLogInfoArgsForCall)
}

func (fake *FakeClient) PostLogInfoArgsForCall(i int) (string, int32, string) {
	fake.postLogInfoMutex.RLock()
	defer fake.postLogInfoMutex.RUnlock()
	return fake.postLogInfoArgsForCall[i].message, fake.postLogInfoArgsForCall[i].simulationID, fake.postLogInfoArgsForCall[i].activityID
}

func (fake *FakeClient) PostLogInfoReturns(result1 error) {
	fake.PostLogInfoStub = nil
	fake.postLogInfoReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PostLogInfoReturnsOnCall(i int, result1 error) {
	fake.PostLogInfoStub = nil
	if fake.postLogInfoReturnsOnCall == nil {
		fake.postLogInfoReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.postLogInfoReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PostLogWarn(message string, simulationID int32, activityID string) (err error) {
	fake.postLogWarnMutex.Lock()
	ret, specificReturn := fake.postLogWarnReturnsOnCall[len(fake.postLogWarnArgsForCall)]
	fake.postLogWarnArgsForCall = append(fake.postLogWarnArgsForCall, struct {
		message      string
		simulationID int32
		activityID   string
	}{message, simulationID, activityID})
	fake.recordInvocation("PostLogWarn", []interface{}{message, simulationID, activityID})
	fake.postLogWarnMutex.Unlock()
	if fake.PostLogWarnStub != nil {
		return fake.PostLogWarnStub(message, simulationID, activityID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.postLogWarnReturns.result1
}

func (fake *FakeClient) PostLogWarnCallCount() int {
	fake.postLogWarnMutex.RLock()
	defer fake.postLogWarnMutex.RUnlock()
	return len(fake.postLogWarnArgsForCall)
}

func (fake *FakeClient) PostLogWarnArgsForCall(i int) (string, int32, string) {
	fake.postLogWarnMutex.RLock()
	defer fake.postLogWarnMutex.RUnlock()
	return fake.postLogWarnArgsForCall[i].message, fake.postLogWarnArgsForCall[i].simulationID, fake.postLogWarnArgsForCall[i].activityID
}

func (fake *FakeClient) PostLogWarnReturns(result1 error) {
	fake.PostLogWarnStub = nil
	fake.postLogWarnReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PostLogWarnReturnsOnCall(i int, result1 error) {
	fake.PostLogWarnStub = nil
	if fake.postLogWarnReturnsOnCall == nil {
		fake.postLogWarnReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.postLogWarnReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PostLogError(message string, simulationID int32, activityID string) (err error) {
	fake.postLogErrorMutex.Lock()
	ret, specificReturn := fake.postLogErrorReturnsOnCall[len(fake.postLogErrorArgsForCall)]
	fake.postLogErrorArgsForCall = append(fake.postLogErrorArgsForCall, struct {
		message      string
		simulationID int32
		activityID   string
	}{message, simulationID, activityID})
	fake.recordInvocation("PostLogError", []interface{}{message, simulationID, activityID})
	fake.postLogErrorMutex.Unlock()
	if fake.PostLogErrorStub != nil {
		return fake.PostLogErrorStub(message, simulationID, activityID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.postLogErrorReturns.result1
}

func (fake *FakeClient) PostLogErrorCallCount() int {
	fake.postLogErrorMutex.RLock()
	defer fake.postLogErrorMutex.RUnlock()
	return len(fake.postLogErrorArgsForCall)
}

func (fake *FakeClient) PostLogErrorArgsForCall(i int) (string, int32, string) {
	fake.postLogErrorMutex.RLock()
	defer fake.postLogErrorMutex.RUnlock()
	return fake.postLogErrorArgsForCall[i].message, fake.postLogErrorArgsForCall[i].simulationID, fake.postLogErrorArgsForCall[i].activityID
}

func (fake *FakeClient) PostLogErrorReturns(result1 error) {
	fake.PostLogErrorStub = nil
	fake.postLogErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PostLogErrorReturnsOnCall(i int, result1 error) {
	fake.PostLogErrorStub = nil
	if fake.postLogErrorReturnsOnCall == nil {
		fake.postLogErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.postLogErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PatchSimulation(simulationID int32, patch *models.PatchDocument) error {
	fake.patchSimulationMutex.Lock()
	ret, specificReturn := fake.patchSimulationReturnsOnCall[len(fake.patchSimulationArgsForCall)]
	fake.patchSimulationArgsForCall = append(fake.patchSimulationArgsForCall, struct {
		simulationID int32
		patch        *models.PatchDocument
	}{simulationID, patch})
	fake.recordInvocation("PatchSimulation", []interface{}{simulationID, patch})
	fake.patchSimulationMutex.Unlock()
	if fake.PatchSimulationStub != nil {
		return fake.PatchSimulationStub(simulationID, patch)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.patchSimulationReturns.result1
}

func (fake *FakeClient) PatchSimulationCallCount() int {
	fake.patchSimulationMutex.RLock()
	defer fake.patchSimulationMutex.RUnlock()
	return len(fake.patchSimulationArgsForCall)
}

func (fake *FakeClient) PatchSimulationArgsForCall(i int) (int32, *models.PatchDocument) {
	fake.patchSimulationMutex.RLock()
	defer fake.patchSimulationMutex.RUnlock()
	return fake.patchSimulationArgsForCall[i].simulationID, fake.patchSimulationArgsForCall[i].patch
}

func (fake *FakeClient) PatchSimulationReturns(result1 error) {
	fake.PatchSimulationStub = nil
	fake.patchSimulationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PatchSimulationReturnsOnCall(i int, result1 error) {
	fake.PatchSimulationStub = nil
	if fake.patchSimulationReturnsOnCall == nil {
		fake.patchSimulationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.patchSimulationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) MultiPatchSimulation(simulationID int32, patches []*models.PatchDocument) error {
	var patchesCopy []*models.PatchDocument
	if patches != nil {
		patchesCopy = make([]*models.PatchDocument, len(patches))
		copy(patchesCopy, patches)
	}
	fake.multiPatchSimulationMutex.Lock()
	ret, specificReturn := fake.multiPatchSimulationReturnsOnCall[len(fake.multiPatchSimulationArgsForCall)]
	fake.multiPatchSimulationArgsForCall = append(fake.multiPatchSimulationArgsForCall, struct {
		simulationID int32
		patches      []*models.PatchDocument
	}{simulationID, patchesCopy})
	fake.recordInvocation("MultiPatchSimulation", []interface{}{simulationID, patchesCopy})
	fake.multiPatchSimulationMutex.Unlock()
	if fake.MultiPatchSimulationStub != nil {
		return fake.MultiPatchSimulationStub(simulationID, patches)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.multiPatchSimulationReturns.result1
}

func (fake *FakeClient) MultiPatchSimulationCallCount() int {
	fake.multiPatchSimulationMutex.RLock()
	defer fake.multiPatchSimulationMutex.RUnlock()
	return len(fake.multiPatchSimulationArgsForCall)
}

func (fake *FakeClient) MultiPatchSimulationArgsForCall(i int) (int32, []*models.PatchDocument) {
	fake.multiPatchSimulationMutex.RLock()
	defer fake.multiPatchSimulationMutex.RUnlock()
	return fake.multiPatchSimulationArgsForCall[i].simulationID, fake.multiPatchSimulationArgsForCall[i].patches
}

func (fake *FakeClient) MultiPatchSimulationReturns(result1 error) {
	fake.MultiPatchSimulationStub = nil
	fake.multiPatchSimulationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) MultiPatchSimulationReturnsOnCall(i int, result1 error) {
	fake.MultiPatchSimulationStub = nil
	if fake.multiPatchSimulationReturnsOnCall == nil {
		fake.multiPatchSimulationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.multiPatchSimulationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PostSimulationActivity(simulationID int32, simulationActivity *models.SimulationActivity) (*models.SimulationActivity, error) {
	fake.postSimulationActivityMutex.Lock()
	ret, specificReturn := fake.postSimulationActivityReturnsOnCall[len(fake.postSimulationActivityArgsForCall)]
	fake.postSimulationActivityArgsForCall = append(fake.postSimulationActivityArgsForCall, struct {
		simulationID       int32
		simulationActivity *models.SimulationActivity
	}{simulationID, simulationActivity})
	fake.recordInvocation("PostSimulationActivity", []interface{}{simulationID, simulationActivity})
	fake.postSimulationActivityMutex.Unlock()
	if fake.PostSimulationActivityStub != nil {
		return fake.PostSimulationActivityStub(simulationID, simulationActivity)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.postSimulationActivityReturns.result1, fake.postSimulationActivityReturns.result2
}

func (fake *FakeClient) PostSimulationActivityCallCount() int {
	fake.postSimulationActivityMutex.RLock()
	defer fake.postSimulationActivityMutex.RUnlock()
	return len(fake.postSimulationActivityArgsForCall)
}

func (fake *FakeClient) PostSimulationActivityArgsForCall(i int) (int32, *models.SimulationActivity) {
	fake.postSimulationActivityMutex.RLock()
	defer fake.postSimulationActivityMutex.RUnlock()
	return fake.postSimulationActivityArgsForCall[i].simulationID, fake.postSimulationActivityArgsForCall[i].simulationActivity
}

func (fake *FakeClient) PostSimulationActivityReturns(result1 *models.SimulationActivity, result2 error) {
	fake.PostSimulationActivityStub = nil
	fake.postSimulationActivityReturns = struct {
		result1 *models.SimulationActivity
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostSimulationActivityReturnsOnCall(i int, result1 *models.SimulationActivity, result2 error) {
	fake.PostSimulationActivityStub = nil
	if fake.postSimulationActivityReturnsOnCall == nil {
		fake.postSimulationActivityReturnsOnCall = make(map[int]struct {
			result1 *models.SimulationActivity
			result2 error
		})
	}
	fake.postSimulationActivityReturnsOnCall[i] = struct {
		result1 *models.SimulationActivity
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SimulationActivityByActivityID(simulationID int32, activityID string) (*models.SimulationActivity, error) {
	fake.simulationActivityByActivityIDMutex.Lock()
	ret, specificReturn := fake.simulationActivityByActivityIDReturnsOnCall[len(fake.simulationActivityByActivityIDArgsForCall)]
	fake.simulationActivityByActivityIDArgsForCall = append(fake.simulationActivityByActivityIDArgsForCall, struct {
		simulationID int32
		activityID   string
	}{simulationID, activityID})
	fake.recordInvocation("SimulationActivityByActivityID", []interface{}{simulationID, activityID})
	fake.simulationActivityByActivityIDMutex.Unlock()
	if fake.SimulationActivityByActivityIDStub != nil {
		return fake.SimulationActivityByActivityIDStub(simulationID, activityID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.simulationActivityByActivityIDReturns.result1, fake.simulationActivityByActivityIDReturns.result2
}

func (fake *FakeClient) SimulationActivityByActivityIDCallCount() int {
	fake.simulationActivityByActivityIDMutex.RLock()
	defer fake.simulationActivityByActivityIDMutex.RUnlock()
	return len(fake.simulationActivityByActivityIDArgsForCall)
}

func (fake *FakeClient) SimulationActivityByActivityIDArgsForCall(i int) (int32, string) {
	fake.simulationActivityByActivityIDMutex.RLock()
	defer fake.simulationActivityByActivityIDMutex.RUnlock()
	return fake.simulationActivityByActivityIDArgsForCall[i].simulationID, fake.simulationActivityByActivityIDArgsForCall[i].activityID
}

func (fake *FakeClient) SimulationActivityByActivityIDReturns(result1 *models.SimulationActivity, result2 error) {
	fake.SimulationActivityByActivityIDStub = nil
	fake.simulationActivityByActivityIDReturns = struct {
		result1 *models.SimulationActivity
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SimulationActivityByActivityIDReturnsOnCall(i int, result1 *models.SimulationActivity, result2 error) {
	fake.SimulationActivityByActivityIDStub = nil
	if fake.simulationActivityByActivityIDReturnsOnCall == nil {
		fake.simulationActivityByActivityIDReturnsOnCall = make(map[int]struct {
			result1 *models.SimulationActivity
			result2 error
		})
	}
	fake.simulationActivityByActivityIDReturnsOnCall[i] = struct {
		result1 *models.SimulationActivity
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PutSimulationActivity(simulationID int32, simulationActivity *models.SimulationActivity) error {
	fake.putSimulationActivityMutex.Lock()
	ret, specificReturn := fake.putSimulationActivityReturnsOnCall[len(fake.putSimulationActivityArgsForCall)]
	fake.putSimulationActivityArgsForCall = append(fake.putSimulationActivityArgsForCall, struct {
		simulationID       int32
		simulationActivity *models.SimulationActivity
	}{simulationID, simulationActivity})
	fake.recordInvocation("PutSimulationActivity", []interface{}{simulationID, simulationActivity})
	fake.putSimulationActivityMutex.Unlock()
	if fake.PutSimulationActivityStub != nil {
		return fake.PutSimulationActivityStub(simulationID, simulationActivity)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.putSimulationActivityReturns.result1
}

func (fake *FakeClient) PutSimulationActivityCallCount() int {
	fake.putSimulationActivityMutex.RLock()
	defer fake.putSimulationActivityMutex.RUnlock()
	return len(fake.putSimulationActivityArgsForCall)
}

func (fake *FakeClient) PutSimulationActivityArgsForCall(i int) (int32, *models.SimulationActivity) {
	fake.putSimulationActivityMutex.RLock()
	defer fake.putSimulationActivityMutex.RUnlock()
	return fake.putSimulationActivityArgsForCall[i].simulationID, fake.putSimulationActivityArgsForCall[i].simulationActivity
}

func (fake *FakeClient) PutSimulationActivityReturns(result1 error) {
	fake.PutSimulationActivityStub = nil
	fake.putSimulationActivityReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PutSimulationActivityReturnsOnCall(i int, result1 error) {
	fake.PutSimulationActivityStub = nil
	if fake.putSimulationActivityReturnsOnCall == nil {
		fake.putSimulationActivityReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.putSimulationActivityReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PatchSimulationActivity(simulationID int32, activityID string, patches []*models.PatchDocument) (*models.SimulationActivity, error) {
	var patchesCopy []*models.PatchDocument
	if patches != nil {
		patchesCopy = make([]*models.PatchDocument, len(patches))
		copy(patchesCopy, patches)
	}
	fake.patchSimulationActivityMutex.Lock()
	ret, specificReturn := fake.patchSimulationActivityReturnsOnCall[len(fake.patchSimulationActivityArgsForCall)]
	fake.patchSimulationActivityArgsForCall = append(fake.patchSimulationActivityArgsForCall, struct {
		simulationID int32
		activityID   string
		patches      []*models.PatchDocument
	}{simulationID, activityID, patchesCopy})
	fake.recordInvocation("PatchSimulationActivity", []interface{}{simulationID, activityID, patchesCopy})
	fake.patchSimulationActivityMutex.Unlock()
	if fake.PatchSimulationActivityStub != nil {
		return fake.PatchSimulationActivityStub(simulationID, activityID, patches)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.patchSimulationActivityReturns.result1, fake.patchSimulationActivityReturns.result2
}

func (fake *FakeClient) PatchSimulationActivityCallCount() int {
	fake.patchSimulationActivityMutex.RLock()
	defer fake.patchSimulationActivityMutex.RUnlock()
	return len(fake.patchSimulationActivityArgsForCall)
}

func (fake *FakeClient) PatchSimulationActivityArgsForCall(i int) (int32, string, []*models.PatchDocument) {
	fake.patchSimulationActivityMutex.RLock()
	defer fake.patchSimulationActivityMutex.RUnlock()
	return fake.patchSimulationActivityArgsForCall[i].simulationID, fake.patchSimulationActivityArgsForCall[i].activityID, fake.patchSimulationActivityArgsForCall[i].patches
}

func (fake *FakeClient) PatchSimulationActivityReturns(result1 *models.SimulationActivity, result2 error) {
	fake.PatchSimulationActivityStub = nil
	fake.patchSimulationActivityReturns = struct {
		result1 *models.SimulationActivity
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PatchSimulationActivityReturnsOnCall(i int, result1 *models.SimulationActivity, result2 error) {
	fake.PatchSimulationActivityStub = nil
	if fake.patchSimulationActivityReturnsOnCall == nil {
		fake.patchSimulationActivityReturnsOnCall = make(map[int]struct {
			result1 *models.SimulationActivity
			result2 error
		})
	}
	fake.patchSimulationActivityReturnsOnCall[i] = struct {
		result1 *models.SimulationActivity
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) AddSimulationOutput(simulationID int32, outputType string, outputFileLocation string) (*models.SimulationOutput, error) {
	fake.addSimulationOutputMutex.Lock()
	ret, specificReturn := fake.addSimulationOutputReturnsOnCall[len(fake.addSimulationOutputArgsForCall)]
	fake.addSimulationOutputArgsForCall = append(fake.addSimulationOutputArgsForCall, struct {
		simulationID       int32
		outputType         string
		outputFileLocation string
	}{simulationID, outputType, outputFileLocation})
	fake.recordInvocation("AddSimulationOutput", []interface{}{simulationID, outputType, outputFileLocation})
	fake.addSimulationOutputMutex.Unlock()
	if fake.AddSimulationOutputStub != nil {
		return fake.AddSimulationOutputStub(simulationID, outputType, outputFileLocation)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.addSimulationOutputReturns.result1, fake.addSimulationOutputReturns.result2
}

func (fake *FakeClient) AddSimulationOutputCallCount() int {
	fake.addSimulationOutputMutex.RLock()
	defer fake.addSimulationOutputMutex.RUnlock()
	return len(fake.addSimulationOutputArgsForCall)
}

func (fake *FakeClient) AddSimulationOutputArgsForCall(i int) (int32, string, string) {
	fake.addSimulationOutputMutex.RLock()
	defer fake.addSimulationOutputMutex.RUnlock()
	return fake.addSimulationOutputArgsForCall[i].simulationID, fake.addSimulationOutputArgsForCall[i].outputType, fake.addSimulationOutputArgsForCall[i].outputFileLocation
}

func (fake *FakeClient) AddSimulationOutputReturns(result1 *models.SimulationOutput, result2 error) {
	fake.AddSimulationOutputStub = nil
	fake.addSimulationOutputReturns = struct {
		result1 *models.SimulationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) AddSimulationOutputReturnsOnCall(i int, result1 *models.SimulationOutput, result2 error) {
	fake.AddSimulationOutputStub = nil
	if fake.addSimulationOutputReturnsOnCall == nil {
		fake.addSimulationOutputReturnsOnCall = make(map[int]struct {
			result1 *models.SimulationOutput
			result2 error
		})
	}
	fake.addSimulationOutputReturnsOnCall[i] = struct {
		result1 *models.SimulationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateSimulationStatus(simulationID int32, status string) error {
	fake.updateSimulationStatusMutex.Lock()
	ret, specificReturn := fake.updateSimulationStatusReturnsOnCall[len(fake.updateSimulationStatusArgsForCall)]
	fake.updateSimulationStatusArgsForCall = append(fake.updateSimulationStatusArgsForCall, struct {
		simulationID int32
		status       string
	}{simulationID, status})
	fake.recordInvocation("UpdateSimulationStatus", []interface{}{simulationID, status})
	fake.updateSimulationStatusMutex.Unlock()
	if fake.UpdateSimulationStatusStub != nil {
		return fake.UpdateSimulationStatusStub(simulationID, status)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.updateSimulationStatusReturns.result1
}

func (fake *FakeClient) UpdateSimulationStatusCallCount() int {
	fake.updateSimulationStatusMutex.RLock()
	defer fake.updateSimulationStatusMutex.RUnlock()
	return len(fake.updateSimulationStatusArgsForCall)
}

func (fake *FakeClient) UpdateSimulationStatusArgsForCall(i int) (int32, string) {
	fake.updateSimulationStatusMutex.RLock()
	defer fake.updateSimulationStatusMutex.RUnlock()
	return fake.updateSimulationStatusArgsForCall[i].simulationID, fake.updateSimulationStatusArgsForCall[i].status
}

func (fake *FakeClient) UpdateSimulationStatusReturns(result1 error) {
	fake.UpdateSimulationStatusStub = nil
	fake.updateSimulationStatusReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) UpdateSimulationStatusReturnsOnCall(i int, result1 error) {
	fake.UpdateSimulationStatusStub = nil
	if fake.updateSimulationStatusReturnsOnCall == nil {
		fake.updateSimulationStatusReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateSimulationStatusReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) RawSimulation(simulationID int32) (map[string]interface{}, error) {
	fake.rawSimulationMutex.Lock()
	ret, specificReturn := fake.rawSimulationReturnsOnCall[len(fake.rawSimulationArgsForCall)]
	fake.rawSimulationArgsForCall = append(fake.rawSimulationArgsForCall, struct {
		simulationID int32
	}{simulationID})
	fake.recordInvocation("RawSimulation", []interface{}{simulationID})
	fake.rawSimulationMutex.Unlock()
	if fake.RawSimulationStub != nil {
		return fake.RawSimulationStub(simulationID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.rawSimulationReturns.result1, fake.rawSimulationReturns.result2
}

func (fake *FakeClient) RawSimulationCallCount() int {
	fake.rawSimulationMutex.RLock()
	defer fake.rawSimulationMutex.RUnlock()
	return len(fake.rawSimulationArgsForCall)
}

func (fake *FakeClient) RawSimulationArgsForCall(i int) int32 {
	fake.rawSimulationMutex.RLock()
	defer fake.rawSimulationMutex.RUnlock()
	return fake.rawSimulationArgsForCall[i].simulationID
}

func (fake *FakeClient) RawSimulationReturns(result1 map[string]interface{}, result2 error) {
	fake.RawSimulationStub = nil
	fake.rawSimulationReturns = struct {
		result1 map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RawSimulationReturnsOnCall(i int, result1 map[string]interface{}, result2 error) {
	fake.RawSimulationStub = nil
	if fake.rawSimulationReturnsOnCall == nil {
		fake.rawSimulationReturnsOnCall = make(map[int]struct {
			result1 map[string]interface{}
			result2 error
		})
	}
	fake.rawSimulationReturnsOnCall[i] = struct {
		result1 map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) BuildFiles(organizationID int32, availability []string, sort []string, offset int32, limit int32) ([]*models.BuildFile, error) {
	var availabilityCopy []string
	if availability != nil {
		availabilityCopy = make([]string, len(availability))
		copy(availabilityCopy, availability)
	}
	var sortCopy []string
	if sort != nil {
		sortCopy = make([]string, len(sort))
		copy(sortCopy, sort)
	}
	fake.buildFilesMutex.Lock()
	ret, specificReturn := fake.buildFilesReturnsOnCall[len(fake.buildFilesArgsForCall)]
	fake.buildFilesArgsForCall = append(fake.buildFilesArgsForCall, struct {
		organizationID int32
		availability   []string
		sort           []string
		offset         int32
		limit          int32
	}{organizationID, availabilityCopy, sortCopy, offset, limit})
	fake.recordInvocation("BuildFiles", []interface{}{organizationID, availabilityCopy, sortCopy, offset, limit})
	fake.buildFilesMutex.Unlock()
	if fake.BuildFilesStub != nil {
		return fake.BuildFilesStub(organizationID, availability, sort, offset, limit)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.buildFilesReturns.result1, fake.buildFilesReturns.result2
}

func (fake *FakeClient) BuildFilesCallCount() int {
	fake.buildFilesMutex.RLock()
	defer fake.buildFilesMutex.RUnlock()
	return len(fake.buildFilesArgsForCall)
}

func (fake *FakeClient) BuildFilesArgsForCall(i int) (int32, []string, []string, int32, int32) {
	fake.buildFilesMutex.RLock()
	defer fake.buildFilesMutex.RUnlock()
	return fake.buildFilesArgsForCall[i].organizationID, fake.buildFilesArgsForCall[i].availability, fake.buildFilesArgsForCall[i].sort, fake.buildFilesArgsForCall[i].offset, fake.buildFilesArgsForCall[i].limit
}

func (fake *FakeClient) BuildFilesReturns(result1 []*models.BuildFile, result2 error) {
	fake.BuildFilesStub = nil
	fake.buildFilesReturns = struct {
		result1 []*models.BuildFile
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) BuildFilesReturnsOnCall(i int, result1 []*models.BuildFile, result2 error) {
	fake.BuildFilesStub = nil
	if fake.buildFilesReturnsOnCall == nil {
		fake.buildFilesReturnsOnCall = make(map[int]struct {
			result1 []*models.BuildFile
			result2 error
		})
	}
	fake.buildFilesReturnsOnCall[i] = struct {
		result1 []*models.BuildFile
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) BuildFile(buildFileID int32) (*models.BuildFile, error) {
	fake.buildFileMutex.Lock()
	ret, specificReturn := fake.buildFileReturnsOnCall[len(fake.buildFileArgsForCall)]
	fake.buildFileArgsForCall = append(fake.buildFileArgsForCall, struct {
		buildFileID int32
	}{buildFileID})
	fake.recordInvocation("BuildFile", []interface{}{buildFileID})
	fake.buildFileMutex.Unlock()
	if fake.BuildFileStub != nil {
		return fake.BuildFileStub(buildFileID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.buildFileReturns.result1, fake.buildFileReturns.result2
}

func (fake *FakeClient) BuildFileCallCount() int {
	fake.buildFileMutex.RLock()
	defer fake.buildFileMutex.RUnlock()
	return len(fake.buildFileArgsForCall)
}

func (fake *FakeClient) BuildFileArgsForCall(i int) int32 {
	fake.buildFileMutex.RLock()
	defer fake.buildFileMutex.RUnlock()
	return fake.buildFileArgsForCall[i].buildFileID
}

func (fake *FakeClient) BuildFileReturns(result1 *models.BuildFile, result2 error) {
	fake.BuildFileStub = nil
	fake.buildFileReturns = struct {
		result1 *models.BuildFile
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) BuildFileReturnsOnCall(i int, result1 *models.BuildFile, result2 error) {
	fake.BuildFileStub = nil
	if fake.buildFileReturnsOnCall == nil {
		fake.buildFileReturnsOnCall = make(map[int]struct {
			result1 *models.BuildFile
			result2 error
		})
	}
	fake.buildFileReturnsOnCall[i] = struct {
		result1 *models.BuildFile
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostBuildFile(arg1 *models.BuildFilePost) (*models.BuildFile, error) {
	fake.postBuildFileMutex.Lock()
	ret, specificReturn := fake.postBuildFileReturnsOnCall[len(fake.postBuildFileArgsForCall)]
	fake.postBuildFileArgsForCall = append(fake.postBuildFileArgsForCall, struct {
		arg1 *models.BuildFilePost
	}{arg1})
	fake.recordInvocation("PostBuildFile", []interface{}{arg1})
	fake.postBuildFileMutex.Unlock()
	if fake.PostBuildFileStub != nil {
		return fake.PostBuildFileStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.postBuildFileReturns.result1, fake.postBuildFileReturns.result2
}

func (fake *FakeClient) PostBuildFileCallCount() int {
	fake.postBuildFileMutex.RLock()
	defer fake.postBuildFileMutex.RUnlock()
	return len(fake.postBuildFileArgsForCall)
}

func (fake *FakeClient) PostBuildFileArgsForCall(i int) *models.BuildFilePost {
	fake.postBuildFileMutex.RLock()
	defer fake.postBuildFileMutex.RUnlock()
	return fake.postBuildFileArgsForCall[i].arg1
}

func (fake *FakeClient) PostBuildFileReturns(result1 *models.BuildFile, result2 error) {
	fake.PostBuildFileStub = nil
	fake.postBuildFileReturns = struct {
		result1 *models.BuildFile
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PostBuildFileReturnsOnCall(i int, result1 *models.BuildFile, result2 error) {
	fake.PostBuildFileStub = nil
	if fake.postBuildFileReturnsOnCall == nil {
		fake.postBuildFileReturnsOnCall = make(map[int]struct {
			result1 *models.BuildFile
			result2 error
		})
	}
	fake.postBuildFileReturnsOnCall[i] = struct {
		result1 *models.BuildFile
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PatchBuildFile(buildFileID int32, patches []*models.PatchDocument) (*models.BuildFile, error) {
	var patchesCopy []*models.PatchDocument
	if patches != nil {
		patchesCopy = make([]*models.PatchDocument, len(patches))
		copy(patchesCopy, patches)
	}
	fake.patchBuildFileMutex.Lock()
	ret, specificReturn := fake.patchBuildFileReturnsOnCall[len(fake.patchBuildFileArgsForCall)]
	fake.patchBuildFileArgsForCall = append(fake.patchBuildFileArgsForCall, struct {
		buildFileID int32
		patches     []*models.PatchDocument
	}{buildFileID, patchesCopy})
	fake.recordInvocation("PatchBuildFile", []interface{}{buildFileID, patchesCopy})
	fake.patchBuildFileMutex.Unlock()
	if fake.PatchBuildFileStub != nil {
		return fake.PatchBuildFileStub(buildFileID, patches)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.patchBuildFileReturns.result1, fake.patchBuildFileReturns.result2
}

func (fake *FakeClient) PatchBuildFileCallCount() int {
	fake.patchBuildFileMutex.RLock()
	defer fake.patchBuildFileMutex.RUnlock()
	return len(fake.patchBuildFileArgsForCall)
}

func (fake *FakeClient) PatchBuildFileArgsForCall(i int) (int32, []*models.PatchDocument) {
	fake.patchBuildFileMutex.RLock()
	defer fake.patchBuildFileMutex.RUnlock()
	return fake.patchBuildFileArgsForCall[i].buildFileID, fake.patchBuildFileArgsForCall[i].patches
}

func (fake *FakeClient) PatchBuildFileReturns(result1 *models.BuildFile, result2 error) {
	fake.PatchBuildFileStub = nil
	fake.patchBuildFileReturns = struct {
		result1 *models.BuildFile
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PatchBuildFileReturnsOnCall(i int, result1 *models.BuildFile, result2 error) {
	fake.PatchBuildFileStub = nil
	if fake.patchBuildFileReturnsOnCall == nil {
		fake.patchBuildFileReturnsOnCall = make(map[int]struct {
			result1 *models.BuildFile
			result2 error
		})
	}
	fake.patchBuildFileReturnsOnCall[i] = struct {
		result1 *models.BuildFile
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateBuildFileAvailability(buildFileID int32, availability string) (*models.BuildFile, error) {
	fake.updateBuildFileAvailabilityMutex.Lock()
	ret, specificReturn := fake.updateBuildFileAvailabilityReturnsOnCall[len(fake.updateBuildFileAvailabilityArgsForCall)]
	fake.updateBuildFileAvailabilityArgsForCall = append(fake.updateBuildFileAvailabilityArgsForCall, struct {
		buildFileID  int32
		availability string
	}{buildFileID, availability})
	fake.recordInvocation("UpdateBuildFileAvailability", []interface{}{buildFileID, availability})
	fake.updateBuildFileAvailabilityMutex.Unlock()
	if fake.UpdateBuildFileAvailabilityStub != nil {
		return fake.UpdateBuildFileAvailabilityStub(buildFileID, availability)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.updateBuildFileAvailabilityReturns.result1, fake.updateBuildFileAvailabilityReturns.result2
}

func (fake *FakeClient) UpdateBuildFileAvailabilityCallCount() int {
	fake.updateBuildFileAvailabilityMutex.RLock()
	defer fake.updateBuildFileAvailabilityMutex.RUnlock()
	return len(fake.updateBuildFileAvailabilityArgsForCall)
}

func (fake *FakeClient) UpdateBuildFileAvailabilityArgsForCall(i int) (int32, string) {
	fake.updateBuildFileAvailabilityMutex.RLock()
	defer fake.updateBuildFileAvailabilityMutex.RUnlock()
	return fake.updateBuildFileAvailabilityArgsForCall[i].buildFileID, fake.updateBuildFileAvailabilityArgsForCall[i].availability
}

func (fake *FakeClient) UpdateBuildFileAvailabilityReturns(result1 *models.BuildFile, result2 error) {
	fake.UpdateBuildFileAvailabilityStub = nil
	fake.updateBuildFileAvailabilityReturns = struct {
		result1 *models.BuildFile
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateBuildFileAvailabilityReturnsOnCall(i int, result1 *models.BuildFile, result2 error) {
	fake.UpdateBuildFileAvailabilityStub = nil
	if fake.updateBuildFileAvailabilityReturnsOnCall == nil {
		fake.updateBuildFileAvailabilityReturnsOnCall = make(map[int]struct {
			result1 *models.BuildFile
			result2 error
		})
	}
	fake.updateBuildFileAvailabilityReturnsOnCall[i] = struct {
		result1 *models.BuildFile
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RawBuildFile(buildFileID int32) (map[string]interface{}, error) {
	fake.rawBuildFileMutex.Lock()
	ret, specificReturn := fake.rawBuildFileReturnsOnCall[len(fake.rawBuildFileArgsForCall)]
	fake.rawBuildFileArgsForCall = append(fake.rawBuildFileArgsForCall, struct {
		buildFileID int32
	}{buildFileID})
	fake.recordInvocation("RawBuildFile", []interface{}{buildFileID})
	fake.rawBuildFileMutex.Unlock()
	if fake.RawBuildFileStub != nil {
		return fake.RawBuildFileStub(buildFileID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.rawBuildFileReturns.result1, fake.rawBuildFileReturns.result2
}

func (fake *FakeClient) RawBuildFileCallCount() int {
	fake.rawBuildFileMutex.RLock()
	defer fake.rawBuildFileMutex.RUnlock()
	return len(fake.rawBuildFileArgsForCall)
}

func (fake *FakeClient) RawBuildFileArgsForCall(i int) int32 {
	fake.rawBuildFileMutex.RLock()
	defer fake.rawBuildFileMutex.RUnlock()
	return fake.rawBuildFileArgsForCall[i].buildFileID
}

func (fake *FakeClient) RawBuildFileReturns(result1 map[string]interface{}, result2 error) {
	fake.RawBuildFileStub = nil
	fake.rawBuildFileReturns = struct {
		result1 map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RawBuildFileReturnsOnCall(i int, result1 map[string]interface{}, result2 error) {
	fake.RawBuildFileStub = nil
	if fake.rawBuildFileReturnsOnCall == nil {
		fake.rawBuildFileReturnsOnCall = make(map[int]struct {
			result1 map[string]interface{}
			result2 error
		})
	}
	fake.rawBuildFileReturnsOnCall[i] = struct {
		result1 map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Part(partID int32) (*models.Part, error) {
	fake.partMutex.Lock()
	ret, specificReturn := fake.partReturnsOnCall[len(fake.partArgsForCall)]
	fake.partArgsForCall = append(fake.partArgsForCall, struct {
		partID int32
	}{partID})
	fake.recordInvocation("Part", []interface{}{partID})
	fake.partMutex.Unlock()
	if fake.PartStub != nil {
		return fake.PartStub(partID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.partReturns.result1, fake.partReturns.result2
}

func (fake *FakeClient) PartCallCount() int {
	fake.partMutex.RLock()
	defer fake.partMutex.RUnlock()
	return len(fake.partArgsForCall)
}

func (fake *FakeClient) PartArgsForCall(i int) int32 {
	fake.partMutex.RLock()
	defer fake.partMutex.RUnlock()
	return fake.partArgsForCall[i].partID
}

func (fake *FakeClient) PartReturns(result1 *models.Part, result2 error) {
	fake.PartStub = nil
	fake.partReturns = struct {
		result1 *models.Part
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PartReturnsOnCall(i int, result1 *models.Part, result2 error) {
	fake.PartStub = nil
	if fake.partReturnsOnCall == nil {
		fake.partReturnsOnCall = make(map[int]struct {
			result1 *models.Part
			result2 error
		})
	}
	fake.partReturnsOnCall[i] = struct {
		result1 *models.Part
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdatePartAvailability(partID int32, availability string) (*models.Part, error) {
	fake.updatePartAvailabilityMutex.Lock()
	ret, specificReturn := fake.updatePartAvailabilityReturnsOnCall[len(fake.updatePartAvailabilityArgsForCall)]
	fake.updatePartAvailabilityArgsForCall = append(fake.updatePartAvailabilityArgsForCall, struct {
		partID       int32
		availability string
	}{partID, availability})
	fake.recordInvocation("UpdatePartAvailability", []interface{}{partID, availability})
	fake.updatePartAvailabilityMutex.Unlock()
	if fake.UpdatePartAvailabilityStub != nil {
		return fake.UpdatePartAvailabilityStub(partID, availability)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.updatePartAvailabilityReturns.result1, fake.updatePartAvailabilityReturns.result2
}

func (fake *FakeClient) UpdatePartAvailabilityCallCount() int {
	fake.updatePartAvailabilityMutex.RLock()
	defer fake.updatePartAvailabilityMutex.RUnlock()
	return len(fake.updatePartAvailabilityArgsForCall)
}

func (fake *FakeClient) UpdatePartAvailabilityArgsForCall(i int) (int32, string) {
	fake.updatePartAvailabilityMutex.RLock()
	defer fake.updatePartAvailabilityMutex.RUnlock()
	return fake.updatePartAvailabilityArgsForCall[i].partID, fake.updatePartAvailabilityArgsForCall[i].availability
}

func (fake *FakeClient) UpdatePartAvailabilityReturns(result1 *models.Part, result2 error) {
	fake.UpdatePartAvailabilityStub = nil
	fake.updatePartAvailabilityReturns = struct {
		result1 *models.Part
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdatePartAvailabilityReturnsOnCall(i int, result1 *models.Part, result2 error) {
	fake.UpdatePartAvailabilityStub = nil
	if fake.updatePartAvailabilityReturnsOnCall == nil {
		fake.updatePartAvailabilityReturnsOnCall = make(map[int]struct {
			result1 *models.Part
			result2 error
		})
	}
	fake.updatePartAvailabilityReturnsOnCall[i] = struct {
		result1 *models.Part
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PatchPart(partID int32, patches []*models.PatchDocument) (*models.Part, error) {
	var patchesCopy []*models.PatchDocument
	if patches != nil {
		patchesCopy = make([]*models.PatchDocument, len(patches))
		copy(patchesCopy, patches)
	}
	fake.patchPartMutex.Lock()
	ret, specificReturn := fake.patchPartReturnsOnCall[len(fake.patchPartArgsForCall)]
	fake.patchPartArgsForCall = append(fake.patchPartArgsForCall, struct {
		partID  int32
		patches []*models.PatchDocument
	}{partID, patchesCopy})
	fake.recordInvocation("PatchPart", []interface{}{partID, patchesCopy})
	fake.patchPartMutex.Unlock()
	if fake.PatchPartStub != nil {
		return fake.PatchPartStub(partID, patches)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.patchPartReturns.result1, fake.patchPartReturns.result2
}

func (fake *FakeClient) PatchPartCallCount() int {
	fake.patchPartMutex.RLock()
	defer fake.patchPartMutex.RUnlock()
	return len(fake.patchPartArgsForCall)
}

func (fake *FakeClient) PatchPartArgsForCall(i int) (int32, []*models.PatchDocument) {
	fake.patchPartMutex.RLock()
	defer fake.patchPartMutex.RUnlock()
	return fake.patchPartArgsForCall[i].partID, fake.patchPartArgsForCall[i].patches
}

func (fake *FakeClient) PatchPartReturns(result1 *models.Part, result2 error) {
	fake.PatchPartStub = nil
	fake.patchPartReturns = struct {
		result1 *models.Part
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PatchPartReturnsOnCall(i int, result1 *models.Part, result2 error) {
	fake.PatchPartStub = nil
	if fake.patchPartReturnsOnCall == nil {
		fake.patchPartReturnsOnCall = make(map[int]struct {
			result1 *models.Part
			result2 error
		})
	}
	fake.patchPartReturnsOnCall[i] = struct {
		result1 *models.Part
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SimulationOutputs(simulationID int32) (so []*models.SimulationOutput, err error) {
	fake.simulationOutputsMutex.Lock()
	ret, specificReturn := fake.simulationOutputsReturnsOnCall[len(fake.simulationOutputsArgsForCall)]
	fake.simulationOutputsArgsForCall = append(fake.simulationOutputsArgsForCall, struct {
		simulationID int32
	}{simulationID})
	fake.recordInvocation("SimulationOutputs", []interface{}{simulationID})
	fake.simulationOutputsMutex.Unlock()
	if fake.SimulationOutputsStub != nil {
		return fake.SimulationOutputsStub(simulationID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.simulationOutputsReturns.result1, fake.simulationOutputsReturns.result2
}

func (fake *FakeClient) SimulationOutputsCallCount() int {
	fake.simulationOutputsMutex.RLock()
	defer fake.simulationOutputsMutex.RUnlock()
	return len(fake.simulationOutputsArgsForCall)
}

func (fake *FakeClient) SimulationOutputsArgsForCall(i int) int32 {
	fake.simulationOutputsMutex.RLock()
	defer fake.simulationOutputsMutex.RUnlock()
	return fake.simulationOutputsArgsForCall[i].simulationID
}

func (fake *FakeClient) SimulationOutputsReturns(result1 []*models.SimulationOutput, result2 error) {
	fake.SimulationOutputsStub = nil
	fake.simulationOutputsReturns = struct {
		result1 []*models.SimulationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SimulationOutputsReturnsOnCall(i int, result1 []*models.SimulationOutput, result2 error) {
	fake.SimulationOutputsStub = nil
	if fake.simulationOutputsReturnsOnCall == nil {
		fake.simulationOutputsReturnsOnCall = make(map[int]struct {
			result1 []*models.SimulationOutput
			result2 error
		})
	}
	fake.simulationOutputsReturnsOnCall[i] = struct {
		result1 []*models.SimulationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SimulationChildren(simulationID int32) (simulation []*models.Simulation, err error) {
	fake.simulationChildrenMutex.Lock()
	ret, specificReturn := fake.simulationChildrenReturnsOnCall[len(fake.simulationChildrenArgsForCall)]
	fake.simulationChildrenArgsForCall = append(fake.simulationChildrenArgsForCall, struct {
		simulationID int32
	}{simulationID})
	fake.recordInvocation("SimulationChildren", []interface{}{simulationID})
	fake.simulationChildrenMutex.Unlock()
	if fake.SimulationChildrenStub != nil {
		return fake.SimulationChildrenStub(simulationID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.simulationChildrenReturns.result1, fake.simulationChildrenReturns.result2
}

func (fake *FakeClient) SimulationChildrenCallCount() int {
	fake.simulationChildrenMutex.RLock()
	defer fake.simulationChildrenMutex.RUnlock()
	return len(fake.simulationChildrenArgsForCall)
}

func (fake *FakeClient) SimulationChildrenArgsForCall(i int) int32 {
	fake.simulationChildrenMutex.RLock()
	defer fake.simulationChildrenMutex.RUnlock()
	return fake.simulationChildrenArgsForCall[i].simulationID
}

func (fake *FakeClient) SimulationChildrenReturns(result1 []*models.Simulation, result2 error) {
	fake.SimulationChildrenStub = nil
	fake.simulationChildrenReturns = struct {
		result1 []*models.Simulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SimulationChildrenReturnsOnCall(i int, result1 []*models.Simulation, result2 error) {
	fake.SimulationChildrenStub = nil
	if fake.simulationChildrenReturnsOnCall == nil {
		fake.simulationChildrenReturnsOnCall = make(map[int]struct {
			result1 []*models.Simulation
			result2 error
		})
	}
	fake.simulationChildrenReturnsOnCall[i] = struct {
		result1 []*models.Simulation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PartSupportByID(supportID int32) (*models.PartSupport, error) {
	fake.partSupportByIDMutex.Lock()
	ret, specificReturn := fake.partSupportByIDReturnsOnCall[len(fake.partSupportByIDArgsForCall)]
	fake.partSupportByIDArgsForCall = append(fake.partSupportByIDArgsForCall, struct {
		supportID int32
	}{supportID})
	fake.recordInvocation("PartSupportByID", []interface{}{supportID})
	fake.partSupportByIDMutex.Unlock()
	if fake.PartSupportByIDStub != nil {
		return fake.PartSupportByIDStub(supportID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.partSupportByIDReturns.result1, fake.partSupportByIDReturns.result2
}

func (fake *FakeClient) PartSupportByIDCallCount() int {
	fake.partSupportByIDMutex.RLock()
	defer fake.partSupportByIDMutex.RUnlock()
	return len(fake.partSupportByIDArgsForCall)
}

func (fake *FakeClient) PartSupportByIDArgsForCall(i int) int32 {
	fake.partSupportByIDMutex.RLock()
	defer fake.partSupportByIDMutex.RUnlock()
	return fake.partSupportByIDArgsForCall[i].supportID
}

func (fake *FakeClient) PartSupportByIDReturns(result1 *models.PartSupport, result2 error) {
	fake.PartSupportByIDStub = nil
	fake.partSupportByIDReturns = struct {
		result1 *models.PartSupport
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PartSupportByIDReturnsOnCall(i int, result1 *models.PartSupport, result2 error) {
	fake.PartSupportByIDStub = nil
	if fake.partSupportByIDReturnsOnCall == nil {
		fake.partSupportByIDReturnsOnCall = make(map[int]struct {
			result1 *models.PartSupport
			result2 error
		})
	}
	fake.partSupportByIDReturnsOnCall[i] = struct {
		result1 *models.PartSupport
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PatchPartSupport(partID int32, supportID int32, patches []*models.PatchDocument) (*models.PartSupport, error) {
	var patchesCopy []*models.PatchDocument
	if patches != nil {
		patchesCopy = make([]*models.PatchDocument, len(patches))
		copy(patchesCopy, patches)
	}
	fake.patchPartSupportMutex.Lock()
	ret, specificReturn := fake.patchPartSupportReturnsOnCall[len(fake.patchPartSupportArgsForCall)]
	fake.patchPartSupportArgsForCall = append(fake.patchPartSupportArgsForCall, struct {
		partID    int32
		supportID int32
		patches   []*models.PatchDocument
	}{partID, supportID, patchesCopy})
	fake.recordInvocation("PatchPartSupport", []interface{}{partID, supportID, patchesCopy})
	fake.patchPartSupportMutex.Unlock()
	if fake.PatchPartSupportStub != nil {
		return fake.PatchPartSupportStub(partID, supportID, patches)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.patchPartSupportReturns.result1, fake.patchPartSupportReturns.result2
}

func (fake *FakeClient) PatchPartSupportCallCount() int {
	fake.patchPartSupportMutex.RLock()
	defer fake.patchPartSupportMutex.RUnlock()
	return len(fake.patchPartSupportArgsForCall)
}

func (fake *FakeClient) PatchPartSupportArgsForCall(i int) (int32, int32, []*models.PatchDocument) {
	fake.patchPartSupportMutex.RLock()
	defer fake.patchPartSupportMutex.RUnlock()
	return fake.patchPartSupportArgsForCall[i].partID, fake.patchPartSupportArgsForCall[i].supportID, fake.patchPartSupportArgsForCall[i].patches
}

func (fake *FakeClient) PatchPartSupportReturns(result1 *models.PartSupport, result2 error) {
	fake.PatchPartSupportStub = nil
	fake.patchPartSupportReturns = struct {
		result1 *models.PartSupport
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PatchPartSupportReturnsOnCall(i int, result1 *models.PartSupport, result2 error) {
	fake.PatchPartSupportStub = nil
	if fake.patchPartSupportReturnsOnCall == nil {
		fake.patchPartSupportReturnsOnCall = make(map[int]struct {
			result1 *models.PartSupport
			result2 error
		})
	}
	fake.patchPartSupportReturnsOnCall[i] = struct {
		result1 *models.PartSupport
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.simulationsMutex.RLock()
	defer fake.simulationsMutex.RUnlock()
	fake.startSimulationMutex.RLock()
	defer fake.startSimulationMutex.RUnlock()
	fake.thermalSimulationMutex.RLock()
	defer fake.thermalSimulationMutex.RUnlock()
	fake.singleBeadSimulationMutex.RLock()
	defer fake.singleBeadSimulationMutex.RUnlock()
	fake.postAssumedStrainSimulationMutex.RLock()
	defer fake.postAssumedStrainSimulationMutex.RUnlock()
	fake.postPorositySimulationMutex.RLock()
	defer fake.postPorositySimulationMutex.RUnlock()
	fake.postScanPatternSimulationMutex.RLock()
	defer fake.postScanPatternSimulationMutex.RUnlock()
	fake.postSingleBeadSimulationMutex.RLock()
	defer fake.postSingleBeadSimulationMutex.RUnlock()
	fake.postThermalSimulationMutex.RLock()
	defer fake.postThermalSimulationMutex.RUnlock()
	fake.machineMutex.RLock()
	defer fake.machineMutex.RUnlock()
	fake.materialMutex.RLock()
	defer fake.materialMutex.RUnlock()
	fake.simulationMutex.RLock()
	defer fake.simulationMutex.RUnlock()
	fake.scanPatternSimulationMutex.RLock()
	defer fake.scanPatternSimulationMutex.RUnlock()
	fake.assumedStrainSimulationMutex.RLock()
	defer fake.assumedStrainSimulationMutex.RUnlock()
	fake.porositySimulationMutex.RLock()
	defer fake.porositySimulationMutex.RUnlock()
	fake.postLogMutex.RLock()
	defer fake.postLogMutex.RUnlock()
	fake.postLogWithObjectMutex.RLock()
	defer fake.postLogWithObjectMutex.RUnlock()
	fake.postLogInfoMutex.RLock()
	defer fake.postLogInfoMutex.RUnlock()
	fake.postLogWarnMutex.RLock()
	defer fake.postLogWarnMutex.RUnlock()
	fake.postLogErrorMutex.RLock()
	defer fake.postLogErrorMutex.RUnlock()
	fake.patchSimulationMutex.RLock()
	defer fake.patchSimulationMutex.RUnlock()
	fake.multiPatchSimulationMutex.RLock()
	defer fake.multiPatchSimulationMutex.RUnlock()
	fake.postSimulationActivityMutex.RLock()
	defer fake.postSimulationActivityMutex.RUnlock()
	fake.simulationActivityByActivityIDMutex.RLock()
	defer fake.simulationActivityByActivityIDMutex.RUnlock()
	fake.putSimulationActivityMutex.RLock()
	defer fake.putSimulationActivityMutex.RUnlock()
	fake.patchSimulationActivityMutex.RLock()
	defer fake.patchSimulationActivityMutex.RUnlock()
	fake.addSimulationOutputMutex.RLock()
	defer fake.addSimulationOutputMutex.RUnlock()
	fake.updateSimulationStatusMutex.RLock()
	defer fake.updateSimulationStatusMutex.RUnlock()
	fake.rawSimulationMutex.RLock()
	defer fake.rawSimulationMutex.RUnlock()
	fake.buildFilesMutex.RLock()
	defer fake.buildFilesMutex.RUnlock()
	fake.buildFileMutex.RLock()
	defer fake.buildFileMutex.RUnlock()
	fake.postBuildFileMutex.RLock()
	defer fake.postBuildFileMutex.RUnlock()
	fake.patchBuildFileMutex.RLock()
	defer fake.patchBuildFileMutex.RUnlock()
	fake.updateBuildFileAvailabilityMutex.RLock()
	defer fake.updateBuildFileAvailabilityMutex.RUnlock()
	fake.rawBuildFileMutex.RLock()
	defer fake.rawBuildFileMutex.RUnlock()
	fake.partMutex.RLock()
	defer fake.partMutex.RUnlock()
	fake.updatePartAvailabilityMutex.RLock()
	defer fake.updatePartAvailabilityMutex.RUnlock()
	fake.patchPartMutex.RLock()
	defer fake.patchPartMutex.RUnlock()
	fake.simulationOutputsMutex.RLock()
	defer fake.simulationOutputsMutex.RUnlock()
	fake.simulationChildrenMutex.RLock()
	defer fake.simulationChildrenMutex.RUnlock()
	fake.partSupportByIDMutex.RLock()
	defer fake.partSupportByIDMutex.RUnlock()
	fake.patchPartSupportMutex.RLock()
	defer fake.patchPartSupportMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ simulation.Client = new(FakeClient)
