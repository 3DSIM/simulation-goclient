// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// BuildFile parameters associated with a build file used by machine manufacturers
// swagger:model BuildFile
type BuildFile struct {

	// true if this build file has been archived, false otherwise
	// Required: true
	Archived *bool `json:"archived"`

	// Describes the availabity of the build file. Uploaded - the build file has been uploaded. Processing - the build file is being processed.  Available - the build file was processed successfully and can be used in simulations.  Error - an error occurred and the build file is not available for simulations.
	// Required: true
	Availability *string `json:"availability"`

	// folder containing build file contents, multiple files may be contained within the folder
	BuildFileLocation string `json:"buildFileLocation,omitempty"`

	// List of supports for this buildfile
	BuildFileSupports []*BuildFileSupport `json:"buildFileSupports"`

	// time stamp assigned when this build file is created
	CreatedAt strfmt.DateTime `json:"createdAt,omitempty"`

	// name of user or entity that created this build file
	CreatedBy string `json:"createdBy,omitempty"`

	// a description of this build file
	Description string `json:"description,omitempty"`

	// reason build file failed to be processed, if any
	ErrorReason string `json:"errorReason,omitempty"`

	// creation time stamp from original build file
	FileCreatedDate *strfmt.DateTime `json:"fileCreatedDate,omitempty"`

	// version of this build file
	FileVersion string `json:"fileVersion,omitempty"`

	// internally assigned identifier for this build file
	// Required: true
	ID *int32 `json:"id"`

	// job number associated with this build file
	JobID string `json:"jobId,omitempty"`

	// job name associated with this build file
	JobName string `json:"jobName,omitempty"`

	// time stamp of last change made to this build file
	LastModifiedAt strfmt.DateTime `json:"lastModifiedAt,omitempty"`

	// name of user or entity that last changed this build file
	LastModifiedBy string `json:"lastModifiedBy,omitempty"`

	// thickness of powder deposition layer in meters
	LayerThickness float64 `json:"layerThickness,omitempty"`

	// length (in meters) of the longest fill scan vector in the scan pattern. Defaults to null
	LongestScanVectorLength *float64 `json:"longestScanVectorLength,omitempty"`

	// type of machine associated with this build file
	// Required: true
	MachineType *string `json:"machineType"`

	// material to use when performing simulation
	MaterialType string `json:"materialType,omitempty"`

	// a name given to this build file
	// Required: true
	Name *string `json:"name"`

	// number of powder deposition layers
	NumberOfLayers int32 `json:"numberOfLayers,omitempty"`

	// identifier for organization this build file belongs to
	OrganizationID int32 `json:"organizationId,omitempty"`

	// x position of original part location in millimeters
	OriginalX float64 `json:"originalX,omitempty"`

	// y position of original part location in millimeters
	OriginalY float64 `json:"originalY,omitempty"`

	// z position of original part location in millimeters
	OriginalZ float64 `json:"originalZ,omitempty"`

	// maximum part dimension in X direction
	// Required: true
	SizeX *float64 `json:"sizeX"`

	// maximum part dimension in Y direction
	// Required: true
	SizeY *float64 `json:"sizeY"`

	// maximum part dimension in Z direction
	// Required: true
	SizeZ *float64 `json:"sizeZ"`

	// path to ZIP file containing scan pattern information for each powder deposition layer
	SliceZipFileLocation string `json:"sliceZipFileLocation,omitempty"`

	// path to STL file describing the part geometry
	StlFileLocation string `json:"stlFileLocation,omitempty"`

	// path to support model file relative to buildFileLocation
	SupportModelFileLocation string `json:"supportModelFileLocation,omitempty"`

	// a comma delimited list of tags assigned to this build file
	Tags []string `json:"tags"`

	// total distance laser travels when building the part
	TotalScanDistance float64 `json:"totalScanDistance,omitempty"`

	// path to uploaded zip file containing build file components, relative to s3 part bucket
	// Required: true
	UploadFileLocation *string `json:"uploadFileLocation"`
}

// Validate validates this build file
func (m *BuildFile) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateArchived(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateAvailability(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateBuildFileSupports(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateMachineType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSizeX(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSizeY(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSizeZ(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTags(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateUploadFileLocation(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BuildFile) validateArchived(formats strfmt.Registry) error {

	if err := validate.Required("archived", "body", m.Archived); err != nil {
		return err
	}

	return nil
}

var buildFileTypeAvailabilityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Uploaded","Processing","Available","Error"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		buildFileTypeAvailabilityPropEnum = append(buildFileTypeAvailabilityPropEnum, v)
	}
}

const (
	// BuildFileAvailabilityUploaded captures enum value "Uploaded"
	BuildFileAvailabilityUploaded string = "Uploaded"
	// BuildFileAvailabilityProcessing captures enum value "Processing"
	BuildFileAvailabilityProcessing string = "Processing"
	// BuildFileAvailabilityAvailable captures enum value "Available"
	BuildFileAvailabilityAvailable string = "Available"
	// BuildFileAvailabilityError captures enum value "Error"
	BuildFileAvailabilityError string = "Error"
)

// prop value enum
func (m *BuildFile) validateAvailabilityEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, buildFileTypeAvailabilityPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *BuildFile) validateAvailability(formats strfmt.Registry) error {

	if err := validate.Required("availability", "body", m.Availability); err != nil {
		return err
	}

	// value enum
	if err := m.validateAvailabilityEnum("availability", "body", *m.Availability); err != nil {
		return err
	}

	return nil
}

func (m *BuildFile) validateBuildFileSupports(formats strfmt.Registry) error {

	if swag.IsZero(m.BuildFileSupports) { // not required
		return nil
	}

	for i := 0; i < len(m.BuildFileSupports); i++ {

		if swag.IsZero(m.BuildFileSupports[i]) { // not required
			continue
		}

		if m.BuildFileSupports[i] != nil {

			if err := m.BuildFileSupports[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("buildFileSupports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BuildFile) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

var buildFileTypeMachineTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["AdditiveIndustries","Renishaw","SLM","ThreeDSystems","EOS","Trumpf","Sisma","HB3D"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		buildFileTypeMachineTypePropEnum = append(buildFileTypeMachineTypePropEnum, v)
	}
}

const (
	// BuildFileMachineTypeAdditiveIndustries captures enum value "AdditiveIndustries"
	BuildFileMachineTypeAdditiveIndustries string = "AdditiveIndustries"
	// BuildFileMachineTypeRenishaw captures enum value "Renishaw"
	BuildFileMachineTypeRenishaw string = "Renishaw"
	// BuildFileMachineTypeSLM captures enum value "SLM"
	BuildFileMachineTypeSLM string = "SLM"
	// BuildFileMachineTypeThreeDSystems captures enum value "ThreeDSystems"
	BuildFileMachineTypeThreeDSystems string = "ThreeDSystems"
	// BuildFileMachineTypeEOS captures enum value "EOS"
	BuildFileMachineTypeEOS string = "EOS"
	// BuildFileMachineTypeTrumpf captures enum value "Trumpf"
	BuildFileMachineTypeTrumpf string = "Trumpf"
	// BuildFileMachineTypeSisma captures enum value "Sisma"
	BuildFileMachineTypeSisma string = "Sisma"
	// BuildFileMachineTypeHB3D captures enum value "HB3D"
	BuildFileMachineTypeHB3D string = "HB3D"
)

// prop value enum
func (m *BuildFile) validateMachineTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, buildFileTypeMachineTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *BuildFile) validateMachineType(formats strfmt.Registry) error {

	if err := validate.Required("machineType", "body", m.MachineType); err != nil {
		return err
	}

	// value enum
	if err := m.validateMachineTypeEnum("machineType", "body", *m.MachineType); err != nil {
		return err
	}

	return nil
}

func (m *BuildFile) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *BuildFile) validateSizeX(formats strfmt.Registry) error {

	if err := validate.Required("sizeX", "body", m.SizeX); err != nil {
		return err
	}

	return nil
}

func (m *BuildFile) validateSizeY(formats strfmt.Registry) error {

	if err := validate.Required("sizeY", "body", m.SizeY); err != nil {
		return err
	}

	return nil
}

func (m *BuildFile) validateSizeZ(formats strfmt.Registry) error {

	if err := validate.Required("sizeZ", "body", m.SizeZ); err != nil {
		return err
	}

	return nil
}

func (m *BuildFile) validateTags(formats strfmt.Registry) error {

	if swag.IsZero(m.Tags) { // not required
		return nil
	}

	return nil
}

func (m *BuildFile) validateUploadFileLocation(formats strfmt.Registry) error {

	if err := validate.Required("uploadFileLocation", "body", m.UploadFileLocation); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BuildFile) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BuildFile) UnmarshalBinary(b []byte) error {
	var res BuildFile
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
