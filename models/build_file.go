package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// BuildFile parameters associated with a build file used by machine manufacturers
// swagger:model BuildFile
type BuildFile struct {

	// true if this build file has been archived, false otherwise
	// Required: true
	Archived *bool `json:"archived"`

	// indicates availability of this build file, valid values: Uploaded, Processing, Available, Error
	// Required: true
	Availability *string `json:"availability"`

	// folder containing build file contents, multiple files may be contained within the folder
	// Required: true
	BuildFileLocation *string `json:"buildFileLocation"`

	// time stamp assigned when this build file is created
	CreatedAt strfmt.DateTime `json:"createdAt,omitempty"`

	// name of user or entity that created this build file
	CreatedBy string `json:"createdBy,omitempty"`

	// a description of this build file
	Description string `json:"description,omitempty"`

	// reason build file failed to be processed, if any
	ErrorReason string `json:"errorReason,omitempty"`

	// creation time stamp from original build file
	FileCreatedDate strfmt.DateTime `json:"fileCreatedDate,omitempty"`

	// version of this build file
	FileVersion string `json:"fileVersion,omitempty"`

	// internally assigned identifier for this build file
	ID int64 `json:"id,omitempty"`

	// job number associated with this build file
	JobID string `json:"jobId,omitempty"`

	// job name associated with this build file
	JobName string `json:"jobName,omitempty"`

	// time stamp of last change made to this build file
	LastModifiedAt strfmt.DateTime `json:"lastModifiedAt,omitempty"`

	// name of user or entity that last changed this build file
	LastModifiedBy string `json:"lastModifiedBy,omitempty"`

	// thickness of powder deposition layer in meters
	LayerThickness float64 `json:"layerThickness,omitempty"`

	// type of machine associated with this build file, valid values: AdditiveIndustries, Renishaw, SLM, ThreeDSystems
	// Required: true
	MachineType *string `json:"machineType"`

	// material to use when performing simulation
	MaterialType string `json:"materialType,omitempty"`

	// a name given to this build file
	// Required: true
	Name *string `json:"name"`

	// number of powder deposition layers
	NumberOfLayers int64 `json:"numberOfLayers,omitempty"`

	// identifier for organization this build file belongs to
	OrganizationID int64 `json:"organizationId,omitempty"`

	// maximum part dimension in X direction
	// Required: true
	SizeX *float64 `json:"sizeX"`

	// maximum part dimension in Y direction
	// Required: true
	SizeY *float64 `json:"sizeY"`

	// maximum part dimension in Z direction
	// Required: true
	SizeZ *float64 `json:"sizeZ"`

	// path to ZIP file containing scan pattern information for each powder deposition layer
	SliceZipFileLocation string `json:"sliceZipFileLocation,omitempty"`

	// path to STL file describing the part geometry
	StlFileLocation string `json:"stlFileLocation,omitempty"`

	// a comma delimited list of tags assigned to this build file
	Tags []string `json:"tags"`

	// total distance laser travels when building the part
	TotalScanDistance float64 `json:"totalScanDistance,omitempty"`
}

// Validate validates this build file
func (m *BuildFile) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateArchived(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateAvailability(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateBuildFileLocation(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateMachineType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSizeX(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSizeY(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSizeZ(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTags(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BuildFile) validateArchived(formats strfmt.Registry) error {

	if err := validate.Required("archived", "body", m.Archived); err != nil {
		return err
	}

	return nil
}

func (m *BuildFile) validateAvailability(formats strfmt.Registry) error {

	if err := validate.Required("availability", "body", m.Availability); err != nil {
		return err
	}

	return nil
}

func (m *BuildFile) validateBuildFileLocation(formats strfmt.Registry) error {

	if err := validate.Required("buildFileLocation", "body", m.BuildFileLocation); err != nil {
		return err
	}

	return nil
}

func (m *BuildFile) validateMachineType(formats strfmt.Registry) error {

	if err := validate.Required("machineType", "body", m.MachineType); err != nil {
		return err
	}

	return nil
}

func (m *BuildFile) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *BuildFile) validateSizeX(formats strfmt.Registry) error {

	if err := validate.Required("sizeX", "body", m.SizeX); err != nil {
		return err
	}

	return nil
}

func (m *BuildFile) validateSizeY(formats strfmt.Registry) error {

	if err := validate.Required("sizeY", "body", m.SizeY); err != nil {
		return err
	}

	return nil
}

func (m *BuildFile) validateSizeZ(formats strfmt.Registry) error {

	if err := validate.Required("sizeZ", "body", m.SizeZ); err != nil {
		return err
	}

	return nil
}

func (m *BuildFile) validateTags(formats strfmt.Registry) error {

	if swag.IsZero(m.Tags) { // not required
		return nil
	}

	return nil
}
