// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// MicrostructureSensor Describes a cubic volume in which the microstructure will be evaluated
// swagger:model MicrostructureSensor
type MicrostructureSensor struct {

	// Cooling rate of material in kelvin/sec. Only used when userProvidedThermalData is true on the simulation model.
	CoolingRate float64 `json:"coolingRate,omitempty"`

	// id
	ID int32 `json:"id,omitempty"`

	// User provided name of this sensor
	// Required: true
	Label *string `json:"label"`

	// Depth of melt pool in meters. Only used when userProvidedThermalData is true on the simulation model.
	MeltPoolDepth float64 `json:"meltPoolDepth,omitempty"`

	// Width of melt pool in meters. Only used when userProvidedThermalData is true on the simulation model.
	MeltPoolWidth float64 `json:"meltPoolWidth,omitempty"`

	// Length of an edge of the sensor cube, 0.0001 to 0.001 meters
	// Required: true
	// Maximum: 0.001
	// Minimum: 0.0001
	SensorDimensionLength *float64 `json:"sensorDimensionLength"`

	// X coordinate of center of the sensor volume in meters
	// Required: true
	SensorX *float64 `json:"sensorX"`

	// Y coordinate of center of the sensor volume in meters
	// Required: true
	SensorY *float64 `json:"sensorY"`

	// Z coordinate of center of the sensor volume in meters
	// Required: true
	SensorZ *float64 `json:"sensorZ"`

	// ID of simulation this sensor belongs to
	// Required: true
	SimulationID *int32 `json:"simulationId"`

	// Thermal gradient in kelvin/meter. Only used when userProvidedThermalData is true on the simulation model.
	ThermalGradient float64 `json:"thermalGradient,omitempty"`
}

// Validate validates this microstructure sensor
func (m *MicrostructureSensor) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLabel(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSensorDimensionLength(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSensorX(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSensorY(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSensorZ(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSimulationID(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MicrostructureSensor) validateLabel(formats strfmt.Registry) error {

	if err := validate.Required("label", "body", m.Label); err != nil {
		return err
	}

	return nil
}

func (m *MicrostructureSensor) validateSensorDimensionLength(formats strfmt.Registry) error {

	if err := validate.Required("sensorDimensionLength", "body", m.SensorDimensionLength); err != nil {
		return err
	}

	if err := validate.Minimum("sensorDimensionLength", "body", float64(*m.SensorDimensionLength), 0.0001, false); err != nil {
		return err
	}

	if err := validate.Maximum("sensorDimensionLength", "body", float64(*m.SensorDimensionLength), 0.001, false); err != nil {
		return err
	}

	return nil
}

func (m *MicrostructureSensor) validateSensorX(formats strfmt.Registry) error {

	if err := validate.Required("sensorX", "body", m.SensorX); err != nil {
		return err
	}

	return nil
}

func (m *MicrostructureSensor) validateSensorY(formats strfmt.Registry) error {

	if err := validate.Required("sensorY", "body", m.SensorY); err != nil {
		return err
	}

	return nil
}

func (m *MicrostructureSensor) validateSensorZ(formats strfmt.Registry) error {

	if err := validate.Required("sensorZ", "body", m.SensorZ); err != nil {
		return err
	}

	return nil
}

func (m *MicrostructureSensor) validateSimulationID(formats strfmt.Registry) error {

	if err := validate.Required("simulationId", "body", m.SimulationID); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MicrostructureSensor) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MicrostructureSensor) UnmarshalBinary(b []byte) error {
	var res MicrostructureSensor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
