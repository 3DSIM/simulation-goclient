// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// MicrostructureSimulationParameters microstructure simulation parameters
// swagger:model MicrostructureSimulationParameters
type MicrostructureSimulationParameters struct {

	// Must be between 0.00001 to 0.001 meters
	// Required: true
	// Maximum: 0.001
	// Minimum: 1e-05
	HatchSpacing *float64 `json:"hatchSpacing"`

	// Heater temperature in degrees kelvin, aka baseplate temperature
	// Maximum: 1000
	// Minimum: 0
	HeaterTemperature *float64 `json:"heaterTemperature,omitempty"`

	// Must be between 10 to 1000 watts
	// Required: true
	// Maximum: 1000
	// Minimum: 10
	LaserWattage *float64 `json:"laserWattage"`

	// Must be between 0 to 180 degrees
	// Required: true
	// Maximum: 180
	// Minimum: 0
	LayerRotationAngle *float64 `json:"layerRotationAngle"`

	// Must be between 0.00001 to 0.0001 meters
	// Required: true
	// Maximum: 0.0001
	// Minimum: 1e-05
	LayerThickness *float64 `json:"layerThickness"`

	// List of points within the part where the microstructure will be evaluated
	// Required: true
	MicrostructurePoints []*MicrostructurePoint `json:"microstructurePoints"`

	// Seed value used for random number generation. If not provided it will be auto-generated.
	RandomSeed int32 `json:"randomSeed,omitempty"`

	// Must be between 0.01 to 10 meters/second
	// Required: true
	// Maximum: 10
	// Minimum: 0.01
	ScanSpeed *float64 `json:"scanSpeed"`

	// Minimum temperature above which microstructure changes will be evaluated
	SensorMinimumTemperature float64 `json:"sensorMinimumTemperature,omitempty"`

	// Must be between 0.001 to 0.1 meters
	// Required: true
	// Maximum: 0.1
	// Minimum: 0.001
	SlicingStripeWidth *float64 `json:"slicingStripeWidth"`

	// Must be between 0 to 180 degrees
	// Required: true
	// Maximum: 180
	// Minimum: 0
	StartingLayerAngle *float64 `json:"startingLayerAngle"`
}

// Validate validates this microstructure simulation parameters
func (m *MicrostructureSimulationParameters) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHatchSpacing(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateHeaterTemperature(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLaserWattage(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLayerRotationAngle(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLayerThickness(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateMicrostructurePoints(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateScanSpeed(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSlicingStripeWidth(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateStartingLayerAngle(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MicrostructureSimulationParameters) validateHatchSpacing(formats strfmt.Registry) error {

	if err := validate.Required("hatchSpacing", "body", m.HatchSpacing); err != nil {
		return err
	}

	if err := validate.Minimum("hatchSpacing", "body", float64(*m.HatchSpacing), 1e-05, false); err != nil {
		return err
	}

	if err := validate.Maximum("hatchSpacing", "body", float64(*m.HatchSpacing), 0.001, false); err != nil {
		return err
	}

	return nil
}

func (m *MicrostructureSimulationParameters) validateHeaterTemperature(formats strfmt.Registry) error {

	if swag.IsZero(m.HeaterTemperature) { // not required
		return nil
	}

	if err := validate.Minimum("heaterTemperature", "body", float64(*m.HeaterTemperature), 0, false); err != nil {
		return err
	}

	if err := validate.Maximum("heaterTemperature", "body", float64(*m.HeaterTemperature), 1000, false); err != nil {
		return err
	}

	return nil
}

func (m *MicrostructureSimulationParameters) validateLaserWattage(formats strfmt.Registry) error {

	if err := validate.Required("laserWattage", "body", m.LaserWattage); err != nil {
		return err
	}

	if err := validate.Minimum("laserWattage", "body", float64(*m.LaserWattage), 10, false); err != nil {
		return err
	}

	if err := validate.Maximum("laserWattage", "body", float64(*m.LaserWattage), 1000, false); err != nil {
		return err
	}

	return nil
}

func (m *MicrostructureSimulationParameters) validateLayerRotationAngle(formats strfmt.Registry) error {

	if err := validate.Required("layerRotationAngle", "body", m.LayerRotationAngle); err != nil {
		return err
	}

	if err := validate.Minimum("layerRotationAngle", "body", float64(*m.LayerRotationAngle), 0, false); err != nil {
		return err
	}

	if err := validate.Maximum("layerRotationAngle", "body", float64(*m.LayerRotationAngle), 180, false); err != nil {
		return err
	}

	return nil
}

func (m *MicrostructureSimulationParameters) validateLayerThickness(formats strfmt.Registry) error {

	if err := validate.Required("layerThickness", "body", m.LayerThickness); err != nil {
		return err
	}

	if err := validate.Minimum("layerThickness", "body", float64(*m.LayerThickness), 1e-05, false); err != nil {
		return err
	}

	if err := validate.Maximum("layerThickness", "body", float64(*m.LayerThickness), 0.0001, false); err != nil {
		return err
	}

	return nil
}

func (m *MicrostructureSimulationParameters) validateMicrostructurePoints(formats strfmt.Registry) error {

	if err := validate.Required("microstructurePoints", "body", m.MicrostructurePoints); err != nil {
		return err
	}

	for i := 0; i < len(m.MicrostructurePoints); i++ {

		if swag.IsZero(m.MicrostructurePoints[i]) { // not required
			continue
		}

		if m.MicrostructurePoints[i] != nil {

			if err := m.MicrostructurePoints[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("microstructurePoints" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MicrostructureSimulationParameters) validateScanSpeed(formats strfmt.Registry) error {

	if err := validate.Required("scanSpeed", "body", m.ScanSpeed); err != nil {
		return err
	}

	if err := validate.Minimum("scanSpeed", "body", float64(*m.ScanSpeed), 0.01, false); err != nil {
		return err
	}

	if err := validate.Maximum("scanSpeed", "body", float64(*m.ScanSpeed), 10, false); err != nil {
		return err
	}

	return nil
}

func (m *MicrostructureSimulationParameters) validateSlicingStripeWidth(formats strfmt.Registry) error {

	if err := validate.Required("slicingStripeWidth", "body", m.SlicingStripeWidth); err != nil {
		return err
	}

	if err := validate.Minimum("slicingStripeWidth", "body", float64(*m.SlicingStripeWidth), 0.001, false); err != nil {
		return err
	}

	if err := validate.Maximum("slicingStripeWidth", "body", float64(*m.SlicingStripeWidth), 0.1, false); err != nil {
		return err
	}

	return nil
}

func (m *MicrostructureSimulationParameters) validateStartingLayerAngle(formats strfmt.Registry) error {

	if err := validate.Required("startingLayerAngle", "body", m.StartingLayerAngle); err != nil {
		return err
	}

	if err := validate.Minimum("startingLayerAngle", "body", float64(*m.StartingLayerAngle), 0, false); err != nil {
		return err
	}

	if err := validate.Maximum("startingLayerAngle", "body", float64(*m.StartingLayerAngle), 180, false); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MicrostructureSimulationParameters) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MicrostructureSimulationParameters) UnmarshalBinary(b []byte) error {
	var res MicrostructureSimulationParameters
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
