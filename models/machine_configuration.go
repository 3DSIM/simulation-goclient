// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// MachineConfiguration machine configuration
// swagger:model MachineConfiguration
type MachineConfiguration struct {

	// diameter of laser beam in meters
	// Required: true
	// Maximum: 0.0001
	// Minimum: 0
	BeamDiameter *float64 `json:"beamDiameter"`

	// ratio between cooling to scanning time
	// Required: true
	// Maximum: 100
	// Minimum: 0
	CoolingToScanningTimeIncrementRatio *float64 `json:"coolingToScanningTimeIncrementRatio"`

	// created time stamp, set server-side, read only field
	// Required: true
	Created *strfmt.DateTime `json:"created"`

	// creating user, set server-side, read only field
	// Required: true
	CreatedBy *string `json:"createdBy"`

	// distance between hatch lines in meters
	// Required: true
	// Maximum: 0.002
	// Minimum: 1e-05
	HatchSpacing *float64 `json:"hatchSpacing"`

	// heater temperature in degrees kelvin
	// Required: true
	// Maximum: 1000
	// Minimum: 0
	HeaterTemperature *float64 `json:"heaterTemperature"`

	// machine configuration identifier
	ID int32 `json:"id,omitempty"`

	// laser power in watts
	// Required: true
	// Maximum: 1000
	// Minimum: 0
	LaserWattage *float64 `json:"laserWattage"`

	// laser light wavelength in meters
	// Required: true
	// Maximum: 1e-05
	// Minimum: 0
	LaserWaveLength *float64 `json:"laserWaveLength"`

	// delay time between layers, stored in seconds
	// Required: true
	// Maximum: 60
	// Minimum: 0
	LayerDelay *float64 `json:"layerDelay"`

	// machine identifier for this machine configuration
	// Required: true
	MachineID *int32 `json:"machineId"`

	// delay time between scan lines, stored in miliseconds
	// Required: true
	// Maximum: 100
	// Minimum: 0
	ScanLineDelay *float64 `json:"scanLineDelay"`

	// speed at which laser travels in meters per second
	// Required: true
	// Maximum: 10
	// Minimum: 0.01
	ScanSpeed *float64 `json:"scanSpeed"`

	// calculation time interval in seconds
	// Required: true
	// Maximum: 10
	// Minimum: 0
	TimeDiscretizationDuringScanning *float64 `json:"timeDiscretizationDuringScanning"`

	// cooling time prior to deposition of next powder layer in seconds
	// Required: true
	// Maximum: 10
	// Minimum: 0
	TotalCoolingTime *float64 `json:"totalCoolingTime"`
}

// Validate validates this machine configuration
func (m *MachineConfiguration) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBeamDiameter(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCoolingToScanningTimeIncrementRatio(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCreated(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCreatedBy(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateHatchSpacing(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateHeaterTemperature(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLaserWattage(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLaserWaveLength(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLayerDelay(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateMachineID(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateScanLineDelay(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateScanSpeed(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTimeDiscretizationDuringScanning(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTotalCoolingTime(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MachineConfiguration) validateBeamDiameter(formats strfmt.Registry) error {

	if err := validate.Required("beamDiameter", "body", m.BeamDiameter); err != nil {
		return err
	}

	if err := validate.Minimum("beamDiameter", "body", float64(*m.BeamDiameter), 0, false); err != nil {
		return err
	}

	if err := validate.Maximum("beamDiameter", "body", float64(*m.BeamDiameter), 0.0001, false); err != nil {
		return err
	}

	return nil
}

func (m *MachineConfiguration) validateCoolingToScanningTimeIncrementRatio(formats strfmt.Registry) error {

	if err := validate.Required("coolingToScanningTimeIncrementRatio", "body", m.CoolingToScanningTimeIncrementRatio); err != nil {
		return err
	}

	if err := validate.Minimum("coolingToScanningTimeIncrementRatio", "body", float64(*m.CoolingToScanningTimeIncrementRatio), 0, false); err != nil {
		return err
	}

	if err := validate.Maximum("coolingToScanningTimeIncrementRatio", "body", float64(*m.CoolingToScanningTimeIncrementRatio), 100, false); err != nil {
		return err
	}

	return nil
}

func (m *MachineConfiguration) validateCreated(formats strfmt.Registry) error {

	if err := validate.Required("created", "body", m.Created); err != nil {
		return err
	}

	return nil
}

func (m *MachineConfiguration) validateCreatedBy(formats strfmt.Registry) error {

	if err := validate.Required("createdBy", "body", m.CreatedBy); err != nil {
		return err
	}

	return nil
}

func (m *MachineConfiguration) validateHatchSpacing(formats strfmt.Registry) error {

	if err := validate.Required("hatchSpacing", "body", m.HatchSpacing); err != nil {
		return err
	}

	if err := validate.Minimum("hatchSpacing", "body", float64(*m.HatchSpacing), 1e-05, false); err != nil {
		return err
	}

	if err := validate.Maximum("hatchSpacing", "body", float64(*m.HatchSpacing), 0.002, false); err != nil {
		return err
	}

	return nil
}

func (m *MachineConfiguration) validateHeaterTemperature(formats strfmt.Registry) error {

	if err := validate.Required("heaterTemperature", "body", m.HeaterTemperature); err != nil {
		return err
	}

	if err := validate.Minimum("heaterTemperature", "body", float64(*m.HeaterTemperature), 0, false); err != nil {
		return err
	}

	if err := validate.Maximum("heaterTemperature", "body", float64(*m.HeaterTemperature), 1000, false); err != nil {
		return err
	}

	return nil
}

func (m *MachineConfiguration) validateLaserWattage(formats strfmt.Registry) error {

	if err := validate.Required("laserWattage", "body", m.LaserWattage); err != nil {
		return err
	}

	if err := validate.Minimum("laserWattage", "body", float64(*m.LaserWattage), 0, false); err != nil {
		return err
	}

	if err := validate.Maximum("laserWattage", "body", float64(*m.LaserWattage), 1000, false); err != nil {
		return err
	}

	return nil
}

func (m *MachineConfiguration) validateLaserWaveLength(formats strfmt.Registry) error {

	if err := validate.Required("laserWaveLength", "body", m.LaserWaveLength); err != nil {
		return err
	}

	if err := validate.Minimum("laserWaveLength", "body", float64(*m.LaserWaveLength), 0, false); err != nil {
		return err
	}

	if err := validate.Maximum("laserWaveLength", "body", float64(*m.LaserWaveLength), 1e-05, false); err != nil {
		return err
	}

	return nil
}

func (m *MachineConfiguration) validateLayerDelay(formats strfmt.Registry) error {

	if err := validate.Required("layerDelay", "body", m.LayerDelay); err != nil {
		return err
	}

	if err := validate.Minimum("layerDelay", "body", float64(*m.LayerDelay), 0, false); err != nil {
		return err
	}

	if err := validate.Maximum("layerDelay", "body", float64(*m.LayerDelay), 60, false); err != nil {
		return err
	}

	return nil
}

func (m *MachineConfiguration) validateMachineID(formats strfmt.Registry) error {

	if err := validate.Required("machineId", "body", m.MachineID); err != nil {
		return err
	}

	return nil
}

func (m *MachineConfiguration) validateScanLineDelay(formats strfmt.Registry) error {

	if err := validate.Required("scanLineDelay", "body", m.ScanLineDelay); err != nil {
		return err
	}

	if err := validate.Minimum("scanLineDelay", "body", float64(*m.ScanLineDelay), 0, false); err != nil {
		return err
	}

	if err := validate.Maximum("scanLineDelay", "body", float64(*m.ScanLineDelay), 100, false); err != nil {
		return err
	}

	return nil
}

func (m *MachineConfiguration) validateScanSpeed(formats strfmt.Registry) error {

	if err := validate.Required("scanSpeed", "body", m.ScanSpeed); err != nil {
		return err
	}

	if err := validate.Minimum("scanSpeed", "body", float64(*m.ScanSpeed), 0.01, false); err != nil {
		return err
	}

	if err := validate.Maximum("scanSpeed", "body", float64(*m.ScanSpeed), 10, false); err != nil {
		return err
	}

	return nil
}

func (m *MachineConfiguration) validateTimeDiscretizationDuringScanning(formats strfmt.Registry) error {

	if err := validate.Required("timeDiscretizationDuringScanning", "body", m.TimeDiscretizationDuringScanning); err != nil {
		return err
	}

	if err := validate.Minimum("timeDiscretizationDuringScanning", "body", float64(*m.TimeDiscretizationDuringScanning), 0, false); err != nil {
		return err
	}

	if err := validate.Maximum("timeDiscretizationDuringScanning", "body", float64(*m.TimeDiscretizationDuringScanning), 10, false); err != nil {
		return err
	}

	return nil
}

func (m *MachineConfiguration) validateTotalCoolingTime(formats strfmt.Registry) error {

	if err := validate.Required("totalCoolingTime", "body", m.TotalCoolingTime); err != nil {
		return err
	}

	if err := validate.Minimum("totalCoolingTime", "body", float64(*m.TotalCoolingTime), 0, false); err != nil {
		return err
	}

	if err := validate.Maximum("totalCoolingTime", "body", float64(*m.TotalCoolingTime), 10, false); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MachineConfiguration) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MachineConfiguration) UnmarshalBinary(b []byte) error {
	var res MachineConfiguration
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
