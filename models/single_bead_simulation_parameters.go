// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SingleBeadSimulationParameters single bead simulation parameters
// swagger:model SingleBeadSimulationParameters
type SingleBeadSimulationParameters struct {

	// Must be between 0.001 to 0.01 meters
	// Required: true
	// Maximum: 0.01
	// Minimum: 0.001
	BeadLength *float64 `json:"beadLength"`

	// Array of Powder Laser Absorptivity Values to simulate across, Each value must be between 0% and 100%, expressed as a decimal
	// Required: true
	LaserAbsorptivityInPowderValues []*float64 `json:"laserAbsorptivityInPowderValues"`

	// Array of Solid Laser Absorptivity Values to simulate across, Each value must be between 0% and 100%, expressed as a decimal
	// Required: true
	LaserAbsorptivityInSolidValues []*float64 `json:"laserAbsorptivityInSolidValues"`

	// Array of laser power values to simulate across, Each value must be between 10 to 1000 watts
	// Required: true
	LaserWattageValues []float64 `json:"laserWattageValues"`

	// Must be between 0.00001 to 0.0001 meters
	// Required: true
	// Maximum: 0.0001
	// Minimum: 1e-05
	LayerThickness *float64 `json:"layerThickness"`

	// Array of Liquidus Temperature Values Values to simulate across
	// Required: true
	LiquidusTemperatureValues []float64 `json:"liquidusTemperatureValues"`

	// Array of Mean Free Path of Laser in Powder Values to simulate across, Each value must be between 0 and 1.25e5
	// Required: true
	MeanFreePathInPowderValues []*float64 `json:"meanFreePathInPowderValues"`

	// Array of Mean Free Path of Laser in Solid Values to simulate across, Each value must be between 0 and 1.25e5
	// Required: true
	MeanFreePathInSolidValues []*float64 `json:"meanFreePathInSolidValues"`

	// Array of Powder Packing Density Percentage Values to simulate across, Each value must be between 0% and 100%, expressed as a decimal
	// Required: true
	PowderPackingDensityValues []*float64 `json:"powderPackingDensityValues"`

	// Array of Powder Thermal Conductivity Percentage Values to simulate across, Each value must be between 0% and 100%, expressed as a decimal
	// Required: true
	PowderThermalConductivityValues []*float64 `json:"powderThermalConductivityValues"`

	// Array of scan speed values to simulate across, Each value must be between 0.01 to 10 meters/second
	// Required: true
	ScanSpeedValues []float64 `json:"scanSpeedValues"`

	// Array of Solidus Temperature Values Values to simulate across
	// Required: true
	SolidusTemperatureValues []float64 `json:"solidusTemperatureValues"`
}

// Validate validates this single bead simulation parameters
func (m *SingleBeadSimulationParameters) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBeadLength(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLaserAbsorptivityInPowderValues(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLaserAbsorptivityInSolidValues(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLaserWattageValues(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLayerThickness(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLiquidusTemperatureValues(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateMeanFreePathInPowderValues(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateMeanFreePathInSolidValues(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePowderPackingDensityValues(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePowderThermalConductivityValues(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateScanSpeedValues(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSolidusTemperatureValues(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SingleBeadSimulationParameters) validateBeadLength(formats strfmt.Registry) error {

	if err := validate.Required("beadLength", "body", m.BeadLength); err != nil {
		return err
	}

	if err := validate.Minimum("beadLength", "body", float64(*m.BeadLength), 0.001, false); err != nil {
		return err
	}

	if err := validate.Maximum("beadLength", "body", float64(*m.BeadLength), 0.01, false); err != nil {
		return err
	}

	return nil
}

func (m *SingleBeadSimulationParameters) validateLaserAbsorptivityInPowderValues(formats strfmt.Registry) error {

	if err := validate.Required("laserAbsorptivityInPowderValues", "body", m.LaserAbsorptivityInPowderValues); err != nil {
		return err
	}

	for i := 0; i < len(m.LaserAbsorptivityInPowderValues); i++ {

		if swag.IsZero(m.LaserAbsorptivityInPowderValues[i]) { // not required
			continue
		}

		if err := validate.Minimum("laserAbsorptivityInPowderValues"+"."+strconv.Itoa(i), "body", float64(*m.LaserAbsorptivityInPowderValues[i]), 0, false); err != nil {
			return err
		}

		if err := validate.Maximum("laserAbsorptivityInPowderValues"+"."+strconv.Itoa(i), "body", float64(*m.LaserAbsorptivityInPowderValues[i]), 1, false); err != nil {
			return err
		}

	}

	return nil
}

func (m *SingleBeadSimulationParameters) validateLaserAbsorptivityInSolidValues(formats strfmt.Registry) error {

	if err := validate.Required("laserAbsorptivityInSolidValues", "body", m.LaserAbsorptivityInSolidValues); err != nil {
		return err
	}

	for i := 0; i < len(m.LaserAbsorptivityInSolidValues); i++ {

		if swag.IsZero(m.LaserAbsorptivityInSolidValues[i]) { // not required
			continue
		}

		if err := validate.Minimum("laserAbsorptivityInSolidValues"+"."+strconv.Itoa(i), "body", float64(*m.LaserAbsorptivityInSolidValues[i]), 0, false); err != nil {
			return err
		}

		if err := validate.Maximum("laserAbsorptivityInSolidValues"+"."+strconv.Itoa(i), "body", float64(*m.LaserAbsorptivityInSolidValues[i]), 1, false); err != nil {
			return err
		}

	}

	return nil
}

func (m *SingleBeadSimulationParameters) validateLaserWattageValues(formats strfmt.Registry) error {

	if err := validate.Required("laserWattageValues", "body", m.LaserWattageValues); err != nil {
		return err
	}

	for i := 0; i < len(m.LaserWattageValues); i++ {

		if err := validate.Minimum("laserWattageValues"+"."+strconv.Itoa(i), "body", float64(m.LaserWattageValues[i]), 10, false); err != nil {
			return err
		}

		if err := validate.Maximum("laserWattageValues"+"."+strconv.Itoa(i), "body", float64(m.LaserWattageValues[i]), 1000, false); err != nil {
			return err
		}

	}

	return nil
}

func (m *SingleBeadSimulationParameters) validateLayerThickness(formats strfmt.Registry) error {

	if err := validate.Required("layerThickness", "body", m.LayerThickness); err != nil {
		return err
	}

	if err := validate.Minimum("layerThickness", "body", float64(*m.LayerThickness), 1e-05, false); err != nil {
		return err
	}

	if err := validate.Maximum("layerThickness", "body", float64(*m.LayerThickness), 0.0001, false); err != nil {
		return err
	}

	return nil
}

func (m *SingleBeadSimulationParameters) validateLiquidusTemperatureValues(formats strfmt.Registry) error {

	if err := validate.Required("liquidusTemperatureValues", "body", m.LiquidusTemperatureValues); err != nil {
		return err
	}

	return nil
}

func (m *SingleBeadSimulationParameters) validateMeanFreePathInPowderValues(formats strfmt.Registry) error {

	if err := validate.Required("meanFreePathInPowderValues", "body", m.MeanFreePathInPowderValues); err != nil {
		return err
	}

	for i := 0; i < len(m.MeanFreePathInPowderValues); i++ {

		if swag.IsZero(m.MeanFreePathInPowderValues[i]) { // not required
			continue
		}

		if err := validate.Minimum("meanFreePathInPowderValues"+"."+strconv.Itoa(i), "body", float64(*m.MeanFreePathInPowderValues[i]), 0, false); err != nil {
			return err
		}

		if err := validate.Maximum("meanFreePathInPowderValues"+"."+strconv.Itoa(i), "body", float64(*m.MeanFreePathInPowderValues[i]), 125000, false); err != nil {
			return err
		}

	}

	return nil
}

func (m *SingleBeadSimulationParameters) validateMeanFreePathInSolidValues(formats strfmt.Registry) error {

	if err := validate.Required("meanFreePathInSolidValues", "body", m.MeanFreePathInSolidValues); err != nil {
		return err
	}

	for i := 0; i < len(m.MeanFreePathInSolidValues); i++ {

		if swag.IsZero(m.MeanFreePathInSolidValues[i]) { // not required
			continue
		}

		if err := validate.Minimum("meanFreePathInSolidValues"+"."+strconv.Itoa(i), "body", float64(*m.MeanFreePathInSolidValues[i]), 0, false); err != nil {
			return err
		}

		if err := validate.Maximum("meanFreePathInSolidValues"+"."+strconv.Itoa(i), "body", float64(*m.MeanFreePathInSolidValues[i]), 125000, false); err != nil {
			return err
		}

	}

	return nil
}

func (m *SingleBeadSimulationParameters) validatePowderPackingDensityValues(formats strfmt.Registry) error {

	if err := validate.Required("powderPackingDensityValues", "body", m.PowderPackingDensityValues); err != nil {
		return err
	}

	for i := 0; i < len(m.PowderPackingDensityValues); i++ {

		if swag.IsZero(m.PowderPackingDensityValues[i]) { // not required
			continue
		}

		if err := validate.Minimum("powderPackingDensityValues"+"."+strconv.Itoa(i), "body", float64(*m.PowderPackingDensityValues[i]), 0, false); err != nil {
			return err
		}

		if err := validate.Maximum("powderPackingDensityValues"+"."+strconv.Itoa(i), "body", float64(*m.PowderPackingDensityValues[i]), 1, false); err != nil {
			return err
		}

	}

	return nil
}

func (m *SingleBeadSimulationParameters) validatePowderThermalConductivityValues(formats strfmt.Registry) error {

	if err := validate.Required("powderThermalConductivityValues", "body", m.PowderThermalConductivityValues); err != nil {
		return err
	}

	for i := 0; i < len(m.PowderThermalConductivityValues); i++ {

		if swag.IsZero(m.PowderThermalConductivityValues[i]) { // not required
			continue
		}

		if err := validate.Minimum("powderThermalConductivityValues"+"."+strconv.Itoa(i), "body", float64(*m.PowderThermalConductivityValues[i]), 0, false); err != nil {
			return err
		}

		if err := validate.Maximum("powderThermalConductivityValues"+"."+strconv.Itoa(i), "body", float64(*m.PowderThermalConductivityValues[i]), 1, false); err != nil {
			return err
		}

	}

	return nil
}

func (m *SingleBeadSimulationParameters) validateScanSpeedValues(formats strfmt.Registry) error {

	if err := validate.Required("scanSpeedValues", "body", m.ScanSpeedValues); err != nil {
		return err
	}

	for i := 0; i < len(m.ScanSpeedValues); i++ {

		if err := validate.Minimum("scanSpeedValues"+"."+strconv.Itoa(i), "body", float64(m.ScanSpeedValues[i]), 0.01, false); err != nil {
			return err
		}

		if err := validate.Maximum("scanSpeedValues"+"."+strconv.Itoa(i), "body", float64(m.ScanSpeedValues[i]), 10, false); err != nil {
			return err
		}

	}

	return nil
}

func (m *SingleBeadSimulationParameters) validateSolidusTemperatureValues(formats strfmt.Registry) error {

	if err := validate.Required("solidusTemperatureValues", "body", m.SolidusTemperatureValues); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SingleBeadSimulationParameters) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SingleBeadSimulationParameters) UnmarshalBinary(b []byte) error {
	var res SingleBeadSimulationParameters
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
